<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Flying Huster</title>
  
  <subtitle>记录科研生活的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.flyinghuster.com/"/>
  <updated>2020-01-10T02:09:21.431Z</updated>
  <id>https://www.flyinghuster.com/</id>
  
  <author>
    <name>刘中岳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用MapReduce实现倒排索引</title>
    <link href="https://www.flyinghuster.com/%E4%BD%BF%E7%94%A8MapReduce%E5%AE%9E%E7%8E%B0%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    <id>https://www.flyinghuster.com/%E4%BD%BF%E7%94%A8MapReduce%E5%AE%9E%E7%8E%B0%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</id>
    <published>2020-01-09T18:03:42.980Z</published>
    <updated>2020-01-10T02:09:21.431Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><p>任务描述<br>本关任务：编写 MapReduce 实现倒排索引。</p><p>相关知识<br>什么是MapReduce<br>MapReduce 是一种可用于数据处理的编程模型，我们现在设想一个场景，你接到一个任务，任务是：挖掘分析我国气象中心近年来的数据日志，该数据日志大小有 3T ，让你分析计算出每一年的最高气温，如果你现在只有一台计算机，如何处理呢？我想你应该会读取这些数据，并且将读取到的数据与目前的最大气温值进行比较。比较完所有的数据之后就可以得出最高气温了。不过以我们的经验都知道要处理这么多数据肯定是非常耗时的。</p><p>如果我现在给你三台机器，你会如何处理呢？看到下图你应该想到了：最好的处理方式是将这些数据切分成三块，然后分别计算处理这些数据（ Map ），处理完毕之后发送到一台机器上进行合并（ merge ），再计算合并之后的数据，归纳（ reduce ）并输出。</p><p>这就是一个比较完整的 MapReduce 的过程了。</p><p><img src="/使用MapReduce实现倒排索引/1.jpg" alt></p><p>如何使用MapReduce进行运算<br>我们通过一个示例，来体验 Map/Reduce 的使用。</p><p>我们从一个问题入手：目前我们想统计两个文本文件中，每个单词出现的次数。</p><p>首先我们在当前目录下创建两个文件：</p><p>创建file01输入内容：</p><p>Hello World Bye World<br>创建file02输入内容：</p><p>Hello Hadoop Goodbye Hadoop<br>将文件上传到 HDFS 的/usr/input/目录下：</p><p>不要忘了启动 DFS：</p><p>start-dfs.sh</p><p>然后创建文件夹并上传：</p><p><img src="/使用MapReduce实现倒排索引/2.jpg" alt></p><p>在右侧代码区域编写，文件WordCount.java，添加如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> </span></span><br><span class="line"><span class="class">       <span class="title">extends</span> <span class="title">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Text <span class="keyword">word</span> = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context</span></span></span><br><span class="line">                    ) throws IOException, InterruptedException &#123;</span><br><span class="line">      StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">      <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">        <span class="keyword">word</span>.<span class="built_in">set</span>(itr.nextToken());</span><br><span class="line">        context.<span class="built_in">write</span>(<span class="keyword">word</span>, one);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> </span></span><br><span class="line"><span class="class">       <span class="title">extends</span> <span class="title">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span></span><br><span class="line">    <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, </span></span></span><br><span class="line"><span class="function"><span class="params">                       Context context</span></span></span><br><span class="line">                       ) throws IOException, InterruptedException &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">        sum += val.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="built_in">set</span>(sum);</span><br><span class="line">      context.<span class="built_in">write</span>(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Job job = <span class="keyword">new</span> Job(conf, <span class="string">"word count"</span>);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    <span class="keyword">String</span> inputfile = <span class="string">"/usr/input"</span>;</span><br><span class="line">    <span class="keyword">String</span> outputFile = <span class="string">"/usr/output"</span>;</span><br><span class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(inputfile));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(outputFile));</span><br><span class="line">    System.<span class="built_in">exit</span>(job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击评测，运行代码，可以看到/usr/output目录下已经生成了文件。</p><p><img src="/使用MapReduce实现倒排索引/3.jpg" alt></p><p>我们来查看part–r-00000文件的内容：</p><p><img src="/使用MapReduce实现倒排索引/4.jpg" alt></p><p>可以看到统计的数据已经生成在文件中了。</p><p>如果你还想要运行一次，那么你需要删除输出路径的文件夹和文件。</p><p>代码解释<br>示例中，Map/Reduce 程序总共分为三块即：Map，Reduce，Job，Map 负责处理输入文件的内容。</p><p>TokenizerMapper 的 map 方法，它通过 StringTokenizer 以空格为分隔符将一行切分为若干 tokens ，之后，输出 &lt; , 1&gt; 形式的键值对。</p><p>对于示例中的第一个输入， map 输出是：</p><p>&lt; Hello, 1&gt;</p><p>&lt; World, 1&gt;</p><p>&lt; Bye, 1&gt;</p><p>&lt; World, 1&gt;</p><p>第二个输入，map 输出是：</p><p>&lt; Hello, 1&gt;</p><p>&lt; Hadoop, 1&gt;</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 1&gt;</p><p>WordCount 还指定了一个 combiner 。因此，每次 map 运行之后，会对输出按照 key 进行排序，然后把输出传递给本地的 combiner （按照作业的配置与 Reducer 一样），进行本地聚合。</p><p><img src="/使用MapReduce实现倒排索引/5.jpg" alt></p><p>第一个 map 的输出是：</p><p>&lt; Bye, 1&gt;</p><p>&lt; Hello, 1&gt;</p><p>&lt; World, 2&gt;</p><p>第二个 map 的输出是：</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 2&gt;</p><p>&lt; Hello, 1&gt;</p><p>reduce 收到的数据是这样的：</p><p>&lt; Bye , [1]&gt;</p><p>&lt; GoodBye , [1]&gt;</p><p>&lt; Hadoop , [1,1]&gt;</p><p>&lt; Hello , [1,1]&gt;</p><p>&lt; World , [1,1]&gt;</p><p>Reducer 中的 reduce 方法 仅是将每个 key（本例中就是单词）出现的次数求和。</p><p>因此这个作业的输出就是：</p><p>&lt; Bye, 1&gt;</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 2&gt;</p><p>&lt; Hello, 2&gt;</p><p>&lt; World, 2&gt;</p><p>编程要求<br>根据提示，在右侧编辑器的中的 begin-end 间补全 InvertIndex_origin 类中的 map 和 reduce 函数。具体实现如下。</p><p>读取 hdfs 中/input目录下的如下三个文件，文件内容如下：</p><p>file1.txt内容：</p><p>mapreduce is simple</p><p>file2.txt内容：</p><p>mapreduce is powerful and simple</p><p>file3.txt内容：</p><p>mapreduce and mapreduce<br>使用 mapreduce 处理后把结果输出到 hdfs 的/out目录下，预期输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and file3.txt:1;file2.txt:1;</span><br><span class="line">is file2.txt:1;file1.txt:1;</span><br><span class="line">mapreduce file1.txt:1;file2.txt:1;file3.txt:2;</span><br><span class="line">powerful file2.txt:1;</span><br><span class="line">simple file2.txt:1;file1.txt:1;</span><br><span class="line">后台会自动把代码打包并执行以下命令提交：</span><br></pre></td></tr></table></figure><p>hadoop jar /root/invertedindex-1.0-SNAPSHOT.jar InvertIndex_origin /invertindex /out</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;任务描述&lt;br&gt;本关任务：编写 MapReduce 实现倒排索引。&lt;/p&gt;&lt;p&gt;相关知识&lt;br&gt;什么是MapReduce&lt;b
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="https://www.flyinghuster.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MapReduce" scheme="https://www.flyinghuster.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce/"/>
    
    
      <category term="MapReduce" scheme="https://www.flyinghuster.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>现代计算机网络复习笔记</title>
    <link href="https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-01-03T08:22:48.000Z</published>
    <updated>2020-01-06T14:34:33.265Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="Ch1-1-体系结构"><a href="#Ch1-1-体系结构" class="headerlink" title="Ch1-1 体系结构"></a>Ch1-1 体系结构</h2><ol><li><p>网络的基本概念</p><p> 逻辑链路：<br> 在两点间通过通信协议的作用建立起来的数据联结通路<br> 通路(Path):<br> 从源点到宿点所经过的一串节点和链路的有序集。或端到端的通路<br> 协议（Protocol）<br> 多个进程为完成一个任务而共同遵守的动作序列规范<br> 三要素：语法、语义、规则(同步时序)<br> 网络云：<br> 区分通信子网交换交换结点（云内）和资源主机结点（云外）的分界<br>线，可表示任何网络（单、多、交换等）</p><p> 第一层：Backbone中转网：国家或世界级网络主干<br>美NFSnet/欧Ebone/中Chinanet/CERNET<br> 第二层：Transit地区性网：覆盖省、洲、国家,<br>提供到因特网的连接<br>因特网服务提供者ISP<br> 第三层：Stub组织性网：本地服务提供商；<br>是一个自治网络系统，有AS号<br>校园网、企业网、公司网、政府网<br>由外围网关接入地区性网络</p></li><li><p>性能参数<br> 性能测量的两个参数：带宽和延迟<br> 带宽(Bandwidth):Hz,KHz,MHz,GHz，bps<br> 信号带宽：构成一信号的各种不同频率成分所占据的频率范围。如人类声音<br>带宽为：3300Hz－300＝声音带宽3000Hz<br> 媒体带宽：通信媒体允许通过的信号频带范围<br> 比特率：某时段内网络上可能传输的比特数，或传输每比特数据所需的时间<br>宽度。习惯把“带宽”作为数字信道的数据率或比特率<br> 比特率越高，高频分量越多，频率范围越大，信号带宽越高。<br> 吞吐率(Throughput)：bps<br> 数字信号的发送速率，因此发送带宽也成为吞吐率<br> 由于各种影响 10M 带宽实际完成 2Mbps<br> 吞吐率：链路上实际每秒传输的比特数</p></li></ol><pre><code>延迟： Delay : 把一个报文从网络一端传输到另一端所需的时间one way，光传播速度： 3.0x108m/s ;光在真空内传播的速率 2.8x108m/s ;电在Cable内传播的速率 2.0x108m/s ;光在Fiber内传播的速率 Round Trip Time (RTT):发收来回时间（2次时延） 定义：延迟 = 处理＋排队+传输+传播，主要考虑后两个 处理时延：检查包首部、决定导向何处；比特差错检测，高速Router一般在微秒或更低数量级，接收完整的一个分组的时间＝包容量/链路速率 排队时延：等待输出链路空闲，与当时流量和排队规则有关 传输时延：数据量/带宽；微秒到毫秒级 传播时延：距离/光速(光缆中1000km传播延迟约5ms) 广域网在毫秒级 端到端吞吐率 = 实际传输大小/传输时间 实际传输时间 = RTT+ 传输大小/信道带宽 RTT：请求与回答时间</code></pre><p> 问题：信道带宽1Gbps，一端到另一端传播时<br>延τ= 10ms，TCP发送窗口65535字节。问可<br>能达到的最大吞吐率T ？信道利用率ρ？<br> 解析：T= size/(2τ+size/BW)<br> = size<em>BW/(2τ</em>BW+size) bps<br> = 65535<em>8</em>109/(20<em>109</em>10-3s+65535<em>8)bps<br> = 524280</em>103/(20 *106 +524280)Mbps<br> = 25.5 Mbps，ρ=25.5M/1000M=2.55%</p><p> 带宽和延迟的组合可描述链路或信道的特征，其相对重<br>要性取决于具体的应用<br> 有些应用延迟支配带宽（SSH），如端客户发送1字节到服务器<br>并依次收到1字节就是延迟重要，如果响应中没有大量的计算，<br>由于跨洲信道要100ms的RTT，同一房间内仅1ms RTT，所以不<br>同延迟导致完全不同效果<br> 数字图书馆来说是带宽支配延迟。设带宽10Mbps,则需<br>20s(2.5MByte的一个图片)，信道是1ms或者100ms延迟不重要，<br>20.001s和20.1s之差可略</p><p>延迟带宽积（以太网相关参数）<br> 一对进程通道间的延迟(总体延迟)带宽积：信道管道的体积=链路上所<br>容纳的比特数<br> 一个信道延迟=50ms ,带宽45Mbps, 则能容纳=50ms<em> 45Mbps=50</em>10-<br>3 sec*45Mbits/sec =2.25Mbits<br> 等价于信道上同时可以存在281K个Byte信号（2.25M/8）</p><ol start="3"><li>习题<br> 假设在地球和月球间建立一点对点100MPS的连接，地<br>月距离为385,000KM，数据传播速度为光速（3<em>108<br>M/S）<br> A．计算最小的RTT<br> B．use the RTT as the delay , calculate the delay</em>bandwidth<br>product for the link<br> C. 在B中计算的delay*bandwidth有何意义？<br> D．在月球照的照片，并以数字格式存在磁盘上。如果地球上的<br>控制中心想下载25M的最新的图形，那么从发出数据到传输完成<br>所要的最小时间是多少？</li></ol><h2 id="Ch1-2-直连网络技术"><a href="#Ch1-2-直连网络技术" class="headerlink" title="Ch1-2 直连网络技术"></a>Ch1-2 直连网络技术</h2><h2 id="Ch1-3-报文交换"><a href="#Ch1-3-报文交换" class="headerlink" title="Ch1-3 报文交换"></a>Ch1-3 报文交换</h2><h2 id="Ch1-4-TCP-IP网络技术"><a href="#Ch1-4-TCP-IP网络技术" class="headerlink" title="Ch1-4 TCP/IP网络技术"></a>Ch1-4 TCP/IP网络技术</h2><h1 id="第二章-IPv6"><a href="#第二章-IPv6" class="headerlink" title="第二章 IPv6"></a>第二章 IPv6</h1><ol><li><p>IPv4和IPv6差异？</p></li><li><p>IPv6地址分类和特点</p></li><li><p>IPv6地址自动分配两种方式, stateless过程</p></li><li><p>IPv6邻居发现协议中：地址解析和DAD</p></li><li><p>IPSec基本概念</p></li></ol><h1 id="第三章-拥塞控制"><a href="#第三章-拥塞控制" class="headerlink" title="第三章 拥塞控制"></a>第三章 拥塞控制</h1><ol><li>拥塞控制基本概念</li></ol><ul><li>Power=吞吐率/延迟</li><li>公平的定义</li></ul><ol start="2"><li>排队算法： FIFO, fQ, wfq</li><li>流量整形：漏桶、令牌桶算法（PPT习题）</li><li>TCP拥塞控制机制（慢启动、拥塞避免、快乘船、快速回复）</li><li>拥塞避免：ECN，RED，TCP Veges算法</li></ol><h1 id="第四章-P2P"><a href="#第四章-P2P" class="headerlink" title="第四章 P2P"></a>第四章 P2P</h1><ol><li>三代P2P网络之间的定义和差异是什么？</li></ol><ul><li>第一代：混合式P2P网络（第一代）</li></ul><p> 拓扑结构：服务器仍然是网络的核心<br> 底层协议：全部使用TCP，限制了链接的Peer数量<br> 查询与路由简单高效：<br> Napster和BT的用户访问服务器；服务器返回文件索引或种子文件<br>；用户再直接同另一Peer连接<br> 故路由跳数为O(1)，即常数跳<br> 容错、自适应和匿名性<br> 服务器单点失效率高<br> 自组织和自适应主要依靠服务器<br> 服务器的存在使匿名性实际不可能<br> 用户接入无安全认证机制</p><ol><li>Napster和Gnutella的原理</li></ol><ul><li>第二代：非结构化P2P网络（第二代）</li></ul><ul><li>第三代：结构化P2P网络(第三代)</li></ul><ol><li>掌握Chord协议</li></ol><ol start="2"><li>理解Kademlia的原理，例如Kademlia协议是如何找到资源的</li></ol><ol start="3"><li>掌握Bitcoin原理（论文）以及区块链概念</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://www.flyinghuster.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="考试" scheme="https://www.flyinghuster.com/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>现代计算机网络lab03-TCP Congestion性能测试分析</title>
    <link href="https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab03-TCP%20Congestion%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/"/>
    <id>https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab03-TCP%20Congestion%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/</id>
    <published>2019-12-21T05:23:31.654Z</published>
    <updated>2020-01-14T09:14:43.768Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="GNS3下的TCP-Congestion测试"><a href="#GNS3下的TCP-Congestion测试" class="headerlink" title="GNS3下的TCP Congestion测试"></a>GNS3下的TCP Congestion测试</h1><p>在GNS3中创建一个新项目，用三台SEED虚拟机按照如图方式连接起来(参考实验1，三台虚拟机分别为SEEDClient，SEED-Router，SEED-Server)，配置IP地址，让他们可以互相通信 如果物理机器性能一般，请用slitaz代替<br>SEED，不过必须自己安装一些软件，安装软件参考： slitaz文档：<a href="http://doc.slitaz.org" target="_blank" rel="noopener">http://doc.slitaz.org</a></p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/1.jpg" alt><br>注意的地方： 在GNS3中先给每台虚拟机配置三个网卡：</p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/2.jpg" alt></p><p>eth0网卡不要在GNS3中使用，而是用VirtualBox如下配置：</p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/3.jpg" alt><br>可以发现虚拟机可以同时访问外部网络<br>在SEED-Client和SEED-Server上安装iperf软件</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install iperf</span><br></pre></td></tr></table></figure><h1 id="Linux下的TCP拥塞控制算法"><a href="#Linux下的TCP拥塞控制算法" class="headerlink" title="Linux下的TCP拥塞控制算法"></a>Linux下的TCP拥塞控制算法</h1><ul><li>列出所有直接编译到内核的拥塞控制算法：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">cubic reno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/4.jpg" alt></p><ul><li><p>修改当前的拥塞控制算法：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_congestion_control=cubic</span><br></pre></td></tr></table></figure></li><li><p>增加新的拥塞控制算法： linux支持的拥塞控制算法：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>怎么加载这些内核模块，来运行新的拥塞控制算法：<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#echo "westwood" &gt; /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line"><span class="comment">#cat /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line">westwood</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#echo "westwood" &gt; /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line"><span class="comment">#lsmod | grep westwood</span></span><br><span class="line">tcp_westwood 12675 0</span><br></pre></td></tr></table></figure><p></p><p>各种拥塞控制算法简介：</p><ul><li>High Speed TCP<br>The algorithm is described in RFC 3649. The main use is for connections with large<br>bandwidth and large RTT (such as Gbit/s and 100 ms RTT).</li><li>H-TCP<br>H-TCP was proposed by the Hamilton Institute for transmissions that recover more<br>quickly after a congestion event. It is also designed for links with high bandwidth and<br>RTT.</li><li>Scalable TCP<br>This is another algorithm for WAN links with high bandwidth and RTT. One of its design<br>goals is a quick recovery of the window size after a congestion event. It achieves this<br>goal by resetting the window to a higher value than standard TCP.<br>3.从SEED-Client虚拟机发包测试<br>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic<br>先在SEED-Server端运行下面的命令，让iperf的服务器端运行守护在5001端口：<br>在SEED-Client端运行下面的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参<br>数变化：</li><li>TCP BIC<br>BIC is the abbreviation for Binary Increase Congestion control. BIC uses a unique<br>window growth function. In case of packet loss, the window is reduced by a<br>multiplicative factor. The window size just before and after the reduction is then used<br>as parameters for a binary search for the new window size. BIC was used as standard<br>algorithm in the Linux kernel.</li><li>TCP CUBIC<br>CUBIC is a less aggressive variant of BIC (meaning, it doesn’t steal as much throughput<br>from competing TCP flows as does BIC).</li><li>TCP Hybla<br>TCP Hybla was proposed in order to transmit data efficiently over satellite links and<br>“defend” the transmission against TCP flows from other origins.</li><li>TCP Low Priority<br>This is an approach to develop an algorithm that uses excess bandwidth for TCP flows.<br>It can be used for low priority data transfers without “disturbing” other TCP<br>transmissions (which probably don’t use TCP Low Priority).</li><li>TCP Tahoe/Reno<br>These are the classical models used for congestion control. They exhibit the typical<br>slow start of transmissions. The throughput increases gradually until it stays stable.<br>It is decreased as soon as the transfer encounters congestion, then the rate rises<br>again slowly. The window is increased by adding fixed values. TCP Reno uses a<br>multiplicative decrease algorithm for the reduction of window size. TCP Reno is the<br>most widely deployed algorithm.</li><li>TCP Vegas<br>TCP Vegas introduces the measurement of RTT for evaluating the link quality. It uses<br>additive increases and additive decreases for the congestion window.</li><li>TCP Veno<br>This variant is optimised for wireless networks, since it was designed to handle random<br>packet loss better. It tries to keep track of the transfer, and guesses if the quality<br>decreases due to congestion or random packet errors.</li><li>TCP Westwood+<br>Westwood+ addresses both large bandwidth/RTT values and random packet loss together<br>with dynamically changing network loads. It analyses the state of the transfer by<br>looking at the acknowledgement packets. Westwood+ is a modification of the TCP Reno<br>algorithm.</li></ul><h1 id="从SEED-Client虚拟机发包测试"><a href="#从SEED-Client虚拟机发包测试" class="headerlink" title="从SEED-Client虚拟机发包测试"></a>从SEED-Client虚拟机发包测试</h1><p>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic<br>先在SEED-Server端运行下面的命令，让iperf的服务器端运行守护在5001端口：<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iperf -s</span></span><br></pre></td></tr></table></figure><p></p><p>在SEED-Client端运行下面的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参<br>数变化：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe tcp_probe port=5001 //对端口为5001（源或目的）的tcp连接进行监控</span></span><br><span class="line"><span class="comment"># cat /proc/net/tcpprobe &gt; data.txt &amp; // tcpprobe捕捉的信息是持续性的，可以放到后台读</span></span><br><span class="line"><span class="comment"># pid=$! // 保存上一个读命令的pid，用于结束读tcpprobe接口</span></span><br><span class="line"><span class="comment"># iperf -c otherhost // 使用iperf建立一个TCP流</span></span><br><span class="line"><span class="comment"># kill $pid</span></span><br></pre></td></tr></table></figure><p>在文件data.txt中保存了tcp的拥塞窗口变化情况，可以通过虚拟机共享目录或者网络导出，作为实验数据，iperf运<br>行结果：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/5.jpg" alt></p><p>记录在data.out中的数据大致是这个样子：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11.172120204 193.168.0.2:8089 193.168.0.25:54320 32 0x842ccad 0x84299c5 10 168 14608</span><br><span class="line">143</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行的各列分别为：</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timestamp //时间戳</span><br><span class="line">saddr:port // 源IP及端口，我的数据是在发送端捕捉的，所以port是固定的8089</span><br><span class="line">daddr:port // 目的IP及端口</span><br><span class="line">skb-&gt;len // 收到的数据包skb大小，收到的都是ACK包，所以len都比较小。</span><br><span class="line">snd_nxt // 下一个待发送数据的序列号</span><br><span class="line">snd_una // 待确认数据的序列号</span><br><span class="line">snd_cwnd // 拥塞窗口大小</span><br><span class="line">ssthresh // 慢启动阈值</span><br><span class="line">snd_wnd // 接收窗口大小</span><br><span class="line">srtt // smoothed RTT</span><br></pre></td></tr></table></figure><p>实际的例子，看到拥塞窗口线性增加：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/6.jpg" alt><br>看到拥塞窗口线性减少，ssthresh折半回退（跟特定的拥塞控制算法相关例如Vegas）：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/7.jpg" alt></p><h1 id="增加延迟"><a href="#增加延迟" class="headerlink" title="增加延迟"></a>增加延迟</h1><p>可以在SEED-Router这台虚拟机连接SEED-Server网卡上增加延迟和丢包来改变网络环境，利用的是Linux中的<br>iproute 工具，以及内核中的Network Simulator特性：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tc qdisc change dev eth0 root netem loss 2.5%</span></span><br><span class="line">设置丢包</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem delay 30ms 10ms</span></span><br><span class="line">设置延迟</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem duplicate 1%</span></span><br><span class="line">该命令将 eth0 网卡的传输设置为随机产生 1% 的重复数据包</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem corrupt 0.2%</span></span><br><span class="line">该命令将 eth0 网卡的传输设置为随机产生 0.2% 的损坏的数据包</span><br><span class="line">删除网卡上面的相关配置，将之前命令中的 add 改为 del 即可删除配置</span><br></pre></td></tr></table></figure><p>qdisc表示在网卡上的排队策略，可以通过ifconfig命令查看：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@dl:~<span class="comment"># ip link show</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,PROMISC,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100</span><br><span class="line">link/ether 52:54:00:de:bf:19 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>qdisc支持的排队策略包括：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FIFO - simple FIFO (packet (p-FIFO) or byte (b-FIFO) )</span><br><span class="line">PRIO - n-band strict priority scheduler</span><br><span class="line">TBF - token bucket filter</span><br><span class="line">CBQ - class based queue</span><br><span class="line">CSZ - Clark-Scott-Zhang</span><br><span class="line">SFQ - stochastic fair queue</span><br><span class="line">RED - random early detection</span><br><span class="line">GRED - generalized random early detection</span><br><span class="line">TEQL - traffic equalizer</span><br><span class="line">ATM - asynchronous transfer mode</span><br><span class="line">DSMARK - DSCP (Diff-Serv Code Point)marker/remarker</span><br></pre></td></tr></table></figure><p>如果条件所限，还可以利用Linux防火墙来进行丢包，在Router上运行以下命令，实现0.5%的丢包<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 121.14.48.1 -m statistic --mode random --probability 0.005 -j DROP</span><br></pre></td></tr></table></figure><p></p><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>根据以上网络配置和TCP性能测试方案，改变Router的延迟和丢包来测试TCP拥塞控制算法的性能：</p><ol><li>选择Linux内核支持的三种拥塞控制算法</li><li>针对每种拥塞控制算法进行性能测试，在性能测试中改变SEED-Router的丢包率和延迟，得到不同的性能测试<br>结果，记录测试结果</li><li>如果性能不行，换成slitaz虚拟机测试（需要编译内核）</li><li>对实验结果进行分析和比较</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;GNS3下的TCP-Congestion测试&quot;&gt;&lt;a href=&quot;#GNS3下的TCP-Congestion测试&quot;
      
    
    </summary>
    
    
      <category term="计算机网路" scheme="https://www.flyinghuster.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"/>
    
      <category term="性能分析" scheme="https://www.flyinghuster.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
      <category term="网络实验" scheme="https://www.flyinghuster.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>现代计算机网络lab02-实验报告</title>
    <link href="https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab02-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab02-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</id>
    <published>2019-12-06T22:21:21.343Z</published>
    <updated>2019-12-21T13:25:05.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h2 id="环境（详细说明实验运行的操作系统，网络平台，机器的配置）"><a href="#环境（详细说明实验运行的操作系统，网络平台，机器的配置）" class="headerlink" title="环境（详细说明实验运行的操作系统，网络平台，机器的配置）"></a>环境（详细说明实验运行的操作系统，网络平台，机器的配置）</h2><p>操作系统：Windows 10 64bit Pro 1909</p><p>处理器：Intel® Xeon® CPU E3-1505M v6 \@ 3.00GHz</p><p>内存：DDR4 2666MHZ 24GB ECC</p><p>网络平台：GNS3 2.2.3</p><p>虚拟机软件：Oracle VM VirtualBox 6.0.14</p><p>虚拟机：Ubuntu 16.04 32bit</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>学会利用GNS3网络平台搭建网络拓扑结构并配置主机的IP和路由。</p></li><li><p>掌握SYN flood攻击的基本原理，利用虚拟机实现SYN flood攻击。</p></li><li><p>掌握SYN cookie的原理，并通过实验证明SYN cookie机制的有效性。</p></li><li><p>了解Linux内核TCP SYN Cookie机制，掌握查看与修改方法。</p></li></ol><a id="more"></a><h2 id="实验步骤（包括主要流程和说明）"><a href="#实验步骤（包括主要流程和说明）" class="headerlink" title="实验步骤（包括主要流程和说明）"></a>实验步骤（包括主要流程和说明）</h2><h3 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h3><p>（1）从<a href="https://seedsecuritylabs.org/" target="_blank" rel="noopener">https://seedsecuritylabs.org/</a>下载SEEDUbuntu的“<a href="http://www.cis.syr.edu/~wedu/SEEDUbuntu-16.04-32bit.zip" target="_blank" rel="noopener">SEEDUbuntu-16.04-32bit.zip</a>”虚拟机文件。</p><p>（2）在VirtualBox中新建虚拟机，名称为SEEDUbuntu，类型为Linux，版本选择Ubuntu(32-bit)，其他使用默认配置，虚拟硬盘使用下载下来的“SEEDUbuntu-16.04-32bit.vmdk”,<br>点击创建进行虚拟机的创建，如下图所示。</p><p><img src="/现代计算机网络lab02-实验报告/3747dc0504c2cd3d7731c9b8f9a1f29e.png" alt="Create Virtual Machine Name and operating system Please cloøse a name and destination fold« for the new virtual machine and the tyJ\* of 01\*ratinq system you intend to instan on it. The name you choose Will be to id81tify this Name: Machine Folder : Type: Versm: SEEDIJbtntu C: VMS Limn Ubuntu (32 -bit) Expat Mode "></p><p><img src="/现代计算机网络lab02-实验报告/6226f40853c94844d4ce61524341ba5d.png" alt="Create Virtual Machine Memory size the amount of (MM) in megabytß to al&amp;ated to recornrrpnded mervnry size is 1024 MB. 16384 MB "></p><p><img src="/现代计算机网络lab02-实验报告/d152f48948906279b9dbf0c36ffc37cb.png" alt="Create Virtual Machine Hard disk If wish pu can add a virtual hard disk to machine. You can either create a new hard disk file select from the list from another location using the fokkr ion. If a more complex storage set-up pu can skip this step and make the changes to the machine is created. recornrrpnded size Of the hard disk 10.00 GB. C) Do not add a virtual hard disk C) Create a virtual hard disk now \@ an existing virtual hard disk file SEEDUbuntwt&amp;04-32bitvrndk (Normal, 20.00 GB) "></p><p>图1：新建SEED虚拟机</p><p>（3）采用完全复制的方式复制上一步创建的虚拟机，并将其命名为SEEDUbuntuTarget，复制完成后结果如下。</p><p><img src="/现代计算机网络lab02-实验报告/d6cba6ded0a79a75cd4b1b240ed42df3.png" alt="Clone Virtual Machine New machine name and path Please ctu:nse a name and optbnally a folder for the virtual The machine a done of the machine SEEDUbuntu Name: VMS MAC Adüess Pdicy: Include only NAT network adapter MAC addresses Options: Keg) Disk Ke\&lt;) LNJIDS Expert "></p><p><img src="/现代计算机网络lab02-实验报告/243afc927eaad303f0745fee1a109cb1.png" alt="Clone Virtual Machine Clone type Please clA)se the type of you wish to create. If you choose Full done, an exact copy (induding all virtual hard disk files) of the original virtual machine will be created. If you choose LinkcKi clone, a new machine will but the virtual hard disk files will be tied to the virtual hard disk files of original machine and you will not be able to move the new virtual machine to a different computer without the original as wen \_ If create a Linked done then a new snapshot will be creat«l the virtual machime as part of the ckming process. \@ Full C) Link«l done "></p><p><img src="/现代计算机网络lab02-实验报告/3363c5420a3d7b2e16abf92e46555e0f.png" alt="Oracle VM VirtualBox Manager tile Machine Help Tools New General powered Off System Power«f Off powered Off SEEDUbuntu SEEDtJbuntuTarget Power«t Off Discard Start preview Settings File Ltxation: IJbLmtu (32 -bit) C: W oha n\\VEtualBox VMs\\SEEDUbuntu SEEDUbuntu Base Manor/ : Oder: Acceleration: Memory 1024 MB Floppy, (Xtical, Hard Disk VT-x/AMD-V, Nested Paging, PAE/ NX, KVM paravirtualization Graphics Controller : Remote Desktop Sever: Recording: Controller: IDE IDE Master: controller: SATA SATA port O: Audio Host Driver: Wincbws Di 16 MB Disabled [Optical (Yive] Empty SEEDtnmJntu-16.04-32bt.vmdk (My-mal, GB) "></p><p>图2：复制虚拟机副本SEEDUbuntuTarget</p><p><img src="/现代计算机网络lab02-实验报告/1cafaae1dd97571a69a44af854d02966.png" alt></p><p><img src="/现代计算机网络lab02-实验报告/5cb83e6c02818ec3ca1d54e07fda6b00.png" alt></p><p>（4）打开GNS3，新建一个名为lab02的工程。通过Edit->Preferences->VirtualBox<br>VMs，将上一步创建的两个虚拟机新建为VM<br>templates，并通过Edit按钮修改网卡（网卡驱动需设置为通用驱动）数量为3，勾选“Allow<br>GNS3 to use any configured VirtualBox<br>adapter”选框，这样就创建好了两个虚拟机模板。</p><p><img src="/现代计算机网络lab02-实验报告/0a4e6fcdf7537880010b0460c3964d57.png" alt="• Preferences General Server GNS3 VM Packet capture • Built-in Ethernet hubs Ethernet switches Cloud nodes • vpcs vpcs nodes Dynami ps IOS routers • IOS on UNIX IOU Devices • QEMU Qemu VMS • VirtualBox VirtualBox VMS • VMware VMware VMS • Docker Docker containers VirtualBox VM ubuntul u buntu2 u buntu3 tem lates SEEDUbuntu SEEDUbuntuTarget General Template name: Template ID VirtualBox name: RAM: Server: Headless mode enabled: On close: Linked base VM: Console type: Auto start console: Adapters: Name format: Use any adapter: Type: SEEDUbuntu 8b1d7099-82d4-48f8-a80e-83S2b4f98aaO SEEDUbuntu 1024 LAPTOP-BH6AKUC False power_off False none False Ethernet(O} False Intel PRO/IOOO MT Desktop (82540EM) "></p><p>图3：新建虚拟机模板</p><p>（5）将两台虚拟机连成如下拓扑结构。</p><p><img src="/现代计算机网络lab02-实验报告/28f240d0e15f231329efd64b624f9aa7.png" alt="• lab02 GNS3 Edit View Control Node Annotate Security filter Jools Help ATM s.. Cloud EttH.. Console GNS3 managerrænt console. SEEDUbuntu-1 SEEDUbuntuTarget-1 Topology Summary NO de B SEEDUbuntu-1 SEEDClbuntuTarget-I Servers Summary LAPTOP-BH6AKL1.„ Running GNS3 version 2_2.3 on Windows (64-bit) with Python 3.68 Qt 5.12.1 and PyQt 5.12. copyright (c) 2006-2019 GNS3 Technologies. HAP •\&gt; GNS3 to detect ca-nrnon issues. "></p><p>图4：网络和拓扑结构</p><p>（6）分别启动两台虚拟机（注意要在GNS3中启动，在VirtualBox中启动的无法连接上），重设两台虚拟机的网卡名称，并设置IP地址和路由。详细步骤如下：</p><ol><li>重设虚拟机网卡名称</li></ol><p>sudo vim /etc/default/grub</p><p>找到GRUB_CMDLINE_LINUX=””</p><p>改为GRUB_CMDLINE_LINUX=”net.ifnames=0 biosdevname=0”</p><p>之后在terminal中键入sudo grub-mkconfig -o /boot/grub/grub.cfg</p><p>重启后，网卡名称变成了eth0。</p><p><img src="/现代计算机网络lab02-实验报告/73e4a9c5ca55a9bd10477f16ffa4db5a.png" alt="SEEDUbuntu [Running] - Oracle VM Virtua130x Help \# /boot/grub/grub.cfg. \# For full documentation of the options in this file, \# info -f grub -n &#39; Simple configuration&#39; GRUB DEFAULT-O HIDDEN TIMEOUT=Ø HIDDEN-TIMEOUT QUIET-true GRUB-TIMEOUt=10 see: GRUB GRUB GRUB GRUB GRUB DISTRIBUTOR=&#39;1Sb retease -i -s /dev/null Il echo Debian• CMDLINE LINUX DEFAULT-&quot;quyet splash&quot; -CMDLINÜLINUXZ net .ifnames=6 biosdevname=0&quot; \# Uncomment to enable BadRAM filtering, modify to suit your needs \# This works with Linux (no patch requi red) and with any kernel that obtains \# the memory map information from GRUB (GNU Mach, kernel of FreeBSD \#GRUB ,oxtetetete, OX89abCdef ,exetetetef&quot; \# Uncomment to disable graphical terminal (grub-pc only) \#GRUB TERMINAL=consote \# The resolution used on graphical terminal \# note that you can use only modes which your graphic card supports via VBE INSERT Top u (S L.&#39;J Right Ctrl "></p><p><img src="/现代计算机网络lab02-实验报告/978eed1663153007326ca87cff132277.png" alt="SEEDUbuntu  "></p><p><img src="/现代计算机网络lab02-实验报告/0599d8b0d46dee59167e21fe2fbf330d.jpg" alt="SEEDUbuntu "></p><p>图5：修改网卡名称</p><ol><li>设置ip地址以及默认路由：</li></ol><p>将攻击机的eth0 ipv4更改为192.168.1.1 ip address add 192.168.1.1/24 dev eth0</p><p>设置路由ip route add 192.168.1.0/24 dev eth0</p><p>设置默认路由ip route add default via 192.168.1.1</p><p>将靶机的eth0 ipv4更改为192.168.1.2 ip address add 192.168.1.2/24 dev eth0</p><p>并设置默认路由ip route add 192.168.1.0/24 dev eth0</p><p>设置默认路由ip route add default via 192.168.1.2</p><p><img src="/现代计算机网络lab02-实验报告/ed5131869a8384b25355ede9ef15af2c.jpg" alt="SEEDUbuntu [Running] &#39;bin/bash - Oracle VM VirtualBox sudo ip address add 192.168.1.1/24 dev etho Isudol password for seed: ifconfig etho ethl eth2 10 Link encap: Ethernet HWaddr inet addr: 192.168.1.1 Bcast:o.o.e.o mask:255.255.255.O inet6 addr: fe8e: Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1509 Metric: 1 RX packets:87 errors:e dropped:O overruns:e frame:O TX packets: 164 errors:O dropped:ß overruns:O carrier:e collisions:O txqueuelen: RX bytes:18987 (18.9 KB) TX bytes:23859 (23.8 KB) Link encap: Ethernet HWaddr UP BROADCAST MULTICAST tm: 1500 Metric:l RX packets:ß errors:ß dropped:e overruns:ß TX packets:O errors:ß dropped:e Overruns:e collisions:O txqueuelen:1000 RX bytes:e (e.o B) TX (0.0 B) Link encap: Ethernet HWaddr 08:00:27:52:b6:1f UP BROADCAST UTICAST tm: 1500 yetric:l frame: O carrier: 0 f rame:O carrier: 9 RX packets:ß errors:ß dropped:e overruns:e TX packets:O errors:O dropped:e overruns:O collisions:ß txqueuelen: RX bytes:e (e.o B) TX bytes:e (e.o B) Link encap: Local Loopback Right Ctrl "></p><p><img src="/现代计算机网络lab02-实验报告/589a1990a185630720d178d1dfb673f2.jpg" alt="SEEDIJbuntuTarget "></p><p><img src="/现代计算机网络lab02-实验报告/1954a7f615ba7f89f95dc1329c0c9051.jpg" alt="SEEDUbuntu [Running] Network Connections - Oracle VM VirtualBox Editing etho Connection name: etho General Ethernet DCB IPV4Settings IPv6 Method: Manual A dd re sses Address DNS servers: Search domains: DHCP dient ID: Netmask Gateway n Require IPv4 addressing for this connection to complete cancel Routes. Right Ctrl "></p><p><img src="/现代计算机网络lab02-实验报告/42816963748134669460c07ab20c1313.jpg" alt="SEEDUbuntu [Running] Network Connections - Oracle VM VirtualBox Editing etho Connection name: etho General Ethernet DCB IPV4Settings IPv6 Method: Manual A dd re sses Address DNS servers: Search domains: DHCP dient ID: Netmask Gateway n Require IPv4 addressing for this connection to complete cancel Routes. Right Ctrl "></p><p>图6：设置IP地址和默认路由</p><p>（7）检查SEEDUbuntu和SEEDUbuntuTarget能否互相ping通。</p><p><img src="/现代计算机网络lab02-实验报告/d897e05d357455175e0e28a2e5d7e5f3.jpg" alt="SEEDUbuntu [Running] - Oracle VM Virtualgox Hnln /bin/buh 192. 168 icmp¯seq=2 192. 168 .1.2: 192. 168 .1.2: 192. 168 192. 168 192. 168 .1.2: 192. 192. 168 192. 168 .1.2: 192. 168 192. 168 .1.2: 192. 168 .1.2: 192. 168 192. 168 .1.2: 192. 168 .1.2: 192.168. 1.2: 192. 168 .1.2: 192. 168 .1.2: 192. 168 .1.2: 192. 168 .1.2: ping 192.168.1 2 PING 192.168.1.2 (192.168.1.2) 56(84) 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes from f rom from from f rom from from from from from from from from from from from from from from from from 1 cmp 1 cmp .1.2: 1 cmp .1.2: 1 cmp rcmp 1 cmp lcmp icmp 192.168.1.2: icmp rcmp seq=l seW seq=7 seq=lß \_seq-12 seq=13 \_seq-15 seq=16 seq=19 seq=21 10:21 AM bytes of data. ttl=64 time—I. 39 ms ttl=64 time—O .930 ms tt1=64 time-e. 815 ms ttl=64 time—e .938 ms ttl=64 time=O.697 ms ttl=64 time-e. 706 ms ttl=64 time—e. 734 ms ttl=64 time-O. 992 ms ttl%64 time-e. 771 ms ttl=64 time—O .95ß ms tt1=64 ume=o.828 ms ttl=64 time—O. 978 ms ttl=64 time—O .881 ms tt1=64 urne=o.770 ms ttl=64 time-I .08 ms ttl=64 time—I. 40 ms tt1=64 urne=o.851 ms ttl=64 time—a. 888 ms ttl=64 time—O .894 ms tt1=64 urne=o.964 ms ttl=64 time—O. 999 ms U Right cm "></p><p><img src="/现代计算机网络lab02-实验报告/376f02a05c377b0106a078d43516504c.jpg" alt="SEEDUbuntuTarget  "></p><p>图7：检查能否ping通</p><p>（8）在SEEDUbuntuTarget上启动telnet服务。</p><p><img src="/现代计算机网络lab02-实验报告/407ee0248ec4abd4d687fd779bae3798.jpg" alt=" "></p><p>图8：启动telnet服务并查看服务状态</p><p>（9）SEEDUbuntu连接SEEDUbuntuTarget，在SEEDUbuntuTarget上用wireshark观察建立连接的过程。</p><p><img src="/现代计算机网络lab02-实验报告/53244ec3bda480b7be3d4bd0943a24bc.png" alt></p><p>图9：telnet建立连接</p><p><img src="/现代计算机网络lab02-实验报告/e49906a977102bcad03ebdee75692acb.png" alt="计算机生成了可选文字: SEEDUbuntuTarget[Running]_OracleVMVirtualBox FileMachineViewInputDevicesHelp Capturing行ometho 龔Applyadisplay鬥e「…\&lt;C辱\&gt; 23：\@5：31．4998821“ 23：\@5：31．5\@33391“ 23：\@5：31．5\@4121上 23：\@5：31．69\@\@82上 23：\@5：31．69\@21\@5“ 23：\@5：31．69\@92\@9“ 23：\@5：31．9\@645\@艺 23：\@5：31．9\@65651“ 23：\@5：31．9\@7234上 一12一\@6 23：\@5：32。196\@944一 每加峨 0 囗 11：05PM =》·Expression.. 过 No. Time 12\@19一12一\@6 22\@19一12一\@6 32\@19一12一\@6 42\@19一12一\@6 52\@19一12一96 62\@19一12一96 72\@19一12一96 82\@19一12一96 92\@19一12一\@6 Files Destination 192．168．12 192．168．1．1 192．168．1．2 192．168．1．2 192．168．1．1 192．168．1．2 192．168．1．2 192．168．1．1 192．168．1．2 192．168．1．2 ProtocolLength 《n 192．168．1．1 192．168．1．2 192．168．1．1 192．168．1．1 192．168．12 192．168．1．1 192．168．1．1 192．168．12 192．168．1．1 192．168．1．1 TELNET TELNET TCP TELNET TELNET TCP TELNET TELNET TCP TELNET 67Telnet 7\@Telnet 6646532 67Telnet 7\@Telnet 6646532 67Telnet 67Telnet 6646532 67Telnet Dat Dat 23 Dat Dat 23 Dat Dat 23 Dat Frame1：67 Ethernet11, bytes Src: WIre 〔536bits),67bytescaptured〔536 bits) 0n\@ PcsCompu_a2:ee:d4〔\@8：\@\@：27：a2：ee：d4),Dst: PcsCompu_a2：ee：d4〔\@8：9\@：27：a2：ee：d4〕 InternetProtocolVersion4，Src:192．168．1．1 TranSmlSSlOn \&gt;Telnet ControlProtocol,Src Port: 46532， Dst:192．168．1．2 DstPort:23，Seq:3566461939，Ack:283416\@292，Len: 1 \@1 27 35 \@2 f5 8d fb b5 f5 7f 4\@ c4 7\@ 17 4\@ d4 \@1 \@6 93 \@1 bc e3 5e f3 \@a c\@ a8 a8 ed \@1 da 64 \@1 4a dl c\@ a8 18 ethO:\&lt;livecaptureinproa「eSS\&gt; packets:74。Dis ed:74100·0％profile:Default 000过回姗回囗 RightCtrl"></p><p>图10：wireshark观察连接过程</p><p>（10）在SEEDUbuntuTarget上执行“netstat -n<br>–tcp”查看TCP连接状态，连接建立成功则已经配置好了SYN<br>Flooding攻击实验的实验环境，下面可以进行实验。</p><p><img src="/现代计算机网络lab02-实验报告/581a673fa6c0069acb44719080974784.jpg" alt="root\@VM: /pmc/sys/net/ipv4 root "></p><p>图11：查看TCP连接状态</p><h3 id="SYN-Flooding-Attack实验"><a href="#SYN-Flooding-Attack实验" class="headerlink" title="SYN Flooding Attack实验"></a>SYN Flooding Attack实验</h3><p>(1)首先通过“cat /proc/sys/net/ipv4/tcp_syncookies”和“cat<br>/proc/sys/net/tcp_syn_max_backlog”命令查看当前SEEDUbuntuTarget的tcp_syncookies和tcp_max_syn_backlog的状态。</p><p>(2)设置SEEDUbuntuTarget的“tcp_syncookies=0”和“tcp_max_syn_backlog=10”，即关闭tcp<br>syn cookies参数和设置保存在队列中的最大连接数为10。</p><p><img src="/现代计算机网络lab02-实验报告/176dc09f33781ac992d61cfe530adb40.jpg" alt="SEEDUbuntuTarget [Running]  "></p><p><img src="/现代计算机网络lab02-实验报告/8810ae8b8d84b76e84dd7cf8798d9bf6.jpg" alt="SEEDUbuntuTarget [Running] "></p><p>图12：配置内核参数</p><p>（3）在SEEDUbuntu上使用命令“netwox 76 -i 192.168.1.2 –dst-port<br>23”，对SEEDUbuntuTarget进行SYN<br>Flood攻击，同时观察SEEDUbuntuTarget的连接状态和wireshark获取的流量包。</p><p>可以看出SEEDUbuntuTarget收到了大量的建立TCP连接的包，并向多个IP地址发出了响应包，这些IP地址并非SEEDUbuntu，都是虚假的。</p><p><img src="/现代计算机网络lab02-实验报告/b65f538f6ebb2e16d4b780a2c74fcb60.png" alt="SEEDUbuntuTarget [Running] "></p><p>图13：wireshark捕获的包</p><p>观察SEEDUbuntuTarget的连接状态，可以看到当前队列已满共有10个连接，且都为SYN_RECV状态。</p><p><img src="/现代计算机网络lab02-实验报告/8f7b655201461f1c602a74106e2d8771.jpg" alt="SEEDUbuntuTarget [Running] "></p><p>图14：SEEDUbuntuTarget连接状态</p><p>（4）在SEEDUbuntu上使用“telnet<br>192.168.1.2”命令尝试建立telnet连接，发现连接超时，无法建立连接。</p><p><img src="/现代计算机网络lab02-实验报告/03e5fcf818d9d081ac70b2891a2b8c8f.jpg" alt="SEEDUbuntu [Running] / bin/bash /bin/bash • Orade VM Virtua130x root\@uw 4702 u x Option &#39; --dist-prot&#39; is not supported Error 10011 • tool argument not decoded netwox 76 -i 192.168.1.2 Option &#39;--dist-port&#39; is not supported Error 10611 tool argLMnent not decoded netwox 76 -i 192.168.1.2 root\@VM:/home/seed\# netwox 76 -i 192.168 root\@VM:/home/seed\# ip route netwox 76 -i 192.168.1.2 telnet 192.168.1.2 .1.2 23 Trying 192.168.1.2. telnet: Unable to connect to remote host: Conne ction timed out root\@VM 169.254. 192. €.0/16 dev etho scope link metric 100 1.0/24 dev etho proto kernel scope I i ip route add default via 19 root\@VM:/home/seed\# netwox 76 root\@VM:/home/seed\# netwox 76 netwox 76 -i 192.168.1.2 -i 192.168.1.2 - -i 192.168.1.2 - "></p><p>图15：建立Telnet连接失败</p><p>（5）设置SeedUbuntuTarget的tcp_syn_cookies参数为1，开启tcp_cookies，此时再尝试用SEEDUbuntu进行Telnet连接，发现连接成功。</p><p><img src="/现代计算机网络lab02-实验报告/fded31b7fcd2aa5fbaf4d524fd5877ed.jpg" alt="SEEDUbuntuTarget [Running]  "></p><p><img src="/现代计算机网络lab02-实验报告/11a95050349352cb6fd9bfc8e64e9108.jpg" alt="SEEDUbuntu [Running]  "></p><p>图16：Telnet连接成功</p><p>此时再观察SEEDUbuntuTarget的TCP连接状态，可以看到在众多的SYN_RECV状态中有一个ESTABLISHED状态，来自192.168.1.1的52074端口。</p><p><img src="/现代计算机网络lab02-实验报告/5eb157291c0e26adaf951f3724e63823.jpg" alt="root\@VM: /pmc/sys/net/ipv4 root  "></p><p>图17：SEEDUbuntuTarget的TCP连接状态</p><ol><li>关闭SYN Flooding攻击，结束本次实验。</li></ol><h2 id="实验结果和分析"><a href="#实验结果和分析" class="headerlink" title="实验结果和分析"></a>实验结果和分析</h2><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>本次实验使用Virtualbox虚拟平台，配合GNS建立网络拓扑，使用Wiresdhark观察网络中数据包传输情况<br>，成功对靶机实施了SYN Flood攻击。</p><p>本次实验中需要的是需要设置靶机的默认路由。否则在被攻击时，因为靶机路由表中没有这些伪造地址的路由，所以靶机不会回复TCP连接请求，也不会为其预留资源，在这种情况下，即使攻击成功也会被telnet成功连接。</p><p>实验中，主要改变了SYN cookies和tcp_max_syn_backlog的值，在均使用攻击机进行SYN<br>flood攻击模拟的情况下，见表4.1。</p><p>表4.1 SYN Cookies Value</p><table><thead><tr><th>SYN Cookies Value</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>即关闭了SYN cookies防范机制，此时表现为靶机无法防范SYN flood攻击，在被攻击时无法被其他机器通过telnet登陆。且TCP连接队列大小固定为backlog的值，虽然队列内在不断刷新，本可以给新来的telnet连接以机会，但是攻击报文快速涌入，导致telnet连接的三次握手无法完成，最终使靶机表现为无法连接。</td></tr><tr><td>1</td><td>即开启了SYN cookies防范机制，此时表现为靶机可以防范SYN flood攻击，在被攻击时可以被其他机器通过telnet登陆。但TCP连接队列大小不固定为backlog的值，推测此时连接队列的大小受到多个参数的制约。</td></tr></tbody></table><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><h4 id="SYN-flood与TCP三次握手"><a href="#SYN-flood与TCP三次握手" class="headerlink" title="SYN flood与TCP三次握手"></a>SYN flood与TCP三次握手</h4><p>SYN<br>flood攻击的原理是利用了TCP协议中的三次握手过程。对于三次握手过程，TCP协议中规定，当一台主机A想向另一台主机B发起TCP连接时，A需要先发送TCP<br>SYN 包给B，B收到后发送一个TCP SYN+ACK包回复至A，A此时再发送TCP<br>ACK包回给B，此时三次握手才结束，连接建立成功，对于B，连接的过程有“SYN_RECV”-“TIME_WAIT”-“ESTABLISHED”。</p><p>其中B在“SYN_RECV”状态，即半开连接状态下，在等待TCP<br>SYN+ACK包发送回来前，系统要先分配好一个数据区专门服务于这个即将形成的TCP连接。</p><p>SYN<br>flood攻击则是利用在短时间内伪造大量的源地址，向被攻击主机发送大量的SYN包，以让靶机为每一个SYN包分配一个数据区，以建立预期的TCP连接，这样就会导致大量资源消耗，系统也不能对后面正常的TCP连接进行响应。</p><h4 id="SYN-cookie抵御SYN-Flood攻击的原理"><a href="#SYN-cookie抵御SYN-Flood攻击的原理" class="headerlink" title="SYN cookie抵御SYN Flood攻击的原理"></a>SYN cookie抵御SYN Flood攻击的原理</h4><p>SYN cookies是对TCP服务器端的三次握手做一些修改，专门用来防范SYN<br>Flood攻击的一种手段。它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN +<br>ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN<br>ACK包的初始序列号。当客户端返回一个ACK包时，根据包头信息计算cookie，与返回的确认序列号(初始序列号<br>+<br>1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接。这样就不需要等待客户的响应，防止其占用资源。</p><p>实现的关键在于cookie的计算，cookie的计算应该包含本次连接的状态信息，使攻击者不能伪造。cookie的计算过程为，服务器收到一个SYN包，计算一个消息摘要mac<br>= MAC(A,<br>k)；其中MAC是密码学中的一个消息认证码函数，也就是满足某种安全性质的带密钥的hash函数，它能够提供cookie计算中需要的安全性。在Linux中，MAC函数为SHA1。A的计算方式如下：</p><p>A = SOURCE_IP || SOURCE_PORT || DST_IP || DST_PORT || t || MSSIND</p><p>k为服务器独有的密钥，实际上是一组随机数。t为系统启动时间，每60秒加1，MSSIND为MSS对应的索引。</p><p>通过计算并验证cookie，SEEDUbuntu避免了守候半开放连接，从而能够有足够的资源响应SEEDUbuntu的SYN连接请求,因此当开启syn_cookies时，能够正常建立连接。</p><p>被攻击端不开启SYN Cookie，当遭受SYN<br>Flood攻击时，正常的TCP连接无法进行连接到被攻击。</p><p>SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN<br>Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP<br>SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP<br>ACK包时，TCP服务器在根据那个cookie值检查这个TCP<br>ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。</p><p>开启和不开启SYN Cookie的连接步骤如下图所示。</p><p><img src="/现代计算机网络lab02-实验报告/c1fd0f29009f8f2f81138e646a0ac3f5.png" alt></p><p>可以很容易的知道开启SYN Cookie 时可以很好的防范SYN Flood 攻击。</p><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><h5 id="SYN-cookie"><a href="#SYN-cookie" class="headerlink" title="SYN cookie"></a>SYN cookie</h5><p>SYN Cookie的原理是靶机在收到TCP<br>SYN包后，保持在半开连接状态下时，不再为每一个SYN包分配一个专门的数据区，而是根据加密算法计算出一个cookie值，并与TCP<br>SYN+ACK包一同发送。在后面收到返回的TCP<br>ACK包时再进行校验，根据返回的cookie值来检查这个TCP<br>ACK包的合法性。如果合法，再分配专门的数据区以建立未来的TCP连接，此时即有效地防范了SYN<br>flood攻击。</p><h5 id="tcp-max-syn-backlog"><a href="#tcp-max-syn-backlog" class="headerlink" title="tcp_max_syn_backlog"></a>tcp_max_syn_backlog</h5><p>tcp_max_syn_backlog的值应可以简单理解为TCP连接队列的大小，实验中，在SYN<br>cookie设置关闭时，主机的TCP连接队列的最大值即严格按照backlog的值；而在SYN<br>cookie设置打开时，变化backlog的值对TCP连接队列的最大值并无明显影响，推测是由于此时连接队列的最大值受到多个参数的制约。而不论SYN<br>cookie是否打开，在接受攻击时主机的TCP连接队列都在不断刷新，即应会在连接数增加到最大值时关闭旧连接。由此推测在SYN<br>cookie关闭时，调小backlog的值可以减少系统在等待TCP连接完成时的资源的消耗，但新连接很有可能在完成三次握手之前就被关闭；相反，如果增大backlog的值，有机会会使新连接在被攻击报文淹没之前完成三次握手，但相对会增大系统的资源消耗。</p><p>因而，相对来说不开启SYN cookie机制，调节backlog的值会可能会对SYN<br>flood攻击有一些效果，但相对于开启SYN cookie机制仍不够有效。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;环境（详细说明实验运行的操作系统，网络平台，机器的配置）&quot;&gt;&lt;a href=&quot;#环境（详细说明实验运行的操作系统，网络平台，机器的配置）&quot; class=&quot;headerlink&quot; title=&quot;环境（详细说明实验运行的操作系统，网络平台，机器的配置）&quot;&gt;&lt;/a&gt;环境（详细说明实验运行的操作系统，网络平台，机器的配置）&lt;/h2&gt;&lt;p&gt;操作系统：Windows 10 64bit Pro 1909&lt;/p&gt;&lt;p&gt;处理器：Intel® Xeon® CPU E3-1505M v6 \@ 3.00GHz&lt;/p&gt;&lt;p&gt;内存：DDR4 2666MHZ 24GB ECC&lt;/p&gt;&lt;p&gt;网络平台：GNS3 2.2.3&lt;/p&gt;&lt;p&gt;虚拟机软件：Oracle VM VirtualBox 6.0.14&lt;/p&gt;&lt;p&gt;虚拟机：Ubuntu 16.04 32bit&lt;/p&gt;&lt;h2 id=&quot;实验目的&quot;&gt;&lt;a href=&quot;#实验目的&quot; class=&quot;headerlink&quot; title=&quot;实验目的&quot;&gt;&lt;/a&gt;实验目的&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;学会利用GNS3网络平台搭建网络拓扑结构并配置主机的IP和路由。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;掌握SYN flood攻击的基本原理，利用虚拟机实现SYN flood攻击。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;掌握SYN cookie的原理，并通过实验证明SYN cookie机制的有效性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;了解Linux内核TCP SYN Cookie机制，掌握查看与修改方法。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://www.flyinghuster.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络实验" scheme="https://www.flyinghuster.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="网络攻防" scheme="https://www.flyinghuster.com/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[16]数值的整数次方</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[16]%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[16]%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</id>
    <published>2019-12-05T06:44:48.580Z</published>
    <updated>2019-12-07T07:28:15.311Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16:数值的整数次方"></a>面试题16:数值的整数次方</h1><p>题目：实现函数double Power(doubele base, iont exponent), 求base的exponent次方。 不得使用库函数，同时不需要考虑大数问题。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h2><p>下面这种解法只考虑了指数为正数的情况，并没有考虑指数小于1（0以及负正数）的情况：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=exponent; ++i)</span><br><span class="line">        result*=base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p>当指数为负时，可以先对指数求绝对值，算出次方的结果之后再取倒数。但是要避免底数为0时，对其进行负幂运算。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>)&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line"><span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">    absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result=PowerWithUnsignedExponent(base, basExponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1.0</span>/result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=exponent; ++i)</span><br><span class="line">        result *=base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另在上述代码中，我们用全局变量标识是否出错。如果出错，则返回值是0。为了区分出错的时候返回0，还是底数为0的时候正常运行返回的零，我们使用全局变量g_InvalidInput进行标识。</p><h2 id="完美解法"><a href="#完美解法" class="headerlink" title="完美解法"></a>完美解法</h2><p>加速运算，将指数运算拆分成若干指数运算的乘积：<br>$$a^n=\begin{cases}<br>a^{n/2}\cdot a^{n/2} &amp; n为偶数 \<br>a^{(n-1)/2}\cdot a^{(n-1)/2} &amp; n为奇数\<br>\end{cases}$$<br>然后使用递归法求运算结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span>  base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> result=PowerWithUnsignedExponent(base, exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    result *=result;</span><br><span class="line">    <span class="keyword">if</span>(exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">        result*=base;</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们还是用了两个小技巧：用右移运算符代替除以2，用位与运算符(%)来判断一个数是偶数还是奇数。因为位运算比size运算的效率要高很多，这样可以起到优化代码的作用。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题16-数值的整数次方&quot;&gt;&lt;a href=&quot;#面试题16-数值的整数次方&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Server网络配置</title>
    <link href="https://www.flyinghuster.com/Ubuntu%20Server%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.flyinghuster.com/Ubuntu%20Server%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2019-12-04T19:49:37.075Z</published>
    <updated>2019-12-05T03:59:21.079Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>需求：在进行内网穿透的实验过程中，需要将Ubuntu server的IPv4分配方式改为静态。</p><p>Ubuntu自17.10开始，就放弃使用/etc/network/interfaces进行Ip配置。因此，即使在新版本里对interfaces进行了配置，也不会生效。</p><p>新的方法是使用netplan方式进行配置 ，配置写在/etc/netplan/01-netcfg.yaml或者类似名称的yaml文件里。</p><p>Ubuntu Server 18.04的yaml配置文件是：/etc/netplan/50-cloud-init.yaml，修改配置以后不用重启，直接执行netplan apply 命令即可以让配置生效。</p><p>注意：以前的重启网络服务命令/etc/init.d/networking restart或者services network restrart也都会提示为无效命令。</p><h1 id="yaml配置模板"><a href="#yaml配置模板" class="headerlink" title="yaml配置模板"></a>yaml配置模板</h1><p>下面是我的配置模板：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is generated from information provided by</span></span><br><span class="line"><span class="comment"># the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="comment"># To disable cloud-init's network configuration capabilities, write a file</span></span><br><span class="line"><span class="comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="comment"># network: &#123;config: disabled&#125;</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">        <span class="attr">enp9s0:</span></span><br><span class="line">            <span class="attr">addresses:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.133</span><span class="number">.120</span><span class="string">/24</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.133</span><span class="number">.1</span></span><br><span class="line">            <span class="attr">nameservers:</span></span><br><span class="line">                <span class="attr">addresses:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">                <span class="attr">search:</span> <span class="string">[]</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://www.flyinghuster.com/categories/Ubuntu/"/>
    
      <category term="Server" scheme="https://www.flyinghuster.com/categories/Ubuntu/Server/"/>
    
    
      <category term="计算机网络" scheme="https://www.flyinghuster.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Ubuntu" scheme="https://www.flyinghuster.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>现代计算机网络lab02-SYN flood攻击及SYN cookie原理分析</title>
    <link href="https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab02-SYN%20flood%E6%94%BB%E5%87%BB%E5%8F%8ASYN%20cookie%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://www.flyinghuster.com/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab02-SYN%20flood%E6%94%BB%E5%87%BB%E5%8F%8ASYN%20cookie%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2019-12-01T03:19:37.570Z</published>
    <updated>2019-12-01T11:35:54.071Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul><li><p>SEED：计算机安全教育的教学实验平台 • <a href="http://www.cis.syr.edu/~wedu/seed/" target="_blank" rel="noopener">http://www.cis.syr.edu/~wedu/seed/</a> • 纽约雪城大学 杜文亮 (Du, Wenliang)教授设计和实现，从2002年 开始得到NSF 1.2M$的资助</p></li><li><p>SEED内容包含以下几类</p></li><li><p>网络安全主要包括十大实验</p></li><li>分为攻击类、破解类、实现类</li><li>难度越大、消耗的时间越长</li></ul><h1 id="二、TCP-IP-攻击实验"><a href="#二、TCP-IP-攻击实验" class="headerlink" title="二、TCP/IP 攻击实验"></a>二、TCP/IP 攻击实验</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>• Netwox Tools作为报文生成工具<br>• Wireshark 报文截获工具<br>• 启动 ftp and telnet Servers</p><p>• Task 1 : SYN Flooding Attack<br>• Task 2 : TCP RST Attacks on telnet and ssh Connections<br>• Task 3 : TCP RST Attacks on Video Streaming Applications<br>• Task 4 : TCP Session Hijacking<br>• Task 5 : Creating Reverse Shell using TCP Session Hijacking<br>• 注意：攻击者可以观察到被攻击者的流<br>• netwox Tools一共提供了200多个工具<br>• 运行netwox，进入界面后<br>• 选项3搜索工具<br>• 选项4显示帮助</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>• VirtualBox新建虚拟机</p><p>• 导入SEED 虚拟机镜像文件，运行虚拟机</p><p>• 普通用户登陆，有特权操 作再su<br>• 超级用户 User ID: root, Password: seedubuntu.<br>• 普通用户 User ID: seed, Password: dees</p><p>• 利用GNS3配置如图网络<br>• SEED ubuntu 攻击 SEED Ubuntu target<br>• 配置好两台主机的地址和路由</p><h3 id="配置IP地址命令："><a href="#配置IP地址命令：" class="headerlink" title="配置IP地址命令："></a>配置IP地址命令：</h3><p>• ip address显示地址<br>• sudo ip address add 192.168.1.1/24 dev eth0 添加IP<br>• sudo ip address del 192.168.1.1/24 dev eth0 删除IP</p><h3 id="增加路由"><a href="#增加路由" class="headerlink" title="增加路由"></a>增加路由</h3><p>• ip route显示路由<br>• sudo ip route add 192.168.1.0/24 dev eth0<br>• sudo ip route del 192.168.1.0/24 dev eth0</p><h3 id="增加路由-1"><a href="#增加路由-1" class="headerlink" title="增加路由"></a>增加路由</h3><p>• ip route add {NETWORK/MASK} via {GATEWAYIP}</p><h3 id="增加默认路由"><a href="#增加默认路由" class="headerlink" title="增加默认路由"></a>增加默认路由</h3><p>• ip route add default via 192.168.1.1<br>• 永久修改网络配置，图形界面配置</p><p>• SEED Ubuntu target上启动telnet服务： service service openbsd-inetd start<br>• 攻击命令： netwox 76 -i 192.168.1.1 –dst-port 23<br>• 可以在SEED ubuntu 或者 SEED Ubuntu target 上用 tcpdump或者wireshark观察攻击报文： 如左图<br>• 可以在SEED ubuntu 或者 SEED Ubuntu target 上用 tcpdump或者wireshark观察建立连接： netstat –n –tcp</p><h1 id="进一步观察linux内核tcp-syn-cookie机制"><a href="#进一步观察linux内核tcp-syn-cookie机制" class="headerlink" title="进一步观察linux内核tcp syn cookie机制"></a>进一步观察linux内核tcp syn cookie机制</h1><p>配置内核参数的两种方式：<br>• cat /proc/sys/net/ipv4/tcp_syncookies<br>• echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies<br>• sysctl –a | grep net.ipv4.tcp_max_syn_backlog<br>• sysctl -w net.ipv4.tcp_max_syn_backlog = 5<br>比较打开和关闭SEED Ubuntu target内核tcp syn cookie参数，syn flood攻击的效果：</p><ol><li>设置SEED Ubuntu target上， net.ipv4.tcp_max_syn_backlog=5 2.</li><li>设置SEED Ubuntu target上， net.ipv4. tcp_syncookies=0</li><li>从SEED Ubuntu 上用netwox的syn flood攻击SEED Ubuntu target</li><li>同时从SEED Ubuntu 上用telnet 主机 SEED Ubuntu target，看能否建立连 接？</li></ol><p>打开SEED Ubuntu target内核tcp syn cookie参数，同时从SEED Ubuntu 上用 telnet 主机 SEED Ubuntu target，看能否建立连接？</p><h1 id="实验报告要求"><a href="#实验报告要求" class="headerlink" title="实验报告要求"></a>实验报告要求</h1><ol><li>写出完整的实验配置过程，包括拓扑结构和配置命令</li><li>用截图的方式描述实验结果</li><li>描述tcp syn cookie的原理</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="网络空间安全" scheme="https://www.flyinghuster.com/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8/"/>
    
      <category term="网络实验" scheme="https://www.flyinghuster.com/categories/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
    
      <category term="网络实验" scheme="https://www.flyinghuster.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C/"/>
    
      <category term="网路攻击" scheme="https://www.flyinghuster.com/tags/%E7%BD%91%E8%B7%AF%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置多https站点</title>
    <link href="https://www.flyinghuster.com/Nginx%E9%85%8D%E7%BD%AE%E5%A4%9Ahttps%E7%AB%99%E7%82%B9/"/>
    <id>https://www.flyinghuster.com/Nginx%E9%85%8D%E7%BD%AE%E5%A4%9Ahttps%E7%AB%99%E7%82%B9/</id>
    <published>2019-11-28T15:20:37.000Z</published>
    <updated>2019-11-28T15:41:15.485Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>最近需要在一台云服务器上使用Nginx同时部署多个http与https服务。使得多个http以及https站点分别监听80以及443端口。</p><h1 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h1><p>在此之前，我已经成功地在服务器上部署了单对http以及https服务，并强制使http跳转到https。在部署多https时，参考了很多博客，有的说使用正向代理，也有说使用反向代理的，后来仔细学习了Nginx，才发现原来事情根本没有那么复杂，只需要像配置单对http以及https服务那样，将配置文件重新复制一份就行了。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>现有domain, domian2, …, domianN 一共N个站点需要同时监听80以及443端口，且使用80端口访问其中任一站点时，nginx将会将这些请求发送到此站点对应的443端口。<br>下面是Nginx对于<a href="http://www.domain.com站点的配置文件，将其存储在/etc/nginx/conf.d目录下，习惯将其命名为domain.conf。" target="_blank" rel="noopener">www.domain.com站点的配置文件，将其存储在/etc/nginx/conf.d目录下，习惯将其命名为domain.conf。</a><br></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/domain.conf</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line"><span class="comment">#填写绑定证书的域名</span></span><br><span class="line"><span class="attribute">server_name</span> www.domain.com; </span><br><span class="line"><span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span></span><br><span class="line"><span class="attribute">root</span> /var/www/www.domain.com; </span><br><span class="line"><span class="attribute">index</span> index.html index.htm;   </span><br><span class="line"><span class="comment">#证书文件名称</span></span><br><span class="line"><span class="attribute">ssl_certificate</span>  1_www.domain.com_bundle.crt; </span><br><span class="line"><span class="comment">#私钥文件名称</span></span><br><span class="line"><span class="attribute">ssl_certificate_key</span> 2_www.domain.com.key; </span><br><span class="line"><span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line"><span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line"><span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="comment">#填写绑定证书的域名</span></span><br><span class="line"><span class="attribute">server_name</span> www.domain.com; </span><br><span class="line"><span class="comment">#把http的域名请求转成https</span></span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于其余的$N-1$个站点，只需要将此配置文件复制$N-1$份，并将其中domian名称以及对应的ssl文件存储位置进行替换即可。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://www.flyinghuster.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Nginx" scheme="https://www.flyinghuster.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[15]二进制中1的个数</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[15]%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[15]%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</id>
    <published>2019-11-25T06:35:05.520Z</published>
    <updated>2019-11-26T14:08:49.718Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题15"><a href="#面试题15" class="headerlink" title="面试题15"></a>面试题15</h1><p>题目：请事先一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示1的个数。例如，把9表示成二进制是1001，有2位是1.因此，如果输入9，则该函数输出2。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：可能会引起死循环"><a href="#法一：可能会引起死循环" class="headerlink" title="法一：可能会引起死循环"></a>法一：可能会引起死循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二：常规解法"><a href="#法二：常规解法" class="headerlink" title="法二：常规解法"></a>法二：常规解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">            count++;</span><br><span class="line">        flag=flag&lt;&lt;<span class="number">1</span>;&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法三：推荐解法"><a href="#法三：推荐解法" class="headerlink" title="法三：推荐解法"></a>法三：推荐解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n=(n<span class="number">-1</span>)^n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题15&quot;&gt;&lt;a href=&quot;#面试题15&quot; class=&quot;headerlink&quot; title=&quot;面试题15&quot;&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[14]剪绳子</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[14]%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[14]%E5%89%AA%E7%BB%B3%E5%AD%90/</id>
    <published>2019-11-25T06:23:02.547Z</published>
    <updated>2019-11-26T10:55:44.460Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题14"><a href="#面试题14" class="headerlink" title="面试题14"></a>面试题14</h1><p>题目：给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度纪委k[0]，k[1]，…，k[m]。请问k[0]$\times$k[1]$\times$···$\times$k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2, 3, 3的三段，此时得到的最大乘积是18。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：动态规划"><a href="#法一：动态规划" class="headerlink" title="法一：动态规划"></a>法一：动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">int</span> product=products[j]*products[i-j];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">max</span>&lt;product)</span><br><span class="line">                <span class="built_in">max</span> = product;</span><br><span class="line">            products[i]=<span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">max</span>=products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二：贪婪算法"><a href="#法二：贪婪算法" class="headerlink" title="法二：贪婪算法"></a>法二：贪婪算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尽可能多地剪去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length/<span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当绳子最后剩下的长度为4时，不能再剪去长度为3的绳子短</span></span><br><span class="line">    <span class="comment">//此时更好的方法是把绳子剪成长度为2的两端，因为2*2&gt;3*1</span></span><br><span class="line">    <span class="keyword">if</span>(length-timesOf3*<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">        timesOf3-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf2=(length-timesOf3*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3))*(<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题14&quot;&gt;&lt;a href=&quot;#面试题14&quot; class=&quot;headerlink&quot; title=&quot;面试题14&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[13]机器人的运动范围</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[13]%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[13]%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</id>
    <published>2019-11-25T06:17:14.526Z</published>
    <updated>2019-11-26T10:59:23.801Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题13"><a href="#面试题13" class="headerlink" title="面试题13"></a>面试题13</h1><p>题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 17)，因为3+5+3+8=18。但它不能进入方格(35, 38)，因为3+5+3+9=19，请问该机器人能够到达多少格子？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threshold&lt;<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> *visited=<span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;rows*cols; ++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> movingCountCore(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>*visited)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited))</span><br><span class="line">    &#123;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">true</span>;</span><br><span class="line">            count=<span class="number">1</span>+movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)+movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited)+movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)+movingCountCore(threshold, rows,cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols&amp;&amp;getDigitSum(row)+getDigitSum(col)&lt;=threshold&amp;&amp;!visited[row*cols+col])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=number%<span class="number">10</span>;</span><br><span class="line">        number/=<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题13&quot;&gt;&lt;a href=&quot;#面试题13&quot; class=&quot;headerlink&quot; title=&quot;面试题13&quot;&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[12]矩阵中的路径</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[12]%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[12]%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2019-11-25T06:06:36.499Z</published>
    <updated>2019-11-26T10:58:03.806Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题12"><a href="#面试题12" class="headerlink" title="面试题12"></a>面试题12</h1><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一个路径经过了矩阵的某一个，那么该路径不能再次进入该格子。例如，在下面的3$\times4$的矩阵中包含一条字符串“bfee”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串”abfb”的路径，因为字符串的第一个字符b占据了矩阵中第一行第二个格子之后，路径不能再次进入这个格子。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span>||rows&lt;<span class="number">1</span> ||cols&lt;<span class="number">1</span>||str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows*cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row&lt;rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;cols;++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str, pathlength, visited))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasPath=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;<span class="number">0</span>&amp;&amp;col&lt;cols &amp;&amp;matrix[row*cols+col]==str[pathLength]&amp;&amp;!visited[row*cols+col])</span><br><span class="line">    &#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[rows*cols+col]=<span class="literal">true</span>;</span><br><span class="line">        hasPath=hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>, str, pathLength, visited)||hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>, str, pathLength, visited)||hasPath(matrix, rows, cols, row+<span class="number">1</span>, col, str, pathLegnth, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题12&quot;&gt;&lt;a href=&quot;#面试题12&quot; class=&quot;headerlink&quot; title=&quot;面试题12&quot;&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[11]旋转数组的最小数字</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[11]%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[11]%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</id>
    <published>2019-11-25T05:25:05.397Z</published>
    <updated>2019-11-25T14:05:53.088Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题11"><a href="#面试题11" class="headerlink" title="面试题11"></a>面试题11</h1><p>题目：把一个数组最开始的若干数组搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最值为1.</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">intMin（<span class="keyword">int</span>*numbers， <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid parameters"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = length <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">        <span class="keyword">while</span>(numbers[index1]&gt;=numbers[index2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2-index1==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                indexMid=index2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexMid=(index1+index2)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1])</span><br><span class="line">                index1 indexMid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2])</span><br><span class="line">                index2 = indexMid</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* number, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"invalid parameters"</span>);</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = length <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">    <span class="keyword">while</span>(numbers[index1]&gt;=numbers[index2])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2-index==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            indexMid=index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexMid=(index1+index2)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果下表为index1、index2和indexMid指向的三个数字相等，</span></span><br><span class="line">        <span class="comment">//则只能顺序查找</span></span><br><span class="line">        <span class="keyword">if</span>（numbers[index1]==numbers[index2]&amp;&amp;numbers[indexMid]==numbers[index1])</span><br><span class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1])</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2])</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[index1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index1+<span class="number">1</span>; i&lt;=index2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>（result&gt;numbers[i])</span><br><span class="line">        result=numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题11&quot;&gt;&lt;a href=&quot;#面试题11&quot; class=&quot;headerlink&quot; title=&quot;面试题11&quot;&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[9]用两个栈实现队列</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[9]%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[9]%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2019-11-16T20:24:04.687Z</published>
    <updated>2019-11-20T13:13:13.604Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题9：用两个栈实现队列"><a href="#面试题9：用两个栈实现队列" class="headerlink" title="面试题9：用两个栈实现队列"></a>面试题9：用两个栈实现队列</h1><p>题目：用两个栈实现一个队列。队列的生命如下，请事先它的菱格函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">void</span>);</span><br><span class="line">    ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">    T.deleteHead();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>本题属于基本题，利用栈的先进后出的特性，使用两个栈便可实现队列的功能。代码如下：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">void</span> CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>.<span class="built_in">size</span>()&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data=stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack2.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">    T head=stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题9：用两个栈实现队列&quot;&gt;&lt;a href=&quot;#面试题9：用两个栈实现队列&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[10]斐波那契数列</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[10]%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[10]%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2019-11-16T20:23:25.227Z</published>
    <updated>2020-01-07T02:15:04.262Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题10"><a href="#面试题10" class="headerlink" title="面试题10"></a>面试题10</h1><h2 id="题目一：求斐波那契数列的第n项"><a href="#题目一：求斐波那契数列的第n项" class="headerlink" title="题目一：求斐波那契数列的第n项"></a>题目一：求斐波那契数列的第n项</h2><p>写一个函数，输入$n$，求斐波那契(Fibonacci)数列的第$n$项。斐波那契数列的定义如下：<br>$$f(n)=\begin{cases}<br>0 &amp; n=0\<br>1 &amp; n=1\<br>f(n-1)+f(n-2) &amp; n&gt;1<br>\end{cases} $$</p><h2 id="题目二：青蛙跳台阶问题"><a href="#题目二：青蛙跳台阶问题" class="headerlink" title="题目二：青蛙跳台阶问题"></a>题目二：青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个$n$级台阶总共有多少种跳法。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="效率很低的解法"><a href="#效率很低的解法" class="headerlink" title="效率很低的解法"></a>效率很低的解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用解法"><a href="#实用解法" class="headerlink" title="实用解法"></a>实用解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">2</span>]=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusOne = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusTwo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fibN = fibNMinusOne +fibNMinusTwo;</span><br><span class="line">        fibNMinusTwo=fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度为-O-log-n-，但不够实用"><a href="#时间复杂度为-O-log-n-，但不够实用" class="headerlink" title="时间复杂度为$O(\log{n})$，但不够实用"></a>时间复杂度为$O(\log{n})$，但不够实用</h3><p>使用数学公式，可以将问题转化为如何求得矩阵$\left[<br>\begin{matrix}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{matrix}<br>\right]<br>$<br>的乘方。</p><p>$$<br>\left[<br>\begin{matrix}<br>f(n) &amp; f(n-1) \<br>f(n-1) &amp; f(n-2) \<br>\end{matrix}<br>\right]<br>=<br>\left[<br>\begin{matrix}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{matrix}<br>\right]<br>$$<br>考虑到乘方具有如下性质：<br>$$a^n=\begin{cases}<br>a^{n/2} &amp; n为偶数\<br>a^{(n-1)/2}\cdot a^{(n-1)/2}\cdot a&amp; n为奇数\<br>\end{cases} $$<br>因此，想求得$n$次方，只需要闲求得$n/2$次方，再把$n/2$次方的结果进行平方即可。可使用递归法求解。递归法的时间复杂度是$O(\log{n})$</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>题目二同样可以归结为斐波那契数列，使用同样的解法便可求得。在此不再赘述。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题10&quot;&gt;&lt;a href=&quot;#面试题10&quot; class=&quot;headerlink&quot; title=&quot;面试题10&quot;&gt;
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[8]二叉树的下一个节点</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[8]%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[8]%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2019-11-16T20:22:27.719Z</published>
    <updated>2019-11-20T14:30:50.972Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h1><p>题目：给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果一个节点有右节点，那么它的下一个节点就是它的右子树中的最左节点。<br>如果一个节点没有右子树，且这个节点是其父节点的左子节点，那么它的下一个节点是其父节点。<br>如果一个节点没有右子树，且这个节点是其父节点的右子节点，那么我们需要经这个节点沿着指向其府机电的指针一直向上遍历，知道找到一个节点，这个节点是其父节点的左子节点，那么这个节点的父节点就是我们要找的节点。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight =pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRight=pRight-&gt;m_pLeft;</span><br><span class="line">        pNext=pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent!=<span class="literal">nullptr</span> &amp;&amp;pCurrent ==pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext=pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题8：二叉树的下一个节点&quot;&gt;&lt;a href=&quot;#面试题8：二叉树的下一个节点&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[7]重建二叉树</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[7]%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[7]%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2019-11-16T20:21:53.497Z</published>
    <updated>2019-11-20T14:13:51.042Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h1><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不喊重复的数字。例如，输入前序遍历序列{1, 2, 4, 7, 3, 5, 7, 8}和中序遍历{4, 7, 2, 1, 5, 3, 8 ,6}, 则重建如图2.6所示的二叉树并输出它的头结点。二叉树节点的定义如下：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    BinaryTreeNode* m_pLeft;</span><br><span class="line">    BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>前序遍历的特点：根左右<br>中序遍历的特点：左根右<br>我们可以根据前序遍历确定二叉树根节点，再对照根节点在中序遍历中的位置逐步确定其余节点与根节点的父子关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="literal">nullptr</span>||inorder == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder, preorder+length<span class="number">-1</span>, inorder, inorder+length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">BinaryTreeNode* ConstructCore</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder,</span><br><span class="line">    <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前序遍历序列的第一个数字是根节点的值</span></span><br><span class="line">    <span class="keyword">int</span> rootValue=startPreorder[<span class="number">0</span>];</span><br><span class="line">    BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">    root-&gt;m_nValue = rootValue;</span><br><span class="line">    root-&gt;m_pLeft = root-&gt;m_pRight=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startPreorder == endPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在中序遍历序列中找到根节点的值</span></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span>(rootInorder &lt;=endInorder &amp;&amp; *rootInorder !=rootValue)</span><br><span class="line">        ++rootInorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder !=rootValue)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength=rootInorder-startInorder;</span><br><span class="line">        <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">        <span class="keyword">if</span>(leftLength&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建左子树</span></span><br><span class="line">            root-&gt;m_pLeft=ConstructCore(startPreorder+<span class="number">1</span>, leftPreorderEnd, startInorder, rootInorder<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftLength&lt;endPreorder-startPreorder)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建右子树</span></span><br><span class="line">            root-&gt;m_pRight=ConstructCore(leftPreorderEnd+<span class="number">1</span>, endPreorder, rootInorder+<span class="number">1</span>, endInorder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题7：重建二叉树&quot;&gt;&lt;a href=&quot;#面试题7：重建二叉树&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[6]从头到尾打印链表</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[6]%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[6]%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</id>
    <published>2019-11-16T19:28:01.041Z</published>
    <updated>2019-11-17T03:55:06.330Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题6"><a href="#面试题6" class="headerlink" title="面试题6"></a>面试题6</h1><p>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：<br>struct ListNode<br>{<br>int m_nKey;<br>ListNode* m_pNext;<br>};</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：修改链表指针"><a href="#法一：修改链表指针" class="headerlink" title="法一：修改链表指针"></a>法一：修改链表指针</h2><p>设前后两个指针，从前往后，依次改变所有链表指针的方向。但是这样做就修改了原始链表的结构。在面试中，需要若打算修改输入的数据，需要实现征询面试官的意见。</p><h2 id="法二：使用辅助栈"><a href="#法二：使用辅助栈" class="headerlink" title="法二：使用辅助栈"></a>法二：使用辅助栈</h2><p>输出数据具有“后进先出”的特点，即遍历的最后一个节点需要最先输出，因此，我们可以利用同样具有“后进先出”特性的栈数据结构，来辅助完成此操作。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes; <span class="comment">//辅助栈</span></span><br><span class="line">    </span><br><span class="line">    ListNode* pNode = pHead; <span class="comment">//让指针指向原始栈链表的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode); <span class="comment">//将头结点入栈</span></span><br><span class="line">        pNode = pNode-&gt;m_pNext; <span class="comment">//移动指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="法三：使用递归"><a href="#法三：使用递归" class="headerlink" title="法三：使用递归"></a>法三：使用递归</h2><p>递归本质上就是一种栈的结构，因此很自然地，可以使用栈来完成这种操作：每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结构就反过来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题6&quot;&gt;&lt;a href=&quot;#面试题6&quot; class=&quot;headerlink&quot; title=&quot;面试题6&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[5]替换空格</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[5]%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[5]%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</id>
    <published>2019-11-16T05:39:14.594Z</published>
    <updated>2019-11-16T15:08:49.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题5：替换空格"><a href="#面试题5：替换空格" class="headerlink" title="面试题5：替换空格"></a>面试题5：替换空格</h1><p>题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”, 则输出We%20are%20happy.”</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="时间复杂度为-O-n-2-的解法"><a href="#时间复杂度为-O-n-2-的解法" class="headerlink" title="时间复杂度为$O(n^2)$的解法"></a>时间复杂度为$O(n^2)$的解法</h2><p>从头到尾扫描字符串，每次碰到空格字符的时候进行替换。每次替换完毕之后，都把之后的字符往后移动两位。<br>假设字符串的长度是n。对于每个空格字符，需要移动后边$O(n)$个字符，因此对于含有$O(n)$个空格字符的字符串而言，总的时间效率是$O(n^2)$。<br><a id="more"></a></p><h2 id="时间复杂度为-O-n-的解法"><a href="#时间复杂度为-O-n-的解法" class="headerlink" title="时间复杂度为$O(n)$的解法"></a>时间复杂度为$O(n)$的解法</h2><p>上边的做法，时间复杂度太高。我们还可以采用下边这种解法，这样可以将时间复杂度降低到$O(n)$:<br>首先，遍历一次字符串，统计出字符串内空格的数量。由此可以计算出替换之后的字符的总长度。设原长度为$L$，现长度为$L’$，字符串内包含有$n$个空格，则$L$与$L’$应存在下列关系：<br>$$L’=L+2 n$$<br>接着，准备两个指针$P_1$和$P_2$从字符串的后面开始进行复制和替换。其中$P_1$指向原始字符串的末尾，$P_2$指向替换之后的字符串的末尾。<br>接着，我们将$P_1$逐步往前移动，逐个将它们复制到$P_2$指向的位置。如果碰到空格,则先将$P_1$P往前移动1个，在P2之前插入字符串”%20”，由于”%20”的长度为3，同时需要把$P_2$往前移动三格。以此类推。<br>当指针$P_1$和$P_2$指向同一位置时，则表明，所有空格已经被替换完毕。<br>代码如下:<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//length为字符数组string的总容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//originallLength为字符串string的实际长度</span></span><br><span class="line">        <span class="keyword">int</span> originalLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//顺序遍历数组，统计出数组中空格的个数numberOfBlank</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">string</span>[i]!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++originalLength;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">string</span>[i]==<span class="string">' '</span>)</span><br><span class="line">                ++numberOfBlank;</span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//newLength 为把空格替换成'%20'之后的长度</span></span><br><span class="line">        <span class="keyword">int</span> newLength  OriginalLength+numberOfBlank*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newLength&gt;length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> indexOfOriginal = originalLength; <span class="comment">//相当于p1指针</span></span><br><span class="line">        <span class="keyword">int</span> indexOfNew = newLength; <span class="comment">//相当于p2指针</span></span><br><span class="line">        <span class="keyword">while</span>(indexOfOringal &gt;=<span class="number">0</span> &amp;&amp; indexOfNew &gt;indexOfOriginal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOriginal]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="string">'0'</span>;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="string">'2'</span>;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="built_in">string</span>[indexOfOringal]; <span class="comment">//把p1指针指向的数据复制到p2指针指向的的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            --indexOfOriginal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题5：替换空格&quot;&gt;&lt;a href=&quot;#面试题5：替换空格&quot; class=&quot;headerlink&quot; title=&quot;面试题5：替换空格&quot;&gt;&lt;/a&gt;面试题5：替换空格&lt;/h1&gt;&lt;p&gt;题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”, 则输出We%20are%20happy.”&lt;/p&gt;&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;&lt;h2 id=&quot;时间复杂度为-O-n-2-的解法&quot;&gt;&lt;a href=&quot;#时间复杂度为-O-n-2-的解法&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度为$O(n^2)$的解法&quot;&gt;&lt;/a&gt;时间复杂度为$O(n^2)$的解法&lt;/h2&gt;&lt;p&gt;从头到尾扫描字符串，每次碰到空格字符的时候进行替换。每次替换完毕之后，都把之后的字符往后移动两位。&lt;br&gt;假设字符串的长度是n。对于每个空格字符，需要移动后边$O(n)$个字符，因此对于含有$O(n)$个空格字符的字符串而言，总的时间效率是$O(n^2)$。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer面试题[4]二维数组中的查找</title>
    <link href="https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[4]%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.flyinghuster.com/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98[4]%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2019-11-16T05:38:52.986Z</published>
    <updated>2019-11-16T15:08:36.060Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --><h1 id="面试题4"><a href="#面试题4" class="headerlink" title="面试题4"></a>面试题4</h1><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。清完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(matrix!= <span class="literal">nullptr</span> &amp;&amp; rows&gt;<span class="number">0</span> &amp;&amp; columns&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;rows&amp;&amp;column&gt;=<span class="number">0</span>)</span><br><span class="line">        ]&#123;</span><br><span class="line">            ]<span class="keyword">if</span>(matrix[row*columns+column]==number)</span><br><span class="line">            &#123;</span><br><span class="line">                found=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row*columns+column]&gt;number)</span><br><span class="line">                --column;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++row;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Jan 14 2020 22:05:19 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;面试题4&quot;&gt;&lt;a href=&quot;#面试题4&quot; class=&quot;headerlink&quot; title=&quot;面试题4&quot;&gt;&lt;/a&gt;面试题4&lt;/h1&gt;&lt;p&gt;题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。清完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.flyinghuster.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.flyinghuster.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
