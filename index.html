<!-- build time:Tue Jan 14 2020 15:54:08 GMT+0800 (China Standard Time) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.1.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=7.1.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=7.1.2"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=7.1.2"><link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.1.2",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!1,fastclick:!1,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="飞翔的Huster"><meta name="keywords" content="计算机科学与技术,网络空间安全,作曲与作曲技术理论"><meta property="og:type" content="website"><meta property="og:title" content="The Flying Huster"><meta property="og:url" content="https://www.flyinghuster.com/index.html"><meta property="og:site_name" content="The Flying Huster"><meta property="og:description" content="飞翔的Huster"><meta property="og:locale" content="zh"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="The Flying Huster"><meta name="twitter:description" content="飞翔的Huster"><link rel="canonical" href="https://www.flyinghuster.com/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>The Flying Huster – 记录科研生活的点点滴滴</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">The Flying Huster</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">记录科研生活的点点滴滴</h1></div><div class="site-nav-toggle"><button aria-label="Toggle navigation bar"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home menu-item-active"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives<span class="badge">40</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories<span class="badge">23</span></a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags<span class="badge">35</span></a></li><li class="menu-item menu-item-gallery"><a href="/gallery" rel="section"><i class="menu-item-icon fa fa-fw fa-photo"></i><br>Gallery</a></li><li class="menu-item menu-item-contact"><a href="/contact/" rel="section"><i class="menu-item-icon fa fa-fw fa-phone"></i><br>Contact</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a></li><li class="menu-item menu-item-weekend-composer"><a href="https://www.weekendcomposer.com" rel="noopener" target="_blank"><i class="menu-item-icon fa fa-fw fa-music"></i><br>Weekend Composer</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/使用MapReduce实现倒排索引/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/使用MapReduce实现倒排索引/" class="post-title-link" itemprop="url">使用MapReduce实现倒排索引</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-01-10 02:03:42" itemprop="dateCreated datePublished" datetime="2020-01-10T02:03:42+08:00">2020-01-10</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式系统/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式系统/MapReduce/" itemprop="url" rel="index"><span itemprop="name">MapReduce</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><p>任务描述<br>本关任务：编写 MapReduce 实现倒排索引。</p><p>相关知识<br>什么是MapReduce<br>MapReduce 是一种可用于数据处理的编程模型，我们现在设想一个场景，你接到一个任务，任务是：挖掘分析我国气象中心近年来的数据日志，该数据日志大小有 3T ，让你分析计算出每一年的最高气温，如果你现在只有一台计算机，如何处理呢？我想你应该会读取这些数据，并且将读取到的数据与目前的最大气温值进行比较。比较完所有的数据之后就可以得出最高气温了。不过以我们的经验都知道要处理这么多数据肯定是非常耗时的。</p><p>如果我现在给你三台机器，你会如何处理呢？看到下图你应该想到了：最好的处理方式是将这些数据切分成三块，然后分别计算处理这些数据（ Map ），处理完毕之后发送到一台机器上进行合并（ merge ），再计算合并之后的数据，归纳（ reduce ）并输出。</p><p>这就是一个比较完整的 MapReduce 的过程了。</p><p><img src="/使用MapReduce实现倒排索引/1.jpg" alt></p><p>如何使用MapReduce进行运算<br>我们通过一个示例，来体验 Map/Reduce 的使用。</p><p>我们从一个问题入手：目前我们想统计两个文本文件中，每个单词出现的次数。</p><p>首先我们在当前目录下创建两个文件：</p><p>创建file01输入内容：</p><p>Hello World Bye World<br>创建file02输入内容：</p><p>Hello Hadoop Goodbye Hadoop<br>将文件上传到 HDFS 的/usr/input/目录下：</p><p>不要忘了启动 DFS：</p><p>start-dfs.sh</p><p>然后创建文件夹并上传：</p><p><img src="/使用MapReduce实现倒排索引/2.jpg" alt></p><p>在右侧代码区域编写，文件WordCount.java，添加如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> </span></span><br><span class="line"><span class="class">       <span class="title">extends</span> <span class="title">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Text word = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context</span></span></span><br><span class="line">                    ) throws IOException, InterruptedException &#123;</span><br><span class="line">      StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">      <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">        word.<span class="built_in">set</span>(itr.nextToken());</span><br><span class="line">        context.write(word, one);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> </span></span><br><span class="line"><span class="class">       <span class="title">extends</span> <span class="title">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span></span><br><span class="line">    <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, </span></span></span><br><span class="line"><span class="function"><span class="params">                       Context context</span></span></span><br><span class="line">                       ) throws IOException, InterruptedException &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">        sum += val.get();</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="built_in">set</span>(sum);</span><br><span class="line">      context.write(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Job job = <span class="keyword">new</span> Job(conf, <span class="string">"word count"</span>);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    String inputfile = <span class="string">"/usr/input"</span>;</span><br><span class="line">    String outputFile = <span class="string">"/usr/output"</span>;</span><br><span class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(inputfile));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(outputFile));</span><br><span class="line">    System.<span class="built_in">exit</span>(job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击评测，运行代码，可以看到/usr/output目录下已经生成了文件。</p><p><img src="/使用MapReduce实现倒排索引/3.jpg" alt></p><p>我们来查看part–r-00000文件的内容：</p><p><img src="/使用MapReduce实现倒排索引/4.jpg" alt></p><p>可以看到统计的数据已经生成在文件中了。</p><p>如果你还想要运行一次，那么你需要删除输出路径的文件夹和文件。</p><p>代码解释<br>示例中，Map/Reduce 程序总共分为三块即：Map，Reduce，Job，Map 负责处理输入文件的内容。</p><p>TokenizerMapper 的 map 方法，它通过 StringTokenizer 以空格为分隔符将一行切分为若干 tokens ，之后，输出 &lt; , 1&gt; 形式的键值对。</p><p>对于示例中的第一个输入， map 输出是：</p><p>&lt; Hello, 1&gt;</p><p>&lt; World, 1&gt;</p><p>&lt; Bye, 1&gt;</p><p>&lt; World, 1&gt;</p><p>第二个输入，map 输出是：</p><p>&lt; Hello, 1&gt;</p><p>&lt; Hadoop, 1&gt;</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 1&gt;</p><p>WordCount 还指定了一个 combiner 。因此，每次 map 运行之后，会对输出按照 key 进行排序，然后把输出传递给本地的 combiner （按照作业的配置与 Reducer 一样），进行本地聚合。</p><p><img src="/使用MapReduce实现倒排索引/5.jpg" alt></p><p>第一个 map 的输出是：</p><p>&lt; Bye, 1&gt;</p><p>&lt; Hello, 1&gt;</p><p>&lt; World, 2&gt;</p><p>第二个 map 的输出是：</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 2&gt;</p><p>&lt; Hello, 1&gt;</p><p>reduce 收到的数据是这样的：</p><p>&lt; Bye , [1]&gt;</p><p>&lt; GoodBye , [1]&gt;</p><p>&lt; Hadoop , [1,1]&gt;</p><p>&lt; Hello , [1,1]&gt;</p><p>&lt; World , [1,1]&gt;</p><p>Reducer 中的 reduce 方法 仅是将每个 key（本例中就是单词）出现的次数求和。</p><p>因此这个作业的输出就是：</p><p>&lt; Bye, 1&gt;</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 2&gt;</p><p>&lt; Hello, 2&gt;</p><p>&lt; World, 2&gt;</p><p>编程要求<br>根据提示，在右侧编辑器的中的 begin-end 间补全 InvertIndex_origin 类中的 map 和 reduce 函数。具体实现如下。</p><p>读取 hdfs 中/input目录下的如下三个文件，文件内容如下：</p><p>file1.txt内容：</p><p>mapreduce is simple</p><p>file2.txt内容：</p><p>mapreduce is powerful and simple</p><p>file3.txt内容：</p><p>mapreduce and mapreduce<br>使用 mapreduce 处理后把结果输出到 hdfs 的/out目录下，预期输出内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">and file3.txt:1;file2.txt:1;</span><br><span class="line">is file2.txt:1;file1.txt:1;</span><br><span class="line">mapreduce file1.txt:1;file2.txt:1;file3.txt:2;</span><br><span class="line">powerful file2.txt:1;</span><br><span class="line">simple file2.txt:1;file1.txt:1;</span><br><span class="line">后台会自动把代码打包并执行以下命令提交：</span><br></pre></td></tr></table></figure><p>hadoop jar /root/invertedindex-1.0-SNAPSHOT.jar InvertIndex_origin /invertindex /out</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/现代计算机网络复习笔记/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/现代计算机网络复习笔记/" class="post-title-link" itemprop="url">现代计算机网络复习笔记</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-01-03 16:22:48" itemprop="dateCreated datePublished" datetime="2020-01-03T16:22:48+08:00">2020-01-03</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="Ch1-1-体系结构"><a href="#Ch1-1-体系结构" class="headerlink" title="Ch1-1 体系结构"></a>Ch1-1 体系结构</h2><ol><li><p>网络的基本概念</p><p> 逻辑链路：<br> 在两点间通过通信协议的作用建立起来的数据联结通路<br> 通路(Path):<br> 从源点到宿点所经过的一串节点和链路的有序集。或端到端的通路<br> 协议（Protocol）<br> 多个进程为完成一个任务而共同遵守的动作序列规范<br> 三要素：语法、语义、规则(同步时序)<br> 网络云：<br> 区分通信子网交换交换结点（云内）和资源主机结点（云外）的分界<br>线，可表示任何网络（单、多、交换等）</p><p> 第一层：Backbone中转网：国家或世界级网络主干<br>美NFSnet/欧Ebone/中Chinanet/CERNET<br> 第二层：Transit地区性网：覆盖省、洲、国家,<br>提供到因特网的连接<br>因特网服务提供者ISP<br> 第三层：Stub组织性网：本地服务提供商；<br>是一个自治网络系统，有AS号<br>校园网、企业网、公司网、政府网<br>由外围网关接入地区性网络</p></li><li><p>性能参数<br> 性能测量的两个参数：带宽和延迟<br> 带宽(Bandwidth):Hz,KHz,MHz,GHz，bps<br> 信号带宽：构成一信号的各种不同频率成分所占据的频率范围。如人类声音<br>带宽为：3300Hz－300＝声音带宽3000Hz<br> 媒体带宽：通信媒体允许通过的信号频带范围<br> 比特率：某时段内网络上可能传输的比特数，或传输每比特数据所需的时间<br>宽度。习惯把“带宽”作为数字信道的数据率或比特率<br> 比特率越高，高频分量越多，频率范围越大，信号带宽越高。<br> 吞吐率(Throughput)：bps<br> 数字信号的发送速率，因此发送带宽也成为吞吐率<br> 由于各种影响 10M 带宽实际完成 2Mbps<br> 吞吐率：链路上实际每秒传输的比特数</p></li></ol><pre><code>延迟：
 Delay : 把一个报文从网络一端传输到另一端所需的时间one way，光传播
速度：
 3.0x108m/s ;光在真空内传播的速率
 2.8x108m/s ;电在Cable内传播的速率
 2.0x108m/s ;光在Fiber内传播的速率
 Round Trip Time (RTT):发收来回时间（2次时延）
 定义：延迟 = 处理＋排队+传输+传播，主要考虑后两个
 处理时延：检查包首部、决定导向何处；比特差错检测，高速Router一般在微秒
或更低数量级，接收完整的一个分组的时间＝包容量/链路速率
 排队时延：等待输出链路空闲，与当时流量和排队规则有关
 传输时延：数据量/带宽；微秒到毫秒级
 传播时延：距离/光速(光缆中1000km传播延迟约5ms) 广域网在毫秒级

 端到端吞吐率 = 实际传输
大小/传输时间
 实际传输时间 = RTT+ 传输
大小/信道带宽
 RTT：请求与回答时间
</code></pre><p> 问题：信道带宽1Gbps，一端到另一端传播时<br>延τ= 10ms，TCP发送窗口65535字节。问可<br>能达到的最大吞吐率T ？信道利用率ρ？<br> 解析：T= size/(2τ+size/BW)<br> = size<em>BW/(2τ</em>BW+size) bps<br> = 65535<em>8</em>109/(20<em>109</em>10-3s+65535<em>8)bps<br> = 524280</em>103/(20 *106 +524280)Mbps<br> = 25.5 Mbps，ρ=25.5M/1000M=2.55%</p><p> 带宽和延迟的组合可描述链路或信道的特征，其相对重<br>要性取决于具体的应用<br> 有些应用延迟支配带宽（SSH），如端客户发送1字节到服务器<br>并依次收到1字节就是延迟重要，如果响应中没有大量的计算，<br>由于跨洲信道要100ms的RTT，同一房间内仅1ms RTT，所以不<br>同延迟导致完全不同效果<br> 数字图书馆来说是带宽支配延迟。设带宽10Mbps,则需<br>20s(2.5MByte的一个图片)，信道是1ms或者100ms延迟不重要，<br>20.001s和20.1s之差可略</p><p>延迟带宽积（以太网相关参数）<br> 一对进程通道间的延迟(总体延迟)带宽积：信道管道的体积=链路上所<br>容纳的比特数<br> 一个信道延迟=50ms ,带宽45Mbps, 则能容纳=50ms<em> 45Mbps=50</em>10-<br>3 sec*45Mbits/sec =2.25Mbits<br> 等价于信道上同时可以存在281K个Byte信号（2.25M/8）</p><ol start="3"><li>习题<br> 假设在地球和月球间建立一点对点100MPS的连接，地<br>月距离为385,000KM，数据传播速度为光速（3<em>108<br>M/S）<br> A．计算最小的RTT<br> B．use the RTT as the delay , calculate the delay</em>bandwidth<br>product for the link<br> C. 在B中计算的delay*bandwidth有何意义？<br> D．在月球照的照片，并以数字格式存在磁盘上。如果地球上的<br>控制中心想下载25M的最新的图形，那么从发出数据到传输完成<br>所要的最小时间是多少？</li></ol><h2 id="Ch1-2-直连网络技术"><a href="#Ch1-2-直连网络技术" class="headerlink" title="Ch1-2 直连网络技术"></a>Ch1-2 直连网络技术</h2><h2 id="Ch1-3-报文交换"><a href="#Ch1-3-报文交换" class="headerlink" title="Ch1-3 报文交换"></a>Ch1-3 报文交换</h2><h2 id="Ch1-4-TCP-IP网络技术"><a href="#Ch1-4-TCP-IP网络技术" class="headerlink" title="Ch1-4 TCP/IP网络技术"></a>Ch1-4 TCP/IP网络技术</h2><h1 id="第二章-IPv6"><a href="#第二章-IPv6" class="headerlink" title="第二章 IPv6"></a>第二章 IPv6</h1><ol><li><p>IPv4和IPv6差异？</p></li><li><p>IPv6地址分类和特点</p></li><li><p>IPv6地址自动分配两种方式, stateless过程</p></li><li><p>IPv6邻居发现协议中：地址解析和DAD</p></li><li><p>IPSec基本概念</p></li></ol><h1 id="第三章-拥塞控制"><a href="#第三章-拥塞控制" class="headerlink" title="第三章 拥塞控制"></a>第三章 拥塞控制</h1><ol><li>拥塞控制基本概念</li></ol><ul><li>Power=吞吐率/延迟</li><li>公平的定义</li></ul><ol start="2"><li>排队算法： FIFO, fQ, wfq</li><li>流量整形：漏桶、令牌桶算法（PPT习题）</li><li>TCP拥塞控制机制（慢启动、拥塞避免、快乘船、快速回复）</li><li>拥塞避免：ECN，RED，TCP Veges算法</li></ol><h1 id="第四章-P2P"><a href="#第四章-P2P" class="headerlink" title="第四章 P2P"></a>第四章 P2P</h1><ol><li>三代P2P网络之间的定义和差异是什么？</li></ol><ul><li>第一代：混合式P2P网络（第一代）</li></ul><p> 拓扑结构：服务器仍然是网络的核心<br> 底层协议：全部使用TCP，限制了链接的Peer数量<br> 查询与路由简单高效：<br> Napster和BT的用户访问服务器；服务器返回文件索引或种子文件<br>；用户再直接同另一Peer连接<br> 故路由跳数为O(1)，即常数跳<br> 容错、自适应和匿名性<br> 服务器单点失效率高<br> 自组织和自适应主要依靠服务器<br> 服务器的存在使匿名性实际不可能<br> 用户接入无安全认证机制</p><ol><li>Napster和Gnutella的原理</li></ol><ul><li>第二代：非结构化P2P网络（第二代）</li></ul><ul><li>第三代：结构化P2P网络(第三代)</li></ul><ol><li>掌握Chord协议</li></ol><ol start="2"><li>理解Kademlia的原理，例如Kademlia协议是如何找到资源的</li></ol><ol start="3"><li>掌握Bitcoin原理（论文）以及区块链概念</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/2020-01-01-hello-world/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020-01-01-hello-world/" class="post-title-link" itemprop="url">hello world</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-01T00:00:00+08:00">2020-01-01</time></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><p>demo</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/现代计算机网络lab03-TCP Congestion性能测试分析/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/现代计算机网络lab03-TCP Congestion性能测试分析/" class="post-title-link" itemprop="url">现代计算机网络lab03-TCP Congestion性能测试分析</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-21 13:23:31" itemprop="dateCreated datePublished" datetime="2019-12-21T13:23:31+08:00">2019-12-21</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网路/" itemprop="url" rel="index"><span itemprop="name">计算机网路</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网路/性能分析/" itemprop="url" rel="index"><span itemprop="name">性能分析</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="GNS3下的TCP-Congestion测试"><a href="#GNS3下的TCP-Congestion测试" class="headerlink" title="GNS3下的TCP Congestion测试"></a>GNS3下的TCP Congestion测试</h1><p>在GNS3中创建一个新项目，用三台SEED虚拟机按照如图方式连接起来(参考实验1，三台虚拟机分别为SEEDClient，SEED-Router，SEED-Server)，配置IP地址，让他们可以互相通信 如果物理机器性能一般，请用slitaz代替<br>SEED，不过必须自己安装一些软件，安装软件参考： slitaz文档：<a href="http://doc.slitaz.org" target="_blank" rel="noopener">http://doc.slitaz.org</a></p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/1.png" alt><br>注意的地方： 在GNS3中先给每台虚拟机配置三个网卡：</p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/2.png" alt></p><p>eth0网卡不要在GNS3中使用，而是用VirtualBox如下配置：</p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/3.png" alt><br>可以发现虚拟机可以同时访问外部网络<br>在SEED-Client和SEED-Server上安装iperf软件</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install iperf</span><br></pre></td></tr></table></figure><h1 id="Linux下的TCP拥塞控制算法"><a href="#Linux下的TCP拥塞控制算法" class="headerlink" title="Linux下的TCP拥塞控制算法"></a>Linux下的TCP拥塞控制算法</h1><ul><li>列出所有直接编译到内核的拥塞控制算法：<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">cubic reno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/4.png" alt></p><ul><li><p>修改当前的拥塞控制算法：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_congestion_control=cubic</span><br></pre></td></tr></table></figure></li><li><p>增加新的拥塞控制算法： linux支持的拥塞控制算法：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>怎么加载这些内核模块，来运行新的拥塞控制算法：<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#echo "westwood" &gt; /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line"><span class="comment">#cat /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line">westwood</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#echo "westwood" &gt; /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line"><span class="comment">#lsmod | grep westwood</span></span><br><span class="line">tcp_westwood 12675 0</span><br></pre></td></tr></table></figure><p></p><p>各种拥塞控制算法简介：</p><ul><li>High Speed TCP<br>The algorithm is described in RFC 3649. The main use is for connections with large<br>bandwidth and large RTT (such as Gbit/s and 100 ms RTT).</li><li>H-TCP<br>H-TCP was proposed by the Hamilton Institute for transmissions that recover more<br>quickly after a congestion event. It is also designed for links with high bandwidth and<br>RTT.</li><li>Scalable TCP<br>This is another algorithm for WAN links with high bandwidth and RTT. One of its design<br>goals is a quick recovery of the window size after a congestion event. It achieves this<br>goal by resetting the window to a higher value than standard TCP.<br>3.从SEED-Client虚拟机发包测试<br>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic<br>先在SEED-Server端运行下面的命令，让iperf的服务器端运行守护在5001端口：<br>在SEED-Client端运行下面的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参<br>数变化：</li><li>TCP BIC<br>BIC is the abbreviation for Binary Increase Congestion control. BIC uses a unique<br>window growth function. In case of packet loss, the window is reduced by a<br>multiplicative factor. The window size just before and after the reduction is then used<br>as parameters for a binary search for the new window size. BIC was used as standard<br>algorithm in the Linux kernel.</li><li>TCP CUBIC<br>CUBIC is a less aggressive variant of BIC (meaning, it doesn’t steal as much throughput<br>from competing TCP flows as does BIC).</li><li>TCP Hybla<br>TCP Hybla was proposed in order to transmit data efficiently over satellite links and<br>“defend” the transmission against TCP flows from other origins.</li><li>TCP Low Priority<br>This is an approach to develop an algorithm that uses excess bandwidth for TCP flows.<br>It can be used for low priority data transfers without “disturbing” other TCP<br>transmissions (which probably don’t use TCP Low Priority).</li><li>TCP Tahoe/Reno<br>These are the classical models used for congestion control. They exhibit the typical<br>slow start of transmissions. The throughput increases gradually until it stays stable.<br>It is decreased as soon as the transfer encounters congestion, then the rate rises<br>again slowly. The window is increased by adding fixed values. TCP Reno uses a<br>multiplicative decrease algorithm for the reduction of window size. TCP Reno is the<br>most widely deployed algorithm.</li><li>TCP Vegas<br>TCP Vegas introduces the measurement of RTT for evaluating the link quality. It uses<br>additive increases and additive decreases for the congestion window.</li><li>TCP Veno<br>This variant is optimised for wireless networks, since it was designed to handle random<br>packet loss better. It tries to keep track of the transfer, and guesses if the quality<br>decreases due to congestion or random packet errors.</li><li>TCP Westwood+<br>Westwood+ addresses both large bandwidth/RTT values and random packet loss together<br>with dynamically changing network loads. It analyses the state of the transfer by<br>looking at the acknowledgement packets. Westwood+ is a modification of the TCP Reno<br>algorithm.</li></ul><h1 id="从SEED-Client虚拟机发包测试"><a href="#从SEED-Client虚拟机发包测试" class="headerlink" title="从SEED-Client虚拟机发包测试"></a>从SEED-Client虚拟机发包测试</h1><p>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic<br>先在SEED-Server端运行下面的命令，让iperf的服务器端运行守护在5001端口：<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># iperf -s</span></span><br></pre></td></tr></table></figure><p></p><p>在SEED-Client端运行下面的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参<br>数变化：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modprobe tcp_probe port=5001 //对端口为5001（源或目的）的tcp连接进行监控</span></span><br><span class="line"><span class="comment"># cat /proc/net/tcpprobe &gt; data.txt &amp; // tcpprobe捕捉的信息是持续性的，可以放到后台读</span></span><br><span class="line"><span class="comment"># pid=$! // 保存上一个读命令的pid，用于结束读tcpprobe接口</span></span><br><span class="line"><span class="comment"># iperf -c otherhost // 使用iperf建立一个TCP流</span></span><br><span class="line"><span class="comment"># kill $pid</span></span><br></pre></td></tr></table></figure><p>在文件data.txt中保存了tcp的拥塞窗口变化情况，可以通过虚拟机共享目录或者网络导出，作为实验数据，iperf运<br>行结果：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/5.png" alt></p><p>记录在data.out中的数据大致是这个样子：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11.172120204 193.168.0.2:8089 193.168.0.25:54320 32 0x842ccad 0x84299c5 10 168 14608</span><br><span class="line">143</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每行的各列分别为：</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timestamp //时间戳</span><br><span class="line">saddr:port // 源IP及端口，我的数据是在发送端捕捉的，所以port是固定的8089</span><br><span class="line">daddr:port // 目的IP及端口</span><br><span class="line">skb-&gt;len // 收到的数据包skb大小，收到的都是ACK包，所以len都比较小。</span><br><span class="line">snd_nxt // 下一个待发送数据的序列号</span><br><span class="line">snd_una // 待确认数据的序列号</span><br><span class="line">snd_cwnd // 拥塞窗口大小</span><br><span class="line">ssthresh // 慢启动阈值</span><br><span class="line">snd_wnd // 接收窗口大小</span><br><span class="line">srtt // smoothed RTT</span><br></pre></td></tr></table></figure><p>实际的例子，看到拥塞窗口线性增加：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/6.png" alt><br>看到拥塞窗口线性减少，ssthresh折半回退（跟特定的拥塞控制算法相关例如Vegas）：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/7.png" alt></p><h1 id="增加延迟"><a href="#增加延迟" class="headerlink" title="增加延迟"></a>增加延迟</h1><p>可以在SEED-Router这台虚拟机连接SEED-Server网卡上增加延迟和丢包来改变网络环境，利用的是Linux中的<br>iproute 工具，以及内核中的Network Simulator特性：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tc qdisc change dev eth0 root netem loss 2.5%</span></span><br><span class="line">设置丢包</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem delay 30ms 10ms</span></span><br><span class="line">设置延迟</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem duplicate 1%</span></span><br><span class="line">该命令将 eth0 网卡的传输设置为随机产生 1% 的重复数据包</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem corrupt 0.2%</span></span><br><span class="line">该命令将 eth0 网卡的传输设置为随机产生 0.2% 的损坏的数据包</span><br><span class="line">删除网卡上面的相关配置，将之前命令中的 add 改为 del 即可删除配置</span><br></pre></td></tr></table></figure><p>qdisc表示在网卡上的排队策略，可以通过ifconfig命令查看：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@dl:~<span class="comment"># ip link show</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,PROMISC,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100</span><br><span class="line">link/ether 52:54:00:de:bf:19 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>qdisc支持的排队策略包括：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FIFO - simple FIFO (packet (p-FIFO) or byte (b-FIFO) )</span><br><span class="line">PRIO - n-band strict priority scheduler</span><br><span class="line">TBF - token bucket filter</span><br><span class="line">CBQ - class based queue</span><br><span class="line">CSZ - Clark-Scott-Zhang</span><br><span class="line">SFQ - stochastic fair queue</span><br><span class="line">RED - random early detection</span><br><span class="line">GRED - generalized random early detection</span><br><span class="line">TEQL - traffic equalizer</span><br><span class="line">ATM - asynchronous transfer mode</span><br><span class="line">DSMARK - DSCP (Diff-Serv Code Point)marker/remarker</span><br></pre></td></tr></table></figure><p>如果条件所限，还可以利用Linux防火墙来进行丢包，在Router上运行以下命令，实现0.5%的丢包<br></p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 121.14.48.1 -m statistic --mode random --probability 0.005 -j DROP</span><br></pre></td></tr></table></figure><p></p><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>根据以上网络配置和TCP性能测试方案，改变Router的延迟和丢包来测试TCP拥塞控制算法的性能：</p><ol><li>选择Linux内核支持的三种拥塞控制算法</li><li>针对每种拥塞控制算法进行性能测试，在性能测试中改变SEED-Router的丢包率和延迟，得到不同的性能测试<br>结果，记录测试结果</li><li>如果性能不行，换成slitaz虚拟机测试（需要编译内核）</li><li>对实验结果进行分析和比较</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/现代计算机网络lab02-实验报告/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/现代计算机网络lab02-实验报告/" class="post-title-link" itemprop="url">现代计算机网络lab02-实验报告</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-07 06:21:21" itemprop="dateCreated datePublished" datetime="2019-12-07T06:21:21+08:00">2019-12-07</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="环境（详细说明实验运行的操作系统，网络平台，机器的配置）"><a href="#环境（详细说明实验运行的操作系统，网络平台，机器的配置）" class="headerlink" title="环境（详细说明实验运行的操作系统，网络平台，机器的配置）"></a>环境（详细说明实验运行的操作系统，网络平台，机器的配置）</h2><p>操作系统：Windows 10 64bit Pro 1909</p><p>处理器：Intel® Xeon® CPU E3-1505M v6 \@ 3.00GHz</p><p>内存：DDR4 2666MHZ 24GB ECC</p><p>网络平台：GNS3 2.2.3</p><p>虚拟机软件：Oracle VM VirtualBox 6.0.14</p><p>虚拟机：Ubuntu 16.04 32bit</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>学会利用GNS3网络平台搭建网络拓扑结构并配置主机的IP和路由。</p></li><li><p>掌握SYN flood攻击的基本原理，利用虚拟机实现SYN flood攻击。</p></li><li><p>掌握SYN cookie的原理，并通过实验证明SYN cookie机制的有效性。</p></li><li><p>了解Linux内核TCP SYN Cookie机制，掌握查看与修改方法。</p></li></ol><div class="post-button text-center"><a class="btn" href="/现代计算机网络lab02-实验报告/#more" rel="contents">Read more &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[16]数值的整数次方/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[16]数值的整数次方/" class="post-title-link" itemprop="url">剑指Offer面试题[16]数值的整数次方</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-05 14:44:48" itemprop="dateCreated datePublished" datetime="2019-12-05T14:44:48+08:00">2019-12-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16:数值的整数次方"></a>面试题16:数值的整数次方</h1><p>题目：实现函数double Power(doubele base, iont exponent), 求base的exponent次方。 不得使用库函数，同时不需要考虑大数问题。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h2><p>下面这种解法只考虑了指数为正数的情况，并没有考虑指数小于1（0以及负正数）的情况：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=exponent; ++i)</span><br><span class="line">        result*=base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p>当指数为负时，可以先对指数求绝对值，算出次方的结果之后再取倒数。但是要避免底数为0时，对其进行负幂运算。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>)&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line"><span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">    absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result=PowerWithUnsignedExponent(base, basExponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1.0</span>/result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=exponent; ++i)</span><br><span class="line">        result *=base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另在上述代码中，我们用全局变量标识是否出错。如果出错，则返回值是0。为了区分出错的时候返回0，还是底数为0的时候正常运行返回的零，我们使用全局变量g_InvalidInput进行标识。</p><h2 id="完美解法"><a href="#完美解法" class="headerlink" title="完美解法"></a>完美解法</h2><p>加速运算，将指数运算拆分成若干指数运算的乘积：<br>$$a^n=\begin{cases}<br>a^{n/2}\cdot a^{n/2} &amp; n为偶数 \<br>a^{(n-1)/2}\cdot a^{(n-1)/2} &amp; n为奇数\<br>\end{cases}$$<br>然后使用递归法求运算结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span>  base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> result=PowerWithUnsignedExponent(base, exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    result *=result;</span><br><span class="line">    <span class="keyword">if</span>(exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">        result*=base;</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们还是用了两个小技巧：用右移运算符代替除以2，用位与运算符(%)来判断一个数是偶数还是奇数。因为位运算比size运算的效率要高很多，这样可以起到优化代码的作用。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/Ubuntu Server网络配置/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/Ubuntu Server网络配置/" class="post-title-link" itemprop="url">Ubuntu Server网络配置</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-05 03:49:37" itemprop="dateCreated datePublished" datetime="2019-12-05T03:49:37+08:00">2019-12-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Ubuntu/" itemprop="url" rel="index"><span itemprop="name">Ubuntu</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Ubuntu/Server/" itemprop="url" rel="index"><span itemprop="name">Server</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>需求：在进行内网穿透的实验过程中，需要将Ubuntu server的IPv4分配方式改为静态。</p><p>Ubuntu自17.10开始，就放弃使用/etc/network/interfaces进行Ip配置。因此，即使在新版本里对interfaces进行了配置，也不会生效。</p><p>新的方法是使用netplan方式进行配置 ，配置写在/etc/netplan/01-netcfg.yaml或者类似名称的yaml文件里。</p><p>Ubuntu Server 18.04的yaml配置文件是：/etc/netplan/50-cloud-init.yaml，修改配置以后不用重启，直接执行netplan apply 命令即可以让配置生效。</p><p>注意：以前的重启网络服务命令/etc/init.d/networking restart或者services network restrart也都会提示为无效命令。</p><h1 id="yaml配置模板"><a href="#yaml配置模板" class="headerlink" title="yaml配置模板"></a>yaml配置模板</h1><p>下面是我的配置模板：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file is generated from information provided by</span></span><br><span class="line"><span class="comment"># the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="comment"># To disable cloud-init's network configuration capabilities, write a file</span></span><br><span class="line"><span class="comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="comment"># network: &#123;config: disabled&#125;</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">        <span class="attr">enp9s0:</span></span><br><span class="line">            <span class="attr">addresses:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.133</span><span class="number">.120</span><span class="string">/24</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.133</span><span class="number">.1</span></span><br><span class="line">            <span class="attr">nameservers:</span></span><br><span class="line">                <span class="attr">addresses:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">                <span class="attr">search:</span> <span class="string">[]</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/现代计算机网络lab02-SYN flood攻击及SYN cookie原理分析/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/现代计算机网络lab02-SYN flood攻击及SYN cookie原理分析/" class="post-title-link" itemprop="url">现代计算机网络lab02-SYN flood攻击及SYN cookie原理分析</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-12-01 11:19:37" itemprop="dateCreated datePublished" datetime="2019-12-01T11:19:37+08:00">2019-12-01</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络空间安全/" itemprop="url" rel="index"><span itemprop="name">网络空间安全</span></a></span> , <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络空间安全/网络实验/" itemprop="url" rel="index"><span itemprop="name">网络实验</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul><li><p>SEED：计算机安全教育的教学实验平台 • <a href="http://www.cis.syr.edu/~wedu/seed/" target="_blank" rel="noopener">http://www.cis.syr.edu/~wedu/seed/</a> • 纽约雪城大学 杜文亮 (Du, Wenliang)教授设计和实现，从2002年 开始得到NSF 1.2M$的资助</p></li><li><p>SEED内容包含以下几类</p></li><li><p>网络安全主要包括十大实验</p></li><li>分为攻击类、破解类、实现类</li><li>难度越大、消耗的时间越长</li></ul><h1 id="二、TCP-IP-攻击实验"><a href="#二、TCP-IP-攻击实验" class="headerlink" title="二、TCP/IP 攻击实验"></a>二、TCP/IP 攻击实验</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>• Netwox Tools作为报文生成工具<br>• Wireshark 报文截获工具<br>• 启动 ftp and telnet Servers</p><p>• Task 1 : SYN Flooding Attack<br>• Task 2 : TCP RST Attacks on telnet and ssh Connections<br>• Task 3 : TCP RST Attacks on Video Streaming Applications<br>• Task 4 : TCP Session Hijacking<br>• Task 5 : Creating Reverse Shell using TCP Session Hijacking<br>• 注意：攻击者可以观察到被攻击者的流<br>• netwox Tools一共提供了200多个工具<br>• 运行netwox，进入界面后<br>• 选项3搜索工具<br>• 选项4显示帮助</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>• VirtualBox新建虚拟机</p><p>• 导入SEED 虚拟机镜像文件，运行虚拟机</p><p>• 普通用户登陆，有特权操 作再su<br>• 超级用户 User ID: root, Password: seedubuntu.<br>• 普通用户 User ID: seed, Password: dees</p><p>• 利用GNS3配置如图网络<br>• SEED ubuntu 攻击 SEED Ubuntu target<br>• 配置好两台主机的地址和路由</p><h3 id="配置IP地址命令："><a href="#配置IP地址命令：" class="headerlink" title="配置IP地址命令："></a>配置IP地址命令：</h3><p>• ip address显示地址<br>• sudo ip address add 192.168.1.1/24 dev eth0 添加IP<br>• sudo ip address del 192.168.1.1/24 dev eth0 删除IP</p><h3 id="增加路由"><a href="#增加路由" class="headerlink" title="增加路由"></a>增加路由</h3><p>• ip route显示路由<br>• sudo ip route add 192.168.1.0/24 dev eth0<br>• sudo ip route del 192.168.1.0/24 dev eth0</p><h3 id="增加路由-1"><a href="#增加路由-1" class="headerlink" title="增加路由"></a>增加路由</h3><p>• ip route add {NETWORK/MASK} via {GATEWAYIP}</p><h3 id="增加默认路由"><a href="#增加默认路由" class="headerlink" title="增加默认路由"></a>增加默认路由</h3><p>• ip route add default via 192.168.1.1<br>• 永久修改网络配置，图形界面配置</p><p>• SEED Ubuntu target上启动telnet服务： service service openbsd-inetd start<br>• 攻击命令： netwox 76 -i 192.168.1.1 –dst-port 23<br>• 可以在SEED ubuntu 或者 SEED Ubuntu target 上用 tcpdump或者wireshark观察攻击报文： 如左图<br>• 可以在SEED ubuntu 或者 SEED Ubuntu target 上用 tcpdump或者wireshark观察建立连接： netstat –n –tcp</p><h1 id="进一步观察linux内核tcp-syn-cookie机制"><a href="#进一步观察linux内核tcp-syn-cookie机制" class="headerlink" title="进一步观察linux内核tcp syn cookie机制"></a>进一步观察linux内核tcp syn cookie机制</h1><p>配置内核参数的两种方式：<br>• cat /proc/sys/net/ipv4/tcp_syncookies<br>• echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies<br>• sysctl –a | grep net.ipv4.tcp_max_syn_backlog<br>• sysctl -w net.ipv4.tcp_max_syn_backlog = 5<br>比较打开和关闭SEED Ubuntu target内核tcp syn cookie参数，syn flood攻击的效果：</p><ol><li>设置SEED Ubuntu target上， net.ipv4.tcp_max_syn_backlog=5 2.</li><li>设置SEED Ubuntu target上， net.ipv4. tcp_syncookies=0</li><li>从SEED Ubuntu 上用netwox的syn flood攻击SEED Ubuntu target</li><li>同时从SEED Ubuntu 上用telnet 主机 SEED Ubuntu target，看能否建立连 接？</li></ol><p>打开SEED Ubuntu target内核tcp syn cookie参数，同时从SEED Ubuntu 上用 telnet 主机 SEED Ubuntu target，看能否建立连接？</p><h1 id="实验报告要求"><a href="#实验报告要求" class="headerlink" title="实验报告要求"></a>实验报告要求</h1><ol><li>写出完整的实验配置过程，包括拓扑结构和配置命令</li><li>用截图的方式描述实验结果</li><li>描述tcp syn cookie的原理</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/Nginx配置多https站点/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/Nginx配置多https站点/" class="post-title-link" itemprop="url">Nginx配置多https站点</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-28 23:20:37" itemprop="dateCreated datePublished" datetime="2019-11-28T23:20:37+08:00">2019-11-28</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>最近需要在一台云服务器上使用Nginx同时部署多个http与https服务。使得多个http以及https站点分别监听80以及443端口。</p><h1 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h1><p>在此之前，我已经成功地在服务器上部署了单对http以及https服务，并强制使http跳转到https。在部署多https时，参考了很多博客，有的说使用正向代理，也有说使用反向代理的，后来仔细学习了Nginx，才发现原来事情根本没有那么复杂，只需要像配置单对http以及https服务那样，将配置文件重新复制一份就行了。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>现有domain, domian2, …, domianN 一共N个站点需要同时监听80以及443端口，且使用80端口访问其中任一站点时，nginx将会将这些请求发送到此站点对应的443端口。<br>下面是Nginx对于<a href="http://www.domain.com站点的配置文件，将其存储在/etc/nginx/conf.d目录下，习惯将其命名为domain.conf。" target="_blank" rel="noopener">www.domain.com站点的配置文件，将其存储在/etc/nginx/conf.d目录下，习惯将其命名为domain.conf。</a><br></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/domain.conf</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line"><span class="comment">#填写绑定证书的域名</span></span><br><span class="line"><span class="attribute">server_name</span> www.domain.com; </span><br><span class="line"><span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span></span><br><span class="line"><span class="attribute">root</span> /var/www/www.domain.com; </span><br><span class="line"><span class="attribute">index</span> index.html index.htm;   </span><br><span class="line"><span class="comment">#证书文件名称</span></span><br><span class="line"><span class="attribute">ssl_certificate</span>  1_www.domain.com_bundle.crt; </span><br><span class="line"><span class="comment">#私钥文件名称</span></span><br><span class="line"><span class="attribute">ssl_certificate_key</span> 2_www.domain.com.key; </span><br><span class="line"><span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line"><span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line"><span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="comment">#填写绑定证书的域名</span></span><br><span class="line"><span class="attribute">server_name</span> www.domain.com; </span><br><span class="line"><span class="comment">#把http的域名请求转成https</span></span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于其余的$N-1$个站点，只需要将此配置文件复制$N-1$份，并将其中domian名称以及对应的ssl文件存储位置进行替换即可。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[15]二进制中1的个数/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[15]二进制中1的个数/" class="post-title-link" itemprop="url">剑指Offer面试题[15]二进制中1的个数</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-25 14:35:05" itemprop="dateCreated datePublished" datetime="2019-11-25T14:35:05+08:00">2019-11-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题15"><a href="#面试题15" class="headerlink" title="面试题15"></a>面试题15</h1><p>题目：请事先一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示1的个数。例如，把9表示成二进制是1001，有2位是1.因此，如果输入9，则该函数输出2。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：可能会引起死循环"><a href="#法一：可能会引起死循环" class="headerlink" title="法一：可能会引起死循环"></a>法一：可能会引起死循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二：常规解法"><a href="#法二：常规解法" class="headerlink" title="法二：常规解法"></a>法二：常规解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">            count++;</span><br><span class="line">        flag=flag&lt;&lt;<span class="number">1</span>;&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法三：推荐解法"><a href="#法三：推荐解法" class="headerlink" title="法三：推荐解法"></a>法三：推荐解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n=(n<span class="number">-1</span>)^n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[14]剪绳子/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[14]剪绳子/" class="post-title-link" itemprop="url">剑指Offer面试题[14]剪绳子</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-25 14:23:02" itemprop="dateCreated datePublished" datetime="2019-11-25T14:23:02+08:00">2019-11-25</time></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题14"><a href="#面试题14" class="headerlink" title="面试题14"></a>面试题14</h1><p>题目：给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度纪委k[0]，k[1]，…，k[m]。请问k[0]$\times$k[1]$\times$···$\times$k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2, 3, 3的三段，此时得到的最大乘积是18。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：动态规划"><a href="#法一：动态规划" class="headerlink" title="法一：动态规划"></a>法一：动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">int</span> product=products[j]*products[i-j];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;product)</span><br><span class="line">                max = product;</span><br><span class="line">            products[i]=max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max=products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二：贪婪算法"><a href="#法二：贪婪算法" class="headerlink" title="法二：贪婪算法"></a>法二：贪婪算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尽可能多地剪去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length/<span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当绳子最后剩下的长度为4时，不能再剪去长度为3的绳子短</span></span><br><span class="line">    <span class="comment">//此时更好的方法是把绳子剪成长度为2的两端，因为2*2&gt;3*1</span></span><br><span class="line">    <span class="keyword">if</span>(length-timesOf3*<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">        timesOf3-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf2=(length-timesOf3*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3))*(<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[13]机器人的运动范围/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[13]机器人的运动范围/" class="post-title-link" itemprop="url">剑指Offer面试题[13]机器人的运动范围</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-25 14:17:14" itemprop="dateCreated datePublished" datetime="2019-11-25T14:17:14+08:00">2019-11-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题13"><a href="#面试题13" class="headerlink" title="面试题13"></a>面试题13</h1><p>题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 17)，因为3+5+3+8=18。但它不能进入方格(35, 38)，因为3+5+3+9=19，请问该机器人能够到达多少格子？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threshold&lt;<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> *visited=<span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;rows*cols; ++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> movingCountCore(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>*visited)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited))</span><br><span class="line">    &#123;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">true</span>;</span><br><span class="line">            count=<span class="number">1</span>+movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)+movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited)+movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)+movingCountCore(threshold, rows,cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols&amp;&amp;getDigitSum(row)+getDigitSum(col)&lt;=threshold&amp;&amp;!visited[row*cols+col])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=number%<span class="number">10</span>;</span><br><span class="line">        number/=<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[12]矩阵中的路径/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[12]矩阵中的路径/" class="post-title-link" itemprop="url">剑指Offer面试题[12]矩阵中的路径</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-25 14:06:36" itemprop="dateCreated datePublished" datetime="2019-11-25T14:06:36+08:00">2019-11-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题12"><a href="#面试题12" class="headerlink" title="面试题12"></a>面试题12</h1><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一个路径经过了矩阵的某一个，那么该路径不能再次进入该格子。例如，在下面的3$\times4$的矩阵中包含一条字符串“bfee”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串”abfb”的路径，因为字符串的第一个字符b占据了矩阵中第一行第二个格子之后，路径不能再次进入这个格子。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span>||rows&lt;<span class="number">1</span> ||cols&lt;<span class="number">1</span>||str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows*cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row&lt;rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;cols;++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str, pathlength, visited))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasPath=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;<span class="number">0</span>&amp;&amp;col&lt;cols &amp;&amp;matrix[row*cols+col]==str[pathLength]&amp;&amp;!visited[row*cols+col])</span><br><span class="line">    &#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[rows*cols+col]=<span class="literal">true</span>;</span><br><span class="line">        hasPath=hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>, str, pathLength, visited)||hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>, str, pathLength, visited)||hasPath(matrix, rows, cols, row+<span class="number">1</span>, col, str, pathLegnth, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[11]旋转数组的最小数字/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[11]旋转数组的最小数字/" class="post-title-link" itemprop="url">剑指Offer面试题[11]旋转数组的最小数字</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-25 13:25:05" itemprop="dateCreated datePublished" datetime="2019-11-25T13:25:05+08:00">2019-11-25</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题11"><a href="#面试题11" class="headerlink" title="面试题11"></a>面试题11</h1><p>题目：把一个数组最开始的若干数组搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最值为1.</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">intMin（<span class="keyword">int</span>*numbers， <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid parameters"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = length <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">        <span class="keyword">while</span>(numbers[index1]&gt;=numbers[index2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2-index1==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                indexMid=index2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexMid=(index1+index2)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1])</span><br><span class="line">                index1 indexMid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2])</span><br><span class="line">                index2 = indexMid</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* number, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"invalid parameters"</span>);</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = length <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">    <span class="keyword">while</span>(numbers[index1]&gt;=numbers[index2])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2-index==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            indexMid=index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexMid=(index1+index2)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果下表为index1、index2和indexMid指向的三个数字相等，</span></span><br><span class="line">        <span class="comment">//则只能顺序查找</span></span><br><span class="line">        <span class="keyword">if</span>（numbers[index1]==numbers[index2]&amp;&amp;numbers[indexMid]==numbers[index1])</span><br><span class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1])</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2])</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[index1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index1+<span class="number">1</span>; i&lt;=index2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>（result&gt;numbers[i])</span><br><span class="line">        result=numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[9]用两个栈实现队列/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[9]用两个栈实现队列/" class="post-title-link" itemprop="url">剑指Offer面试题[9]用两个栈实现队列</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-17 04:24:04" itemprop="dateCreated datePublished" datetime="2019-11-17T04:24:04+08:00">2019-11-17</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题9：用两个栈实现队列"><a href="#面试题9：用两个栈实现队列" class="headerlink" title="面试题9：用两个栈实现队列"></a>面试题9：用两个栈实现队列</h1><p>题目：用两个栈实现一个队列。队列的生命如下，请事先它的菱格函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">void</span>);</span><br><span class="line">    ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">    T.deleteHead();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>本题属于基本题，利用栈的先进后出的特性，使用两个栈便可实现队列的功能。代码如下：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">void</span> CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>.size()&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data=stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">    T head=stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[10]斐波那契数列/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[10]斐波那契数列/" class="post-title-link" itemprop="url">剑指Offer面试题[10]斐波那契数列</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-17 04:23:25" itemprop="dateCreated datePublished" datetime="2019-11-17T04:23:25+08:00">2019-11-17</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题10"><a href="#面试题10" class="headerlink" title="面试题10"></a>面试题10</h1><h2 id="题目一：求斐波那契数列的第n项"><a href="#题目一：求斐波那契数列的第n项" class="headerlink" title="题目一：求斐波那契数列的第n项"></a>题目一：求斐波那契数列的第n项</h2><p>写一个函数，输入$n$，求斐波那契(Fibonacci)数列的第$n$项。斐波那契数列的定义如下：<br>$$f(n)=\begin{cases}<br>0 &amp; n=0\<br>1 &amp; n=1\<br>f(n-1)+f(n-2) &amp; n&gt;1<br>\end{cases} $$</p><h2 id="题目二：青蛙跳台阶问题"><a href="#题目二：青蛙跳台阶问题" class="headerlink" title="题目二：青蛙跳台阶问题"></a>题目二：青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个$n$级台阶总共有多少种跳法。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="效率很低的解法"><a href="#效率很低的解法" class="headerlink" title="效率很低的解法"></a>效率很低的解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用解法"><a href="#实用解法" class="headerlink" title="实用解法"></a>实用解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">2</span>]=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusOne = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusTwo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fibN = fibNMinusOne +fibNMinusTwo;</span><br><span class="line">        fibNMinusTwo=fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度为-O-log-n-，但不够实用"><a href="#时间复杂度为-O-log-n-，但不够实用" class="headerlink" title="时间复杂度为$O(\log{n})$，但不够实用"></a>时间复杂度为$O(\log{n})$，但不够实用</h3><p>使用数学公式，可以将问题转化为如何求得矩阵$\left[<br>\begin{matrix}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{matrix}<br>\right]<br>$<br>的乘方。</p><p>$$<br>\left[<br>\begin{matrix}<br>f(n) &amp; f(n-1) \<br>f(n-1) &amp; f(n-2) \<br>\end{matrix}<br>\right]<br>=<br>\left[<br>\begin{matrix}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{matrix}<br>\right]<br>$$<br>考虑到乘方具有如下性质：<br>$$a^n=\begin{cases}<br>a^{n/2} &amp; n为偶数\<br>a^{(n-1)/2}\cdot a^{(n-1)/2}\cdot a&amp; n为奇数\<br>\end{cases} $$<br>因此，想求得$n$次方，只需要闲求得$n/2$次方，再把$n/2$次方的结果进行平方即可。可使用递归法求解。递归法的时间复杂度是$O(\log{n})$</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>题目二同样可以归结为斐波那契数列，使用同样的解法便可求得。在此不再赘述。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[8]二叉树的下一个节点/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[8]二叉树的下一个节点/" class="post-title-link" itemprop="url">剑指Offer面试题[8]二叉树的下一个节点</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-17 04:22:27" itemprop="dateCreated datePublished" datetime="2019-11-17T04:22:27+08:00">2019-11-17</time></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h1><p>题目：给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果一个节点有右节点，那么它的下一个节点就是它的右子树中的最左节点。<br>如果一个节点没有右子树，且这个节点是其父节点的左子节点，那么它的下一个节点是其父节点。<br>如果一个节点没有右子树，且这个节点是其父节点的右子节点，那么我们需要经这个节点沿着指向其府机电的指针一直向上遍历，知道找到一个节点，这个节点是其父节点的左子节点，那么这个节点的父节点就是我们要找的节点。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight =pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRight=pRight-&gt;m_pLeft;</span><br><span class="line">        pNext=pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent!=<span class="literal">nullptr</span> &amp;&amp;pCurrent ==pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext=pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[7]重建二叉树/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[7]重建二叉树/" class="post-title-link" itemprop="url">剑指Offer面试题[7]重建二叉树</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-17 04:21:53" itemprop="dateCreated datePublished" datetime="2019-11-17T04:21:53+08:00">2019-11-17</time></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h1><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不喊重复的数字。例如，输入前序遍历序列{1, 2, 4, 7, 3, 5, 7, 8}和中序遍历{4, 7, 2, 1, 5, 3, 8 ,6}, 则重建如图2.6所示的二叉树并输出它的头结点。二叉树节点的定义如下：<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    BinaryTreeNode* m_pLeft;</span><br><span class="line">    BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>前序遍历的特点：根左右<br>中序遍历的特点：左根右<br>我们可以根据前序遍历确定二叉树根节点，再对照根节点在中序遍历中的位置逐步确定其余节点与根节点的父子关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="literal">nullptr</span>||inorder == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder, preorder+length<span class="number">-1</span>, inorder, inorder+length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">BinaryTreeNode* ConstructCore</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder,</span><br><span class="line">    <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前序遍历序列的第一个数字是根节点的值</span></span><br><span class="line">    <span class="keyword">int</span> rootValue=startPreorder[<span class="number">0</span>];</span><br><span class="line">    BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">    root-&gt;m_nValue = rootValue;</span><br><span class="line">    root-&gt;m_pLeft = root-&gt;m_pRight=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startPreorder == endPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在中序遍历序列中找到根节点的值</span></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span>(rootInorder &lt;=endInorder &amp;&amp; *rootInorder !=rootValue)</span><br><span class="line">        ++rootInorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder !=rootValue)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength=rootInorder-startInorder;</span><br><span class="line">        <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">        <span class="keyword">if</span>(leftLength&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建左子树</span></span><br><span class="line">            root-&gt;m_pLeft=ConstructCore(startPreorder+<span class="number">1</span>, leftPreorderEnd, startInorder, rootInorder<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftLength&lt;endPreorder-startPreorder)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建右子树</span></span><br><span class="line">            root-&gt;m_pRight=ConstructCore(leftPreorderEnd+<span class="number">1</span>, endPreorder, rootInorder+<span class="number">1</span>, endInorder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[6]从头到尾打印链表/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[6]从头到尾打印链表/" class="post-title-link" itemprop="url">剑指Offer面试题[6]从头到尾打印链表</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-17 03:28:01" itemprop="dateCreated datePublished" datetime="2019-11-17T03:28:01+08:00">2019-11-17</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题6"><a href="#面试题6" class="headerlink" title="面试题6"></a>面试题6</h1><p>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：<br>struct ListNode<br>{<br>int m_nKey;<br>ListNode* m_pNext;<br>};</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：修改链表指针"><a href="#法一：修改链表指针" class="headerlink" title="法一：修改链表指针"></a>法一：修改链表指针</h2><p>设前后两个指针，从前往后，依次改变所有链表指针的方向。但是这样做就修改了原始链表的结构。在面试中，需要若打算修改输入的数据，需要实现征询面试官的意见。</p><h2 id="法二：使用辅助栈"><a href="#法二：使用辅助栈" class="headerlink" title="法二：使用辅助栈"></a>法二：使用辅助栈</h2><p>输出数据具有“后进先出”的特点，即遍历的最后一个节点需要最先输出，因此，我们可以利用同样具有“后进先出”特性的栈数据结构，来辅助完成此操作。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes; <span class="comment">//辅助栈</span></span><br><span class="line">    </span><br><span class="line">    ListNode* pNode = pHead; <span class="comment">//让指针指向原始栈链表的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode); <span class="comment">//将头结点入栈</span></span><br><span class="line">        pNode = pNode-&gt;m_pNext; <span class="comment">//移动指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        print(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="法三：使用递归"><a href="#法三：使用递归" class="headerlink" title="法三：使用递归"></a>法三：使用递归</h2><p>递归本质上就是一种栈的结构，因此很自然地，可以使用栈来完成这种操作：每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结构就反过来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.flyinghuster.com/剑指Offer面试题[5]替换空格/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="刘中岳"><meta itemprop="description" content="飞翔的Huster"><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="The Flying Huster"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/剑指Offer面试题[5]替换空格/" class="post-title-link" itemprop="url">剑指Offer面试题[5]替换空格</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-11-16 13:39:14" itemprop="dateCreated datePublished" datetime="2019-11-16T13:39:14+08:00">2019-11-16</time></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span title="Symbols count in article">0</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">1 mins.</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="面试题5：替换空格"><a href="#面试题5：替换空格" class="headerlink" title="面试题5：替换空格"></a>面试题5：替换空格</h1><p>题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”, 则输出We%20are%20happy.”</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="时间复杂度为-O-n-2-的解法"><a href="#时间复杂度为-O-n-2-的解法" class="headerlink" title="时间复杂度为$O(n^2)$的解法"></a>时间复杂度为$O(n^2)$的解法</h2><p>从头到尾扫描字符串，每次碰到空格字符的时候进行替换。每次替换完毕之后，都把之后的字符往后移动两位。<br>假设字符串的长度是n。对于每个空格字符，需要移动后边$O(n)$个字符，因此对于含有$O(n)$个空格字符的字符串而言，总的时间效率是$O(n^2)$。<br></p><div class="post-button text-center"><a class="btn" href="/剑指Offer面试题[5]替换空格/#more" rel="contents">Read more &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="刘中岳"><p class="site-author-name" itemprop="name">刘中岳</p><div class="site-description motion-element" itemprop="description">飞翔的Huster</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">40</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/johannesliu" title="GitHub &rarr; https://github.com/johannesliu" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="mailto:iexkliu@gmail.com" title="E-Mail &rarr; mailto:iexkliu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a> </span><span class="links-of-author-item"><a href="https://plus.google.com/iexkliu" title="Google &rarr; https://plus.google.com/iexkliu" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a> </span><span class="links-of-author-item"><a href="https://twitter.com/iexkliu" title="Twitter &rarr; https://twitter.com/iexkliu" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a> </span><span class="links-of-author-item"><a href="https://www.facebook.com/iexkliu" title="FB Page &rarr; https://www.facebook.com/iexkliu" rel="noopener" target="_blank"><i class="fa fa-fw fa-facebook"></i></a> </span><span class="links-of-author-item"><a href="https://youtube.com/iexkliu" title="YouTube &rarr; https://youtube.com/iexkliu" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i></a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=458238836&auto=1&height=32"></iframe></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span style="padding-left:25px;background:url(https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png) no-repeat left center" rel="nofollow"><a href="http://www.beian.miit.gov.cn" rel="noopener" target="_blank">豫ICP备19040049号-1| </a><span style="padding-left:25px;background:url(https://www.return520.com/images/beian.png) no-repeat left center" rel="nofollow"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=" rel="noopener" target="_blank">豫公网安备 41132402411642号 </a>&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-at"></i> </span><span class="author" itemprop="copyrightHolder">刘中岳</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">Symbols count total: </span><span title="Symbols count total">112k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">Reading time total &asymp;</span> <span title="Reading time total">1:22</span></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.1.2"></script><script src="/js/motion.js?v=7.1.2"></script><script src="/js/affix.js?v=7.1.2"></script><script src="/js/schemes/pisces.js?v=7.1.2"></script><script src="/js/next-boot.js?v=7.1.2"></script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });
  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') { next = next.nextSibling }
        if (next && next.nodeName.toLowerCase() === 'br') { next.parentNode.removeChild(next) }
      }
    });
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      document.getElementById(all[i].inputID + '-Frame').parentNode.className += ' has-jax';
    }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>$(".highlight").not(".gist .highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("Copy").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=window.pageYOffset||document.documentElement.scrollTop;n.style.top=o+"px",n.style.position="absolute",n.style.opacity="0",n.readOnly=!0,n.value=t,document.body.appendChild(n);const a=document.getSelection(),i=a.rangeCount>0&&a.getRangeAt(0);n.select(),n.setSelectionRange(0,t.length),n.readOnly=!1;var d=document.execCommand("copy");d?$(this).text("Copied"):$(this).text("Copy failed"),n.blur(),$(this).blur(),i&&(a.removeAllRanges(),a.addRange(i))})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("Copy")},300)}).append(t)})</script></body></html><!-- rebuild by neat -->