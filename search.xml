<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SpringCloud分布式微服务架构实战学习笔记（一）微服务架构概述</title>
    <url>/SpringCloud%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>本笔记是对梦学谷课程Spring Cloud微服务课程的总结。笔者在学习梦学谷相关课程过程中收获颇丰。请支持正版课程。</p><h1 id="微服务概述"><a href="#微服务概述" class="headerlink" title="微服务概述"></a>微服务概述</h1><p>马丁·福勒 ，他于2014年发表了一篇关于微服务的博客<br>博客：<a href="https://martinfowler.com/microservices/" target="_blank" rel="noopener">https://martinfowler.com/microservices/</a><br>微服务详细文档：<br>英文：<a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa微服务是一种架构风格，是以开发一组小型服务的方式来作为一个独立的应用系统，每个服务都运行在自已的进程中，服务之间采用轻量级的HTTP通信机制" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa微服务是一种架构风格，是以开发一组小型服务的方式来作为一个独立的应用系统，每个服务都运行在自已的进程中，服务之间采用轻量级的HTTP通信机制</a> ( 通常是采用HTTP的RESTful API )进行通信。这些服务都是围绕具体业务进行构建的，并且可以独立部署到生产环境上。这些服务可以用不同的编程语言编写，并且可以使用不同的数据存储技术。对这些微服务我们只需要使用一个非常轻量级的集中式管<br>理来进行协调。</p><a id="more"></a><h1 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h1><ul><li>单体应用架构概念<br>一个应用中包含了应用程序的所有功能（比如：页面，代码，配置等），把应用打成一个war或jar包部署到<br>Tomcat中，通常称为单体应用架构。</li><li>单体架构图<br><img src="/SpringCloud分布式微服务架构实战学习笔记（一）微服务架构概述/单体架构应用.png" alt="单体架构应用"></li><li>单体应用架构的优缺点<br>优点 易于开发&amp;测试：单个应用包含所有功能，不涉及多个应用的互联互调，便于在团队之间开发与测<br>试。 易于部署：只需将单个应用打成war或jar包，进行部署到Tomcat即可，运维起来比较方便。<br>易于整体扩展：当应用负载压力大时，将这个应用复制几份，分别部署在不同的服务器上，再通过负载<br>均衡即可提高应用的并发能力。<br>缺点 复杂性高：由于是单个应用，所以整个项目文件包含的模块非常多，导致模块的边界模糊、依赖关<br>系不清晰、代码的质量参差不齐，混乱的堆在一起，使得整个项目非常复杂。以致每次修改代码，都非<br>常小心，可能添加一个简单的功能，或者修改一个Bug都会带来隐藏的缺陷。 技术债务：随着时间的推<br>移、需求的变更和技术人员的更替，会逐渐形成应用程序的技术债务，并且越积越多。 阻碍技术创新：<br>对于单体应用来说，技术是在开发之前经过慎重评估后选定的，每个团队成员都必须使用相同的开发语<br>言、持久化存储及消息系统。</li></ul><h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><ul><li>微服务架构概念<br>微服务是一种架构风格，是以开发一组小型服务的方式来作为一个独立的应用系统，每个服务都运行在自已<br>的进程中，服务之间采用轻量级的HTTP通信机制 ( 通常是采用HTTP的RESTful API )进行通信。这些服务都<br>是围绕具体业务进行构建的，并且可以独立部署到生产环境上。这些服务可以用不同的编程语言编写，并且<br>可以使用不同的数据存储技术。对这些微服务我们只需要使用一个非常轻量级的集中式管理来进行协调。</li><li>微服务架构图<br><img src="/SpringCloud分布式微服务架构实战学习笔记（一）微服务架构概述/微服务架构图.png" alt="微服务架构图"></li></ul><ul><li>微服务架构的优缺点<ul><li>优点</li></ul></li></ul><ol><li>易于开发和维护：一个微服务只会关注一个特定的业务功能，所以业务清晰、代码量较少。开发和<br>维护单个微服务相对简单。</li><li>单个微服务启动较快</li><li>局部修改容易部署：单一应用只要有修改，就得重新部署整个应用。微服务解决了这样的问题。一<br>般来说，对某个微服务进行修改，只需要重新部署这个服务即可。</li><li>技术栈不受限制：在微服务架构中，可以结合项目业务及团队的特点，合理的选择技术栈。</li><li>按需伸缩：可根据需求，实现细粒度的扩展。<ul><li>缺点</li></ul></li><li>运维要求高：更多的服务意味着要投入更多的运维。</li><li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延<br>迟、分布式事务等都会带来巨大的问题。</li><li>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有用到这<br>个接口的微服务都需要进行调整。</li></ol><ul><li>微服务架构总结：<ul><li>微服务的核心就是将传统的单一应用，根据业务拆分成一个一个的服务，彻底地去耦合,每一个微服务提<br>供单个业务功能的服务，一个服务做一件事。</li></ul></li><li>在 IDEA 工具中使用Maven构建的一个个独立的 Module ，也就是使用Spring Boot 开发的一个个小模块<br>就是一个个微服务，将专业的事交给专业的模块来做。比如一个大型项目可能有上百个微服务，将这些<br>微服务集中起来构成一个大的系统，对外暴露服务进行调用与使用。</li><li>从技术角度看就是一种小而独立的处理过程，类似进程概念，能够自行单独启动或销毁，拥有自己独立<br>的数据库。</li></ul><h1 id="微服务架构技术栈"><a href="#微服务架构技术栈" class="headerlink" title="微服务架构技术栈"></a>微服务架构技术栈</h1><table><thead><tr><th>微服务技术维度</th><th>技术实现</th></tr></thead><tbody><tr><td>服务开发</td><td>Spring Boot、Spring、Spring MVC等</td></tr><tr><td>服务注册与发现</td><td>Eureka、Zookeeper等</td></tr><tr><td>服务调用</td><td>Rest、RPC等</td></tr><tr><td>服务熔断器</td><td>Hystrix、Envoy等</td></tr><tr><td>负载均衡</td><td>Ribbon、Nginx等</td></tr><tr><td>服务接口调用(客户端调用服务的简化工具)</td><td>Feign等</td></tr><tr><td>消息队列</td><td>Kafka、ActiveMQ等</td></tr><tr><td>服务配置中心管理</td><td>Spring Cloud Config等</td></tr><tr><td>服务路由（API网关）</td><td>Zuul等</td></tr><tr><td>服务监控</td><td>Zabbix、Nagios等</td></tr><tr><td>全链路追踪</td><td>Zipkin，Brave等</td></tr><tr><td>服务部署</td><td>Docker、OpenStack等</td></tr><tr><td>数据流处理</td><td>Spring Cloud Stream（Redis,Rabbit,Kafka等发送接收消息）</td></tr><tr><td>事件消息总线</td><td>Spring Cloud Bus</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>pip&amp;amp;conda切换国内源</title>
    <url>/pip&amp;conda%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>在使用pip和conda管理工具管理python第三方库时，经常会遇到下载超时而引发的错误。因此，我们需要在必要的时候对软件源进行调整。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><h3 id="单次切换国内原"><a href="#单次切换国内原" class="headerlink" title="单次切换国内原"></a>单次切换国内原</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">pip install packagename -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h3 id="修改配置文件位置"><a href="#修改配置文件位置" class="headerlink" title="修改配置文件位置"></a>修改配置文件位置</h3><p>windows配置文件目录：</p><p>文件路径：C:\Users\你的用户名\pip\pip.ini</p><p>*nix配置文件目录：<br>文件路径：~/.pip/pip.conf</p><p>将pip.ini或pip.conf内容修改如下：<br></p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line"><span class="built_in">index</span>-url = http<span class="variable">s:</span>//pypi.tuna.tsinghua.edu.<span class="keyword">cn</span>/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.tuna.tsinghua.edu.<span class="keyword">cn</span></span><br></pre></td></tr></table></figure><p></p><h2 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">conda config --add channels <span class="comment">#跟源站地址如https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">conda config --remove-key channels</span><br></pre></td></tr></table></figure><h3 id="设置搜索时显示通道地址"><a href="#设置搜索时显示通道地址" class="headerlink" title="设置搜索时显示通道地址"></a>设置搜索时显示通道地址</h3><p>conda config –set show_channel_urls yes</p><h3 id="修改配置文件位置-1"><a href="#修改配置文件位置-1" class="headerlink" title="修改配置文件位置"></a>修改配置文件位置</h3><p>在~/.condarc中输入下列内容<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">channels:</span><br><span class="line">  - https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - defaults</span><br><span class="line">show_channel_urls: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><h1 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h1><h2 id="pip源"><a href="#pip源" class="headerlink" title="pip源"></a>pip源</h2><table><thead><tr><th>源站</th><th>地址</th></tr></thead><tbody><tr><td>阿里云</td><td><a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></td></tr><tr><td>中国科技大学</td><td><a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></td></tr><tr><td>豆瓣(douban)</td><td><a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></td></tr><tr><td>清华大学</td><td><a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></td></tr><tr><td>中国科学技术大学</td><td><a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></td></tr></tbody></table><h2 id="conda源"><a href="#conda源" class="headerlink" title="conda源"></a>conda源</h2><table><thead><tr><th>源站</th><th>地址</th></tr></thead><tbody><tr><td>清华</td><td><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a> <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a> <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</a></td></tr><tr><td>中科大</td><td><a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/main/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</a> <a href="https://mirrors.ustc.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</a> <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/</a> <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</a> <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</a> <a href="https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</a></td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[17]打印从1到最大的n位数</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B17%5D%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题17-打印从1到最大的n位数"><a href="#面试题17-打印从1到最大的n位数" class="headerlink" title="面试题17:打印从1到最大的n位数"></a>面试题17:打印从1到最大的n位数</h1><p>题目：输入数字n，按顺序打印从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999.</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="典型错误解法"><a href="#典型错误解法" class="headerlink" title="典型错误解法"></a>典型错误解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintToMaxOfNDigits_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt;n)</span><br><span class="line">        number*=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;number; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在字符串上模拟数字加法"><a href="#在字符串上模拟数字加法" class="headerlink" title="在字符串上模拟数字加法"></a>在字符串上模拟数字加法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">'0'</span>, n);</span><br><span class="line">    number[n]=<span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!Increcement(number))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p><code>`</code>c++<br>void PrintToMaxOfNDigits(int n)<br>{<br>if(n&lt;=0)<br>reutrn;<br>char* number = new char[n+1];<br>number[n]=’\0’;</p><pre><code>for(int i =0; i&lt;10; i++i)
{
    number[0]=i+&apos;0&apos;;
    PrintToMaxOfNDigitsRecursively(number, n, 0);
}
delete[] number;
</code></pre><p>}</p><p>void PrintToMaxOfNDigitsRecursively(char* number, int length, int index)<br>{<br>if(index == length -1)<br>{<br>PrintNumber(number);<br>return;<br>}</p><pre><code>for(int i = 0; i&lt;10; ++i)
{
    number[index+1]=i+&apos;0&apos;;
    PrintToMaxOfNDigitsRecursively(number, length, index+1);
}
</code></pre><p>}</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱推理技术研究进展</title>
    <url>/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%8E%A8%E7%90%86%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>推理是用已有知识推断出未知知识的过程。知识推理是知识图谱中的一个重要环节。知识推理中的经典任务有知识补全、不一致性检测、知识问答等。</p><p>依据推理任务，推理的方法分为演绎推理、归纳推理以及设证推理。归纳推理是一个从特殊到一般的过程，通过对部分对象进行观察，从而推断整体对象具有的一些共性。而演绎推理则恰恰相反，演绎推理是一个从一半到特殊的过程，通过对整体对象进行观察，从而推断某一部分对象具有的一些特性。设证推理则是使用假设的理论区域经验相对照，以此来验证理论的正确性。<br>依据推理方法，推理的方法大致分为确定性推理和不确定推理。确定性推理也被称为逻辑推理，逻辑推理具有坚实的理论基础以及严格的推理过程，在专家预先定义好的规则约束下，逻辑推理可以准确的导出唯一的结论，也即逻辑推理的结论是固定的，其中典型的逻辑推理方法有可被用于一阶逻辑推理的基于前向连接的rete算法；可被用于求解命题逻辑推理的GSAT和WALKSAT算法。不确定推理也被称为概率推理，不确定性不严格按照既定规则去进行推理，而是使用统计学习等手段，根据已有经验，按照一定模式去构建概率模型。其中典型的概率推理方法有：概率图模型、概率逻辑推理以及关联规则挖掘。</p><p>依据推理形式，推理的方法大致分为符号推理和数值推理。基于知识图谱的符号推理直接在知识图谱中的试题和关系符号上进行推理操作，因此，符号推理也可被看作是逻辑推理。数值推理是使用数值，张量等数值计算方法以挖掘知识图谱上的隐藏特征，并以此来模拟推理过程。<br>面向知识图谱的推理主要围绕关系的推理展开，这就需要构建的知识图谱具有根据已有的事实或关系推断出未知的事实或关系的能力。目前，知识图谱的主要技术手段按推理任务可以分为两类：基于演绎的知识图谱推理与基于归纳的知识图谱推理，下面我们从演绎与归纳的观点出发，对主流推理技术进行介绍。图1展示了知识图谱推理技术研究进展。</p><p><img src="/知识图谱推理技术研究进展/知识图谱推理.jpg" alt="图1：知识图谱推理技术研究进展"></p><h1 id="基于演绎的知识图谱推理技术"><a href="#基于演绎的知识图谱推理技术" class="headerlink" title="基于演绎的知识图谱推理技术"></a>基于演绎的知识图谱推理技术</h1><p>基于演绎的知识图谱推理技术主要包括：本体推理方法、基于逻辑编程的推理方法，基于查询重写的方法和基于产生规则的方法。</p><h1 id="基于归纳的知识图谱推理技术"><a href="#基于归纳的知识图谱推理技术" class="headerlink" title="基于归纳的知识图谱推理技术"></a>基于归纳的知识图谱推理技术</h1><p>基于演绎的知识图谱推理技术主要包括：基于图结构的推理、基于规则学习的推理，基于表示学习的推理。</p><p>基于图结构的推理通过将知识图谱看做是有向图，利用图论相关算法来进行知识图谱推理。其中经典的基于图结构的推理算法有Path Ranking Algorithm，该算法通过使用该实体节点之间的路径作为特征以进行链路检测推理。</p><p>基于规则学习的推理，通过领域专家实现定义的规则，来进行推理。但是由于规则主要由领域专家提供，故而规则推理在大规模知识图谱的应用中十分局限，这主要是由于领域专家啊提供规则的效率比较低且知识图谱动态变化的特性导致的。为了克服这个困难，专家们提出了自动化的规则学习方法。其中经典的自动化规则学习算法有AMIE，AMIE是一种霍恩规则，通过SPARQL在知识图谱上的查询对规则的质量进行评估，从而对规则库进行自动化管理。</p><p>基于表示学习通过将知识图谱中包含实体和关系的元素映射到一个连续的向量空间中，从而使是的知识图谱可以使用预设的向量空间表示之间的计算方法来进行知识推理。其中经典的基于表示学习方法有：TransE，ConvE模型等。</p><h1 id="新兴的知识图谱推理技术"><a href="#新兴的知识图谱推理技术" class="headerlink" title="新兴的知识图谱推理技术"></a>新兴的知识图谱推理技术</h1><p>随着人工智能、大数据技术的快速发展以及科员人员对于知识图谱研究的进一步深入，出现了更先进的知识图谱推理技术。其中，以时序预测推理方法，基于强化学习的知识图谱推理方法、基于元学习的少样本知识图谱推理方法以及图神经网络与基于图神经网络的知识图谱推理方法等在知识推理方面有着广阔的应用与研究前景。下面，我们对这四种新兴知识图谱推理技术进行介绍。</p><p>时序预测推理方法扩展了传统机器学习中的特征嵌入应用范围，使其可用于本体语义嵌入，通过将语义推理和及其学习相结合以捕获本体流中的一致性和知识蕴含的向量，然后再有监督的刘学习的上下文中使用这种嵌入来进行学习。这种方法训练出的模型具有稳定性，通用性与灵活性的特点，它可以增强基本的刘学习算法。</p><p>基于强化学习的知识图谱推理技术在“查询问答”的推理任务上具有良好的性能，当知识图路径较长时，使用强化学习出的模型依然具有很高的准确率与可接受的效率。</p><p>基于元学习的少样本知识图谱推理方法近年来被用来解决知识图谱中有关肠胃关系的推理。</p><p>基于图神经网络的知识图谱推理技术，由于图神经网络的引入极大地扩展了知识库中试题和关系元素的表达，在并具有一定的推理能力，在表示学习和推理方面有着可预见的广泛的应用前景。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>知识图谱</category>
        <category>知识推理</category>
      </categories>
      <tags>
        <tag>研究进展</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MapReduce实现倒排索引</title>
    <url>/%E4%BD%BF%E7%94%A8MapReduce%E5%AE%9E%E7%8E%B0%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><p>任务描述<br>本关任务：编写 MapReduce 实现倒排索引。</p><p>相关知识<br>什么是MapReduce<br>MapReduce 是一种可用于数据处理的编程模型，我们现在设想一个场景，你接到一个任务，任务是：挖掘分析我国气象中心近年来的数据日志，该数据日志大小有 3T ，让你分析计算出每一年的最高气温，如果你现在只有一台计算机，如何处理呢？我想你应该会读取这些数据，并且将读取到的数据与目前的最大气温值进行比较。比较完所有的数据之后就可以得出最高气温了。不过以我们的经验都知道要处理这么多数据肯定是非常耗时的。</p><p>如果我现在给你三台机器，你会如何处理呢？看到下图你应该想到了：最好的处理方式是将这些数据切分成三块，然后分别计算处理这些数据（ Map ），处理完毕之后发送到一台机器上进行合并（ merge ），再计算合并之后的数据，归纳（ reduce ）并输出。</p><p>这就是一个比较完整的 MapReduce 的过程了。</p><p><img src="/使用MapReduce实现倒排索引/1.jpg" alt></p><p>如何使用MapReduce进行运算<br>我们通过一个示例，来体验 Map/Reduce 的使用。</p><p>我们从一个问题入手：目前我们想统计两个文本文件中，每个单词出现的次数。</p><p>首先我们在当前目录下创建两个文件：</p><p>创建file01输入内容：</p><p>Hello World Bye World<br>创建file02输入内容：</p><p>Hello Hadoop Goodbye Hadoop<br>将文件上传到 HDFS 的/usr/input/目录下：</p><p>不要忘了启动 DFS：</p><p>start-dfs.sh</p><p>然后创建文件夹并上传：</p><p><img src="/使用MapReduce实现倒排索引/2.jpg" alt></p><p>在右侧代码区域编写，文件WordCount.java，添加如下内容：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenizerMapper</span> </span></span><br><span class="line"><span class="class">       <span class="title">extends</span> <span class="title">Mapper</span>&lt;LongWritable, Text, Text, IntWritable&gt;&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> IntWritable one = <span class="keyword">new</span> IntWritable(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> Text <span class="keyword">word</span> = <span class="keyword">new</span> Text();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context</span></span></span><br><span class="line">                    ) throws IOException, InterruptedException &#123;</span><br><span class="line">      StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line">      <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">        <span class="keyword">word</span>.<span class="built_in">set</span>(itr.nextToken());</span><br><span class="line">        context.<span class="built_in">write</span>(<span class="keyword">word</span>, one);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntSumReducer</span> </span></span><br><span class="line"><span class="class">       <span class="title">extends</span> <span class="title">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span></span><br><span class="line">    <span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, </span></span></span><br><span class="line"><span class="function"><span class="params">                       Context context</span></span></span><br><span class="line">                       ) throws IOException, InterruptedException &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">        sum += val.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="built_in">set</span>(sum);</span><br><span class="line">      context.<span class="built_in">write</span>(key, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">    Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Job job = <span class="keyword">new</span> Job(conf, <span class="string">"word count"</span>);</span><br><span class="line">    job.setJarByClass(WordCount.class);</span><br><span class="line">    job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">    job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">    job.setReducerClass(IntSumReducer.class);</span><br><span class="line">    job.setOutputKeyClass(Text.class);</span><br><span class="line">    job.setOutputValueClass(IntWritable.class);</span><br><span class="line">    <span class="keyword">String</span> inputfile = <span class="string">"/usr/input"</span>;</span><br><span class="line">    <span class="keyword">String</span> outputFile = <span class="string">"/usr/output"</span>;</span><br><span class="line">    FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(inputfile));</span><br><span class="line">    FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(outputFile));</span><br><span class="line">    System.<span class="built_in">exit</span>(job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击评测，运行代码，可以看到/usr/output目录下已经生成了文件。</p><p><img src="/使用MapReduce实现倒排索引/3.jpg" alt></p><p>我们来查看part–r-00000文件的内容：</p><p><img src="/使用MapReduce实现倒排索引/4.jpg" alt></p><p>可以看到统计的数据已经生成在文件中了。</p><p>如果你还想要运行一次，那么你需要删除输出路径的文件夹和文件。</p><p>代码解释<br>示例中，Map/Reduce 程序总共分为三块即：Map，Reduce，Job，Map 负责处理输入文件的内容。</p><p>TokenizerMapper 的 map 方法，它通过 StringTokenizer 以空格为分隔符将一行切分为若干 tokens ，之后，输出 &lt; , 1&gt; 形式的键值对。</p><p>对于示例中的第一个输入， map 输出是：</p><p>&lt; Hello, 1&gt;</p><p>&lt; World, 1&gt;</p><p>&lt; Bye, 1&gt;</p><p>&lt; World, 1&gt;</p><p>第二个输入，map 输出是：</p><p>&lt; Hello, 1&gt;</p><p>&lt; Hadoop, 1&gt;</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 1&gt;</p><p>WordCount 还指定了一个 combiner 。因此，每次 map 运行之后，会对输出按照 key 进行排序，然后把输出传递给本地的 combiner （按照作业的配置与 Reducer 一样），进行本地聚合。</p><p><img src="/使用MapReduce实现倒排索引/5.jpg" alt></p><p>第一个 map 的输出是：</p><p>&lt; Bye, 1&gt;</p><p>&lt; Hello, 1&gt;</p><p>&lt; World, 2&gt;</p><p>第二个 map 的输出是：</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 2&gt;</p><p>&lt; Hello, 1&gt;</p><p>reduce 收到的数据是这样的：</p><p>&lt; Bye , [1]&gt;</p><p>&lt; GoodBye , [1]&gt;</p><p>&lt; Hadoop , [1,1]&gt;</p><p>&lt; Hello , [1,1]&gt;</p><p>&lt; World , [1,1]&gt;</p><p>Reducer 中的 reduce 方法 仅是将每个 key（本例中就是单词）出现的次数求和。</p><p>因此这个作业的输出就是：</p><p>&lt; Bye, 1&gt;</p><p>&lt; Goodbye, 1&gt;</p><p>&lt; Hadoop, 2&gt;</p><p>&lt; Hello, 2&gt;</p><p>&lt; World, 2&gt;</p><p>编程要求<br>根据提示，在右侧编辑器的中的 begin-end 间补全 InvertIndex_origin 类中的 map 和 reduce 函数。具体实现如下。</p><p>读取 hdfs 中/input目录下的如下三个文件，文件内容如下：</p><p>file1.txt内容：</p><p>mapreduce is simple</p><p>file2.txt内容：</p><p>mapreduce is powerful and simple</p><p>file3.txt内容：</p><p>mapreduce and mapreduce<br>使用 mapreduce 处理后把结果输出到 hdfs 的/out目录下，预期输出内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and file3.txt:1;file2.txt:1;</span><br><span class="line">is file2.txt:1;file1.txt:1;</span><br><span class="line">mapreduce file1.txt:1;file2.txt:1;file3.txt:2;</span><br><span class="line">powerful file2.txt:1;</span><br><span class="line">simple file2.txt:1;file1.txt:1;</span><br><span class="line">后台会自动把代码打包并执行以下命令提交：</span><br></pre></td></tr></table></figure><p>hadoop jar /root/invertedindex-1.0-SNAPSHOT.jar InvertIndex_origin /invertindex /out</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>分布式系统</category>
        <category>MapReduce</category>
      </categories>
      <tags>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络复习笔记</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="Ch1-1-体系结构"><a href="#Ch1-1-体系结构" class="headerlink" title="Ch1-1 体系结构"></a>Ch1-1 体系结构</h2><ol><li><p>网络的基本概念</p><p> 逻辑链路：<br> 在两点间通过通信协议的作用建立起来的数据联结通路<br> 通路(Path):<br> 从源点到宿点所经过的一串节点和链路的有序集。或端到端的通路<br> 协议（Protocol）<br> 多个进程为完成一个任务而共同遵守的动作序列规范<br> 三要素：语法、语义、规则(同步时序)<br> 网络云：<br> 区分通信子网交换交换结点（云内）和资源主机结点（云外）的分界<br>线，可表示任何网络（单、多、交换等）</p><p> 第一层：Backbone中转网：国家或世界级网络主干<br>美NFSnet/欧Ebone/中Chinanet/CERNET<br> 第二层：Transit地区性网：覆盖省、洲、国家,<br>提供到因特网的连接<br>因特网服务提供者ISP<br> 第三层：Stub组织性网：本地服务提供商；<br>是一个自治网络系统，有AS号<br>校园网、企业网、公司网、政府网<br>由外围网关接入地区性网络</p></li><li><p>性能参数<br> 性能测量的两个参数：带宽和延迟<br> 带宽(Bandwidth):Hz,KHz,MHz,GHz，bps<br> 信号带宽：构成一信号的各种不同频率成分所占据的频率范围。如人类声音<br>带宽为：3300Hz－300＝声音带宽3000Hz<br> 媒体带宽：通信媒体允许通过的信号频带范围<br> 比特率：某时段内网络上可能传输的比特数，或传输每比特数据所需的时间<br>宽度。习惯把“带宽”作为数字信道的数据率或比特率<br> 比特率越高，高频分量越多，频率范围越大，信号带宽越高。<br> 吞吐率(Throughput)：bps<br> 数字信号的发送速率，因此发送带宽也成为吞吐率<br> 由于各种影响 10M 带宽实际完成 2Mbps<br> 吞吐率：链路上实际每秒传输的比特数</p></li></ol><pre><code>延迟：
 Delay : 把一个报文从网络一端传输到另一端所需的时间one way，光传播
速度：
 3.0x108m/s ;光在真空内传播的速率
 2.8x108m/s ;电在Cable内传播的速率
 2.0x108m/s ;光在Fiber内传播的速率
 Round Trip Time (RTT):发收来回时间（2次时延）
 定义：延迟 = 处理＋排队+传输+传播，主要考虑后两个
 处理时延：检查包首部、决定导向何处；比特差错检测，高速Router一般在微秒
或更低数量级，接收完整的一个分组的时间＝包容量/链路速率
 排队时延：等待输出链路空闲，与当时流量和排队规则有关
 传输时延：数据量/带宽；微秒到毫秒级
 传播时延：距离/光速(光缆中1000km传播延迟约5ms) 广域网在毫秒级

 端到端吞吐率 = 实际传输
大小/传输时间
 实际传输时间 = RTT+ 传输
大小/信道带宽
 RTT：请求与回答时间
</code></pre><p> 问题：信道带宽1Gbps，一端到另一端传播时<br>延τ= 10ms，TCP发送窗口65535字节。问可<br>能达到的最大吞吐率T ？信道利用率ρ？<br> 解析：T= size/(2τ+size/BW)<br> = size<em>BW/(2τ</em>BW+size) bps<br> = 65535<em>8</em>109/(20<em>109</em>10-3s+65535<em>8)bps<br> = 524280</em>103/(20 *106 +524280)Mbps<br> = 25.5 Mbps，ρ=25.5M/1000M=2.55%</p><p> 带宽和延迟的组合可描述链路或信道的特征，其相对重<br>要性取决于具体的应用<br> 有些应用延迟支配带宽（SSH），如端客户发送1字节到服务器<br>并依次收到1字节就是延迟重要，如果响应中没有大量的计算，<br>由于跨洲信道要100ms的RTT，同一房间内仅1ms RTT，所以不<br>同延迟导致完全不同效果<br> 数字图书馆来说是带宽支配延迟。设带宽10Mbps,则需<br>20s(2.5MByte的一个图片)，信道是1ms或者100ms延迟不重要，<br>20.001s和20.1s之差可略</p><p>延迟带宽积（以太网相关参数）<br> 一对进程通道间的延迟(总体延迟)带宽积：信道管道的体积=链路上所<br>容纳的比特数<br> 一个信道延迟=50ms ,带宽45Mbps, 则能容纳=50ms<em> 45Mbps=50</em>10-<br>3 sec*45Mbits/sec =2.25Mbits<br> 等价于信道上同时可以存在281K个Byte信号（2.25M/8）</p><ol start="3"><li>习题<br> 假设在地球和月球间建立一点对点100MPS的连接，地<br>月距离为385,000KM，数据传播速度为光速（3<em>108<br>M/S）<br> A．计算最小的RTT<br> B．use the RTT as the delay , calculate the delay</em>bandwidth<br>product for the link<br> C. 在B中计算的delay*bandwidth有何意义？<br> D．在月球照的照片，并以数字格式存在磁盘上。如果地球上的<br>控制中心想下载25M的最新的图形，那么从发出数据到传输完成<br>所要的最小时间是多少？</li></ol><h2 id="Ch1-2-直连网络技术"><a href="#Ch1-2-直连网络技术" class="headerlink" title="Ch1-2 直连网络技术"></a>Ch1-2 直连网络技术</h2><h2 id="Ch1-3-报文交换"><a href="#Ch1-3-报文交换" class="headerlink" title="Ch1-3 报文交换"></a>Ch1-3 报文交换</h2><h2 id="Ch1-4-TCP-IP网络技术"><a href="#Ch1-4-TCP-IP网络技术" class="headerlink" title="Ch1-4 TCP/IP网络技术"></a>Ch1-4 TCP/IP网络技术</h2><h1 id="第二章-IPv6"><a href="#第二章-IPv6" class="headerlink" title="第二章 IPv6"></a>第二章 IPv6</h1><ol><li><p>IPv4和IPv6差异？</p></li><li><p>IPv6地址分类和特点</p></li><li><p>IPv6地址自动分配两种方式, stateless过程</p></li><li><p>IPv6邻居发现协议中：地址解析和DAD</p></li><li><p>IPSec基本概念</p></li></ol><h1 id="第三章-拥塞控制"><a href="#第三章-拥塞控制" class="headerlink" title="第三章 拥塞控制"></a>第三章 拥塞控制</h1><ol><li>拥塞控制基本概念</li></ol><ul><li>Power=吞吐率/延迟</li><li>公平的定义</li></ul><ol start="2"><li>排队算法： FIFO, fQ, wfq</li><li>流量整形：漏桶、令牌桶算法（PPT习题）</li><li>TCP拥塞控制机制（慢启动、拥塞避免、快乘船、快速回复）</li><li>拥塞避免：ECN，RED，TCP Veges算法</li></ol><h1 id="第四章-P2P"><a href="#第四章-P2P" class="headerlink" title="第四章 P2P"></a>第四章 P2P</h1><ol><li>三代P2P网络之间的定义和差异是什么？</li></ol><ul><li>第一代：混合式P2P网络（第一代）</li></ul><p> 拓扑结构：服务器仍然是网络的核心<br> 底层协议：全部使用TCP，限制了链接的Peer数量<br> 查询与路由简单高效：<br> Napster和BT的用户访问服务器；服务器返回文件索引或种子文件<br>；用户再直接同另一Peer连接<br> 故路由跳数为O(1)，即常数跳<br> 容错、自适应和匿名性<br> 服务器单点失效率高<br> 自组织和自适应主要依靠服务器<br> 服务器的存在使匿名性实际不可能<br> 用户接入无安全认证机制</p><ol><li>Napster和Gnutella的原理</li></ol><ul><li>第二代：非结构化P2P网络（第二代）</li></ul><ul><li>第三代：结构化P2P网络(第三代)</li></ul><ol><li>掌握Chord协议</li></ol><ol start="2"><li>理解Kademlia的原理，例如Kademlia协议是如何找到资源的</li></ol><ol start="3"><li>掌握Bitcoin原理（论文）以及区块链概念</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络lab03-TCP Congestion性能测试分析</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab03-TCP%20Congestion%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="GNS3下的TCP-Congestion测试"><a href="#GNS3下的TCP-Congestion测试" class="headerlink" title="GNS3下的TCP Congestion测试"></a>GNS3下的TCP Congestion测试</h1><p>在GNS3中创建一个新项目，用三台SEED虚拟机按照如图方式连接起来(参考实验1，三台虚拟机分别为SEEDClient，SEED-Router，SEED-Server)，配置IP地址，让他们可以互相通信 如果物理机器性能一般，请用slitaz代替<br>SEED，不过必须自己安装一些软件，安装软件参考： slitaz文档：<a href="http://doc.slitaz.org" target="_blank" rel="noopener">http://doc.slitaz.org</a></p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/1.jpg" alt><br>注意的地方： 在GNS3中先给每台虚拟机配置三个网卡：</p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/2.jpg" alt></p><p>eth0网卡不要在GNS3中使用，而是用VirtualBox如下配置：</p><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/3.jpg" alt><br>可以发现虚拟机可以同时访问外部网络<br>在SEED-Client和SEED-Server上安装iperf软件</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install iperf</span><br></pre></td></tr></table></figure><h1 id="Linux下的TCP拥塞控制算法"><a href="#Linux下的TCP拥塞控制算法" class="headerlink" title="Linux下的TCP拥塞控制算法"></a>Linux下的TCP拥塞控制算法</h1><ul><li>列出所有直接编译到内核的拥塞控制算法：<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">cubic reno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/4.jpg" alt></p><ul><li><p>修改当前的拥塞控制算法：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_congestion_control=cubic</span><br></pre></td></tr></table></figure></li><li><p>增加新的拥塞控制算法： linux支持的拥塞控制算法：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>怎么加载这些内核模块，来运行新的拥塞控制算法：<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#echo "westwood" &gt; /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line"><span class="comment">#cat /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line">westwood</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#echo "westwood" &gt; /proc/sys/net/ipv4/tcp_congestion_control</span></span><br><span class="line"><span class="comment">#lsmod | grep westwood</span></span><br><span class="line">tcp_westwood 12675 0</span><br></pre></td></tr></table></figure><p></p><p>各种拥塞控制算法简介：</p><ul><li>High Speed TCP<br>The algorithm is described in RFC 3649. The main use is for connections with large<br>bandwidth and large RTT (such as Gbit/s and 100 ms RTT).</li><li>H-TCP<br>H-TCP was proposed by the Hamilton Institute for transmissions that recover more<br>quickly after a congestion event. It is also designed for links with high bandwidth and<br>RTT.</li><li>Scalable TCP<br>This is another algorithm for WAN links with high bandwidth and RTT. One of its design<br>goals is a quick recovery of the window size after a congestion event. It achieves this<br>goal by resetting the window to a higher value than standard TCP.<br>3.从SEED-Client虚拟机发包测试<br>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic<br>先在SEED-Server端运行下面的命令，让iperf的服务器端运行守护在5001端口：<br>在SEED-Client端运行下面的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参<br>数变化：</li><li>TCP BIC<br>BIC is the abbreviation for Binary Increase Congestion control. BIC uses a unique<br>window growth function. In case of packet loss, the window is reduced by a<br>multiplicative factor. The window size just before and after the reduction is then used<br>as parameters for a binary search for the new window size. BIC was used as standard<br>algorithm in the Linux kernel.</li><li>TCP CUBIC<br>CUBIC is a less aggressive variant of BIC (meaning, it doesn’t steal as much throughput<br>from competing TCP flows as does BIC).</li><li>TCP Hybla<br>TCP Hybla was proposed in order to transmit data efficiently over satellite links and<br>“defend” the transmission against TCP flows from other origins.</li><li>TCP Low Priority<br>This is an approach to develop an algorithm that uses excess bandwidth for TCP flows.<br>It can be used for low priority data transfers without “disturbing” other TCP<br>transmissions (which probably don’t use TCP Low Priority).</li><li>TCP Tahoe/Reno<br>These are the classical models used for congestion control. They exhibit the typical<br>slow start of transmissions. The throughput increases gradually until it stays stable.<br>It is decreased as soon as the transfer encounters congestion, then the rate rises<br>again slowly. The window is increased by adding fixed values. TCP Reno uses a<br>multiplicative decrease algorithm for the reduction of window size. TCP Reno is the<br>most widely deployed algorithm.</li><li>TCP Vegas<br>TCP Vegas introduces the measurement of RTT for evaluating the link quality. It uses<br>additive increases and additive decreases for the congestion window.</li><li>TCP Veno<br>This variant is optimised for wireless networks, since it was designed to handle random<br>packet loss better. It tries to keep track of the transfer, and guesses if the quality<br>decreases due to congestion or random packet errors.</li><li>TCP Westwood+<br>Westwood+ addresses both large bandwidth/RTT values and random packet loss together<br>with dynamically changing network loads. It analyses the state of the transfer by<br>looking at the acknowledgement packets. Westwood+ is a modification of the TCP Reno<br>algorithm.</li></ul><h1 id="从SEED-Client虚拟机发包测试"><a href="#从SEED-Client虚拟机发包测试" class="headerlink" title="从SEED-Client虚拟机发包测试"></a>从SEED-Client虚拟机发包测试</h1><p>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic<br>先在SEED-Server端运行下面的命令，让iperf的服务器端运行守护在5001端口：<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iperf -s</span></span><br></pre></td></tr></table></figure><p></p><p>在SEED-Client端运行下面的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参<br>数变化：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># modprobe tcp_probe port=5001 //对端口为5001（源或目的）的tcp连接进行监控</span></span><br><span class="line"><span class="comment"># cat /proc/net/tcpprobe &gt; data.txt &amp; // tcpprobe捕捉的信息是持续性的，可以放到后台读</span></span><br><span class="line"><span class="comment"># pid=$! // 保存上一个读命令的pid，用于结束读tcpprobe接口</span></span><br><span class="line"><span class="comment"># iperf -c otherhost // 使用iperf建立一个TCP流</span></span><br><span class="line"><span class="comment"># kill $pid</span></span><br></pre></td></tr></table></figure><p>在文件data.txt中保存了tcp的拥塞窗口变化情况，可以通过虚拟机共享目录或者网络导出，作为实验数据，iperf运<br>行结果：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/5.jpg" alt></p><p>记录在data.out中的数据大致是这个样子：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">11.172120204 193.168.0.2:8089 193.168.0.25:54320 32 0x842ccad 0x84299c5 10 168 14608</span><br><span class="line">143</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">每行的各列分别为：</span><br></pre></td></tr></table></figure><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">timestamp //时间戳</span><br><span class="line">saddr:port // 源IP及端口，我的数据是在发送端捕捉的，所以port是固定的8089</span><br><span class="line">daddr:port // 目的IP及端口</span><br><span class="line">skb-&gt;len // 收到的数据包skb大小，收到的都是ACK包，所以len都比较小。</span><br><span class="line">snd_nxt // 下一个待发送数据的序列号</span><br><span class="line">snd_una // 待确认数据的序列号</span><br><span class="line">snd_cwnd // 拥塞窗口大小</span><br><span class="line">ssthresh // 慢启动阈值</span><br><span class="line">snd_wnd // 接收窗口大小</span><br><span class="line">srtt // smoothed RTT</span><br></pre></td></tr></table></figure><p>实际的例子，看到拥塞窗口线性增加：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/6.jpg" alt><br>看到拥塞窗口线性减少，ssthresh折半回退（跟特定的拥塞控制算法相关例如Vegas）：<br><img src="/现代计算机网络lab03-TCP Congestion性能测试分析/7.jpg" alt></p><h1 id="增加延迟"><a href="#增加延迟" class="headerlink" title="增加延迟"></a>增加延迟</h1><p>可以在SEED-Router这台虚拟机连接SEED-Server网卡上增加延迟和丢包来改变网络环境，利用的是Linux中的<br>iproute 工具，以及内核中的Network Simulator特性：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tc qdisc change dev eth0 root netem loss 2.5%</span></span><br><span class="line">设置丢包</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem delay 30ms 10ms</span></span><br><span class="line">设置延迟</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem duplicate 1%</span></span><br><span class="line">该命令将 eth0 网卡的传输设置为随机产生 1% 的重复数据包</span><br><span class="line"><span class="comment"># tc qdisc add dev eth0 root netem corrupt 0.2%</span></span><br><span class="line">该命令将 eth0 网卡的传输设置为随机产生 0.2% 的损坏的数据包</span><br><span class="line">删除网卡上面的相关配置，将之前命令中的 add 改为 del 即可删除配置</span><br></pre></td></tr></table></figure><p>qdisc表示在网卡上的排队策略，可以通过ifconfig命令查看：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">root@dl:~<span class="comment"># ip link show</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,PROMISC,UP&gt; mtu 1500 qdisc pfifo_fast qlen 100</span><br><span class="line">link/ether 52:54:00:de:bf:19 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>qdisc支持的排队策略包括：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">FIFO - simple FIFO (packet (p-FIFO) or byte (b-FIFO) )</span><br><span class="line">PRIO - n-band strict priority scheduler</span><br><span class="line">TBF - token bucket filter</span><br><span class="line">CBQ - class based queue</span><br><span class="line">CSZ - Clark-Scott-Zhang</span><br><span class="line">SFQ - stochastic fair queue</span><br><span class="line">RED - random early detection</span><br><span class="line">GRED - generalized random early detection</span><br><span class="line">TEQL - traffic equalizer</span><br><span class="line">ATM - asynchronous transfer mode</span><br><span class="line">DSMARK - DSCP (Diff-Serv Code Point)marker/remarker</span><br></pre></td></tr></table></figure><p>如果条件所限，还可以利用Linux防火墙来进行丢包，在Router上运行以下命令，实现0.5%的丢包<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s 121.14.48.1 -m statistic --mode random --probability 0.005 -j DROP</span><br></pre></td></tr></table></figure><p></p><h1 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h1><p>根据以上网络配置和TCP性能测试方案，改变Router的延迟和丢包来测试TCP拥塞控制算法的性能：</p><ol><li>选择Linux内核支持的三种拥塞控制算法</li><li>针对每种拥塞控制算法进行性能测试，在性能测试中改变SEED-Router的丢包率和延迟，得到不同的性能测试<br>结果，记录测试结果</li><li>如果性能不行，换成slitaz虚拟机测试（需要编译内核）</li><li>对实验结果进行分析和比较</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网路</category>
        <category>性能分析</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络lab02-实验报告</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab02-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h2 id="环境（详细说明实验运行的操作系统，网络平台，机器的配置）"><a href="#环境（详细说明实验运行的操作系统，网络平台，机器的配置）" class="headerlink" title="环境（详细说明实验运行的操作系统，网络平台，机器的配置）"></a>环境（详细说明实验运行的操作系统，网络平台，机器的配置）</h2><p>操作系统：Windows 10 64bit Pro 1909</p><p>处理器：Intel® Xeon® CPU E3-1505M v6 \@ 3.00GHz</p><p>内存：DDR4 2666MHZ 24GB ECC</p><p>网络平台：GNS3 2.2.3</p><p>虚拟机软件：Oracle VM VirtualBox 6.0.14</p><p>虚拟机：Ubuntu 16.04 32bit</p><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>学会利用GNS3网络平台搭建网络拓扑结构并配置主机的IP和路由。</p></li><li><p>掌握SYN flood攻击的基本原理，利用虚拟机实现SYN flood攻击。</p></li><li><p>掌握SYN cookie的原理，并通过实验证明SYN cookie机制的有效性。</p></li><li><p>了解Linux内核TCP SYN Cookie机制，掌握查看与修改方法。</p></li></ol><a id="more"></a><h2 id="实验步骤（包括主要流程和说明）"><a href="#实验步骤（包括主要流程和说明）" class="headerlink" title="实验步骤（包括主要流程和说明）"></a>实验步骤（包括主要流程和说明）</h2><h3 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h3><p>（1）从<a href="https://seedsecuritylabs.org/" target="_blank" rel="noopener">https://seedsecuritylabs.org/</a>下载SEEDUbuntu的“<a href="http://www.cis.syr.edu/~wedu/SEEDUbuntu-16.04-32bit.zip" target="_blank" rel="noopener">SEEDUbuntu-16.04-32bit.zip</a>”虚拟机文件。</p><p>（2）在VirtualBox中新建虚拟机，名称为SEEDUbuntu，类型为Linux，版本选择Ubuntu(32-bit)，其他使用默认配置，虚拟硬盘使用下载下来的“SEEDUbuntu-16.04-32bit.vmdk”,<br>点击创建进行虚拟机的创建，如下图所示。</p><p><img src="/现代计算机网络lab02-实验报告/3747dc0504c2cd3d7731c9b8f9a1f29e.png" alt="Create Virtual Machine Name and operating system Please cloøse a name and destination fold« for the new virtual machine and the tyJ\* of 01\*ratinq system you intend to instan on it. The name you choose Will be to id81tify this Name: Machine Folder : Type: Versm: SEEDIJbtntu C: VMS Limn Ubuntu (32 -bit) Expat Mode "></p><p><img src="/现代计算机网络lab02-实验报告/6226f40853c94844d4ce61524341ba5d.png" alt="Create Virtual Machine Memory size the amount of (MM) in megabytß to al&amp;ated to recornrrpnded mervnry size is 1024 MB. 16384 MB "></p><p><img src="/现代计算机网络lab02-实验报告/d152f48948906279b9dbf0c36ffc37cb.png" alt="Create Virtual Machine Hard disk If wish pu can add a virtual hard disk to machine. You can either create a new hard disk file select from the list from another location using the fokkr ion. If a more complex storage set-up pu can skip this step and make the changes to the machine is created. recornrrpnded size Of the hard disk 10.00 GB. C) Do not add a virtual hard disk C) Create a virtual hard disk now \@ an existing virtual hard disk file SEEDUbuntwt&amp;04-32bitvrndk (Normal, 20.00 GB) "></p><p>图1：新建SEED虚拟机</p><p>（3）采用完全复制的方式复制上一步创建的虚拟机，并将其命名为SEEDUbuntuTarget，复制完成后结果如下。</p><p><img src="/现代计算机网络lab02-实验报告/d6cba6ded0a79a75cd4b1b240ed42df3.png" alt="Clone Virtual Machine New machine name and path Please ctu:nse a name and optbnally a folder for the virtual The machine a done of the machine SEEDUbuntu Name: VMS MAC Adüess Pdicy: Include only NAT network adapter MAC addresses Options: Keg) Disk Ke\&lt;) LNJIDS Expert "></p><p><img src="/现代计算机网络lab02-实验报告/243afc927eaad303f0745fee1a109cb1.png" alt="Clone Virtual Machine Clone type Please clA)se the type of you wish to create. If you choose Full done, an exact copy (induding all virtual hard disk files) of the original virtual machine will be created. If you choose LinkcKi clone, a new machine will but the virtual hard disk files will be tied to the virtual hard disk files of original machine and you will not be able to move the new virtual machine to a different computer without the original as wen \_ If create a Linked done then a new snapshot will be creat«l the virtual machime as part of the ckming process. \@ Full C) Link«l done "></p><p><img src="/现代计算机网络lab02-实验报告/3363c5420a3d7b2e16abf92e46555e0f.png" alt="Oracle VM VirtualBox Manager tile Machine Help Tools New General powered Off System Power«f Off powered Off SEEDUbuntu SEEDtJbuntuTarget Power«t Off Discard Start preview Settings File Ltxation: IJbLmtu (32 -bit) C: W oha n\\VEtualBox VMs\\SEEDUbuntu SEEDUbuntu Base Manor/ : Oder: Acceleration: Memory 1024 MB Floppy, (Xtical, Hard Disk VT-x/AMD-V, Nested Paging, PAE/ NX, KVM paravirtualization Graphics Controller : Remote Desktop Sever: Recording: Controller: IDE IDE Master: controller: SATA SATA port O: Audio Host Driver: Wincbws Di 16 MB Disabled [Optical (Yive] Empty SEEDtnmJntu-16.04-32bt.vmdk (My-mal, GB) "></p><p>图2：复制虚拟机副本SEEDUbuntuTarget</p><p><img src="/现代计算机网络lab02-实验报告/1cafaae1dd97571a69a44af854d02966.png" alt></p><p><img src="/现代计算机网络lab02-实验报告/5cb83e6c02818ec3ca1d54e07fda6b00.png" alt></p><p>（4）打开GNS3，新建一个名为lab02的工程。通过Edit->Preferences->VirtualBox<br>VMs，将上一步创建的两个虚拟机新建为VM<br>templates，并通过Edit按钮修改网卡（网卡驱动需设置为通用驱动）数量为3，勾选“Allow<br>GNS3 to use any configured VirtualBox<br>adapter”选框，这样就创建好了两个虚拟机模板。</p><p><img src="/现代计算机网络lab02-实验报告/0a4e6fcdf7537880010b0460c3964d57.png" alt="• Preferences General Server GNS3 VM Packet capture • Built-in Ethernet hubs Ethernet switches Cloud nodes • vpcs vpcs nodes Dynami ps IOS routers • IOS on UNIX IOU Devices • QEMU Qemu VMS • VirtualBox VirtualBox VMS • VMware VMware VMS • Docker Docker containers VirtualBox VM ubuntul u buntu2 u buntu3 tem lates SEEDUbuntu SEEDUbuntuTarget General Template name: Template ID VirtualBox name: RAM: Server: Headless mode enabled: On close: Linked base VM: Console type: Auto start console: Adapters: Name format: Use any adapter: Type: SEEDUbuntu 8b1d7099-82d4-48f8-a80e-83S2b4f98aaO SEEDUbuntu 1024 LAPTOP-BH6AKUC False power_off False none False Ethernet(O} False Intel PRO/IOOO MT Desktop (82540EM) "></p><p>图3：新建虚拟机模板</p><p>（5）将两台虚拟机连成如下拓扑结构。</p><p><img src="/现代计算机网络lab02-实验报告/28f240d0e15f231329efd64b624f9aa7.png" alt="• lab02 GNS3 Edit View Control Node Annotate Security filter Jools Help ATM s.. Cloud EttH.. Console GNS3 managerrænt console. SEEDUbuntu-1 SEEDUbuntuTarget-1 Topology Summary NO de B SEEDUbuntu-1 SEEDClbuntuTarget-I Servers Summary LAPTOP-BH6AKL1.„ Running GNS3 version 2_2.3 on Windows (64-bit) with Python 3.68 Qt 5.12.1 and PyQt 5.12. copyright (c) 2006-2019 GNS3 Technologies. HAP •\&gt; GNS3 to detect ca-nrnon issues. "></p><p>图4：网络和拓扑结构</p><p>（6）分别启动两台虚拟机（注意要在GNS3中启动，在VirtualBox中启动的无法连接上），重设两台虚拟机的网卡名称，并设置IP地址和路由。详细步骤如下：</p><ol><li>重设虚拟机网卡名称</li></ol><p>sudo vim /etc/default/grub</p><p>找到GRUB_CMDLINE_LINUX=””</p><p>改为GRUB_CMDLINE_LINUX=”net.ifnames=0 biosdevname=0”</p><p>之后在terminal中键入sudo grub-mkconfig -o /boot/grub/grub.cfg</p><p>重启后，网卡名称变成了eth0。</p><p><img src="/现代计算机网络lab02-实验报告/73e4a9c5ca55a9bd10477f16ffa4db5a.png" alt="SEEDUbuntu [Running] - Oracle VM Virtua130x Help \# /boot/grub/grub.cfg. \# For full documentation of the options in this file, \# info -f grub -n &#39; Simple configuration&#39; GRUB DEFAULT-O HIDDEN TIMEOUT=Ø HIDDEN-TIMEOUT QUIET-true GRUB-TIMEOUt=10 see: GRUB GRUB GRUB GRUB GRUB DISTRIBUTOR=&#39;1Sb retease -i -s /dev/null Il echo Debian• CMDLINE LINUX DEFAULT-&quot;quyet splash&quot; -CMDLINÜLINUXZ net .ifnames=6 biosdevname=0&quot; \# Uncomment to enable BadRAM filtering, modify to suit your needs \# This works with Linux (no patch requi red) and with any kernel that obtains \# the memory map information from GRUB (GNU Mach, kernel of FreeBSD \#GRUB ,oxtetetete, OX89abCdef ,exetetetef&quot; \# Uncomment to disable graphical terminal (grub-pc only) \#GRUB TERMINAL=consote \# The resolution used on graphical terminal \# note that you can use only modes which your graphic card supports via VBE INSERT Top u (S L.&#39;J Right Ctrl "></p><p><img src="/现代计算机网络lab02-实验报告/978eed1663153007326ca87cff132277.png" alt="SEEDUbuntu  "></p><p><img src="/现代计算机网络lab02-实验报告/0599d8b0d46dee59167e21fe2fbf330d.jpg" alt="SEEDUbuntu "></p><p>图5：修改网卡名称</p><ol><li>设置ip地址以及默认路由：</li></ol><p>将攻击机的eth0 ipv4更改为192.168.1.1 ip address add 192.168.1.1/24 dev eth0</p><p>设置路由ip route add 192.168.1.0/24 dev eth0</p><p>设置默认路由ip route add default via 192.168.1.1</p><p>将靶机的eth0 ipv4更改为192.168.1.2 ip address add 192.168.1.2/24 dev eth0</p><p>并设置默认路由ip route add 192.168.1.0/24 dev eth0</p><p>设置默认路由ip route add default via 192.168.1.2</p><p><img src="/现代计算机网络lab02-实验报告/ed5131869a8384b25355ede9ef15af2c.jpg" alt="SEEDUbuntu [Running] &#39;bin/bash - Oracle VM VirtualBox sudo ip address add 192.168.1.1/24 dev etho Isudol password for seed: ifconfig etho ethl eth2 10 Link encap: Ethernet HWaddr inet addr: 192.168.1.1 Bcast:o.o.e.o mask:255.255.255.O inet6 addr: fe8e: Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1509 Metric: 1 RX packets:87 errors:e dropped:O overruns:e frame:O TX packets: 164 errors:O dropped:ß overruns:O carrier:e collisions:O txqueuelen: RX bytes:18987 (18.9 KB) TX bytes:23859 (23.8 KB) Link encap: Ethernet HWaddr UP BROADCAST MULTICAST tm: 1500 Metric:l RX packets:ß errors:ß dropped:e overruns:ß TX packets:O errors:ß dropped:e Overruns:e collisions:O txqueuelen:1000 RX bytes:e (e.o B) TX (0.0 B) Link encap: Ethernet HWaddr 08:00:27:52:b6:1f UP BROADCAST UTICAST tm: 1500 yetric:l frame: O carrier: 0 f rame:O carrier: 9 RX packets:ß errors:ß dropped:e overruns:e TX packets:O errors:O dropped:e overruns:O collisions:ß txqueuelen: RX bytes:e (e.o B) TX bytes:e (e.o B) Link encap: Local Loopback Right Ctrl "></p><p><img src="/现代计算机网络lab02-实验报告/589a1990a185630720d178d1dfb673f2.jpg" alt="SEEDIJbuntuTarget "></p><p><img src="/现代计算机网络lab02-实验报告/1954a7f615ba7f89f95dc1329c0c9051.jpg" alt="SEEDUbuntu [Running] Network Connections - Oracle VM VirtualBox Editing etho Connection name: etho General Ethernet DCB IPV4Settings IPv6 Method: Manual A dd re sses Address DNS servers: Search domains: DHCP dient ID: Netmask Gateway n Require IPv4 addressing for this connection to complete cancel Routes. Right Ctrl "></p><p><img src="/现代计算机网络lab02-实验报告/42816963748134669460c07ab20c1313.jpg" alt="SEEDUbuntu [Running] Network Connections - Oracle VM VirtualBox Editing etho Connection name: etho General Ethernet DCB IPV4Settings IPv6 Method: Manual A dd re sses Address DNS servers: Search domains: DHCP dient ID: Netmask Gateway n Require IPv4 addressing for this connection to complete cancel Routes. Right Ctrl "></p><p>图6：设置IP地址和默认路由</p><p>（7）检查SEEDUbuntu和SEEDUbuntuTarget能否互相ping通。</p><p><img src="/现代计算机网络lab02-实验报告/d897e05d357455175e0e28a2e5d7e5f3.jpg" alt="SEEDUbuntu [Running] - Oracle VM Virtualgox Hnln /bin/buh 192. 168 icmp¯seq=2 192. 168 .1.2: 192. 168 .1.2: 192. 168 192. 168 192. 168 .1.2: 192. 192. 168 192. 168 .1.2: 192. 168 192. 168 .1.2: 192. 168 .1.2: 192. 168 192. 168 .1.2: 192. 168 .1.2: 192.168. 1.2: 192. 168 .1.2: 192. 168 .1.2: 192. 168 .1.2: 192. 168 .1.2: ping 192.168.1 2 PING 192.168.1.2 (192.168.1.2) 56(84) 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 64 bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes from f rom from from f rom from from from from from from from from from from from from from from from from 1 cmp 1 cmp .1.2: 1 cmp .1.2: 1 cmp rcmp 1 cmp lcmp icmp 192.168.1.2: icmp rcmp seq=l seW seq=7 seq=lß \_seq-12 seq=13 \_seq-15 seq=16 seq=19 seq=21 10:21 AM bytes of data. ttl=64 time—I. 39 ms ttl=64 time—O .930 ms tt1=64 time-e. 815 ms ttl=64 time—e .938 ms ttl=64 time=O.697 ms ttl=64 time-e. 706 ms ttl=64 time—e. 734 ms ttl=64 time-O. 992 ms ttl%64 time-e. 771 ms ttl=64 time—O .95ß ms tt1=64 ume=o.828 ms ttl=64 time—O. 978 ms ttl=64 time—O .881 ms tt1=64 urne=o.770 ms ttl=64 time-I .08 ms ttl=64 time—I. 40 ms tt1=64 urne=o.851 ms ttl=64 time—a. 888 ms ttl=64 time—O .894 ms tt1=64 urne=o.964 ms ttl=64 time—O. 999 ms U Right cm "></p><p><img src="/现代计算机网络lab02-实验报告/376f02a05c377b0106a078d43516504c.jpg" alt="SEEDUbuntuTarget  "></p><p>图7：检查能否ping通</p><p>（8）在SEEDUbuntuTarget上启动telnet服务。</p><p><img src="/现代计算机网络lab02-实验报告/407ee0248ec4abd4d687fd779bae3798.jpg" alt=" "></p><p>图8：启动telnet服务并查看服务状态</p><p>（9）SEEDUbuntu连接SEEDUbuntuTarget，在SEEDUbuntuTarget上用wireshark观察建立连接的过程。</p><p><img src="/现代计算机网络lab02-实验报告/53244ec3bda480b7be3d4bd0943a24bc.png" alt></p><p>图9：telnet建立连接</p><p><img src="/现代计算机网络lab02-实验报告/e49906a977102bcad03ebdee75692acb.png" alt="计算机生成了可选文字: SEEDUbuntuTarget[Running]_OracleVMVirtualBox FileMachineViewInputDevicesHelp Capturing行ometho 龔Applyadisplay鬥e「…\&lt;C辱\&gt; 23：\@5：31．4998821“ 23：\@5：31．5\@33391“ 23：\@5：31．5\@4121上 23：\@5：31．69\@\@82上 23：\@5：31．69\@21\@5“ 23：\@5：31．69\@92\@9“ 23：\@5：31．9\@645\@艺 23：\@5：31．9\@65651“ 23：\@5：31．9\@7234上 一12一\@6 23：\@5：32。196\@944一 每加峨 0 囗 11：05PM =》·Expression.. 过 No. Time 12\@19一12一\@6 22\@19一12一\@6 32\@19一12一\@6 42\@19一12一\@6 52\@19一12一96 62\@19一12一96 72\@19一12一96 82\@19一12一96 92\@19一12一\@6 Files Destination 192．168．12 192．168．1．1 192．168．1．2 192．168．1．2 192．168．1．1 192．168．1．2 192．168．1．2 192．168．1．1 192．168．1．2 192．168．1．2 ProtocolLength 《n 192．168．1．1 192．168．1．2 192．168．1．1 192．168．1．1 192．168．12 192．168．1．1 192．168．1．1 192．168．12 192．168．1．1 192．168．1．1 TELNET TELNET TCP TELNET TELNET TCP TELNET TELNET TCP TELNET 67Telnet 7\@Telnet 6646532 67Telnet 7\@Telnet 6646532 67Telnet 67Telnet 6646532 67Telnet Dat Dat 23 Dat Dat 23 Dat Dat 23 Dat Frame1：67 Ethernet11, bytes Src: WIre 〔536bits),67bytescaptured〔536 bits) 0n\@ PcsCompu_a2:ee:d4〔\@8：\@\@：27：a2：ee：d4),Dst: PcsCompu_a2：ee：d4〔\@8：9\@：27：a2：ee：d4〕 InternetProtocolVersion4，Src:192．168．1．1 TranSmlSSlOn \&gt;Telnet ControlProtocol,Src Port: 46532， Dst:192．168．1．2 DstPort:23，Seq:3566461939，Ack:283416\@292，Len: 1 \@1 27 35 \@2 f5 8d fb b5 f5 7f 4\@ c4 7\@ 17 4\@ d4 \@1 \@6 93 \@1 bc e3 5e f3 \@a c\@ a8 a8 ed \@1 da 64 \@1 4a dl c\@ a8 18 ethO:\&lt;livecaptureinproa「eSS\&gt; packets:74。Dis ed:74100·0％profile:Default 000过回姗回囗 RightCtrl"></p><p>图10：wireshark观察连接过程</p><p>（10）在SEEDUbuntuTarget上执行“netstat -n<br>–tcp”查看TCP连接状态，连接建立成功则已经配置好了SYN<br>Flooding攻击实验的实验环境，下面可以进行实验。</p><p><img src="/现代计算机网络lab02-实验报告/581a673fa6c0069acb44719080974784.jpg" alt="root\@VM: /pmc/sys/net/ipv4 root "></p><p>图11：查看TCP连接状态</p><h3 id="SYN-Flooding-Attack实验"><a href="#SYN-Flooding-Attack实验" class="headerlink" title="SYN Flooding Attack实验"></a>SYN Flooding Attack实验</h3><p>(1)首先通过“cat /proc/sys/net/ipv4/tcp_syncookies”和“cat<br>/proc/sys/net/tcp_syn_max_backlog”命令查看当前SEEDUbuntuTarget的tcp_syncookies和tcp_max_syn_backlog的状态。</p><p>(2)设置SEEDUbuntuTarget的“tcp_syncookies=0”和“tcp_max_syn_backlog=10”，即关闭tcp<br>syn cookies参数和设置保存在队列中的最大连接数为10。</p><p><img src="/现代计算机网络lab02-实验报告/176dc09f33781ac992d61cfe530adb40.jpg" alt="SEEDUbuntuTarget [Running]  "></p><p><img src="/现代计算机网络lab02-实验报告/8810ae8b8d84b76e84dd7cf8798d9bf6.jpg" alt="SEEDUbuntuTarget [Running] "></p><p>图12：配置内核参数</p><p>（3）在SEEDUbuntu上使用命令“netwox 76 -i 192.168.1.2 –dst-port<br>23”，对SEEDUbuntuTarget进行SYN<br>Flood攻击，同时观察SEEDUbuntuTarget的连接状态和wireshark获取的流量包。</p><p>可以看出SEEDUbuntuTarget收到了大量的建立TCP连接的包，并向多个IP地址发出了响应包，这些IP地址并非SEEDUbuntu，都是虚假的。</p><p><img src="/现代计算机网络lab02-实验报告/b65f538f6ebb2e16d4b780a2c74fcb60.png" alt="SEEDUbuntuTarget [Running] "></p><p>图13：wireshark捕获的包</p><p>观察SEEDUbuntuTarget的连接状态，可以看到当前队列已满共有10个连接，且都为SYN_RECV状态。</p><p><img src="/现代计算机网络lab02-实验报告/8f7b655201461f1c602a74106e2d8771.jpg" alt="SEEDUbuntuTarget [Running] "></p><p>图14：SEEDUbuntuTarget连接状态</p><p>（4）在SEEDUbuntu上使用“telnet<br>192.168.1.2”命令尝试建立telnet连接，发现连接超时，无法建立连接。</p><p><img src="/现代计算机网络lab02-实验报告/03e5fcf818d9d081ac70b2891a2b8c8f.jpg" alt="SEEDUbuntu [Running] / bin/bash /bin/bash • Orade VM Virtua130x root\@uw 4702 u x Option &#39; --dist-prot&#39; is not supported Error 10011 • tool argument not decoded netwox 76 -i 192.168.1.2 Option &#39;--dist-port&#39; is not supported Error 10611 tool argLMnent not decoded netwox 76 -i 192.168.1.2 root\@VM:/home/seed\# netwox 76 -i 192.168 root\@VM:/home/seed\# ip route netwox 76 -i 192.168.1.2 telnet 192.168.1.2 .1.2 23 Trying 192.168.1.2. telnet: Unable to connect to remote host: Conne ction timed out root\@VM 169.254. 192. €.0/16 dev etho scope link metric 100 1.0/24 dev etho proto kernel scope I i ip route add default via 19 root\@VM:/home/seed\# netwox 76 root\@VM:/home/seed\# netwox 76 netwox 76 -i 192.168.1.2 -i 192.168.1.2 - -i 192.168.1.2 - "></p><p>图15：建立Telnet连接失败</p><p>（5）设置SeedUbuntuTarget的tcp_syn_cookies参数为1，开启tcp_cookies，此时再尝试用SEEDUbuntu进行Telnet连接，发现连接成功。</p><p><img src="/现代计算机网络lab02-实验报告/fded31b7fcd2aa5fbaf4d524fd5877ed.jpg" alt="SEEDUbuntuTarget [Running]  "></p><p><img src="/现代计算机网络lab02-实验报告/11a95050349352cb6fd9bfc8e64e9108.jpg" alt="SEEDUbuntu [Running]  "></p><p>图16：Telnet连接成功</p><p>此时再观察SEEDUbuntuTarget的TCP连接状态，可以看到在众多的SYN_RECV状态中有一个ESTABLISHED状态，来自192.168.1.1的52074端口。</p><p><img src="/现代计算机网络lab02-实验报告/5eb157291c0e26adaf951f3724e63823.jpg" alt="root\@VM: /pmc/sys/net/ipv4 root  "></p><p>图17：SEEDUbuntuTarget的TCP连接状态</p><ol><li>关闭SYN Flooding攻击，结束本次实验。</li></ol><h2 id="实验结果和分析"><a href="#实验结果和分析" class="headerlink" title="实验结果和分析"></a>实验结果和分析</h2><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>本次实验使用Virtualbox虚拟平台，配合GNS建立网络拓扑，使用Wiresdhark观察网络中数据包传输情况<br>，成功对靶机实施了SYN Flood攻击。</p><p>本次实验中需要的是需要设置靶机的默认路由。否则在被攻击时，因为靶机路由表中没有这些伪造地址的路由，所以靶机不会回复TCP连接请求，也不会为其预留资源，在这种情况下，即使攻击成功也会被telnet成功连接。</p><p>实验中，主要改变了SYN cookies和tcp_max_syn_backlog的值，在均使用攻击机进行SYN<br>flood攻击模拟的情况下，见表4.1。</p><p>表4.1 SYN Cookies Value</p><table><thead><tr><th>SYN Cookies Value</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>即关闭了SYN cookies防范机制，此时表现为靶机无法防范SYN flood攻击，在被攻击时无法被其他机器通过telnet登陆。且TCP连接队列大小固定为backlog的值，虽然队列内在不断刷新，本可以给新来的telnet连接以机会，但是攻击报文快速涌入，导致telnet连接的三次握手无法完成，最终使靶机表现为无法连接。</td></tr><tr><td>1</td><td>即开启了SYN cookies防范机制，此时表现为靶机可以防范SYN flood攻击，在被攻击时可以被其他机器通过telnet登陆。但TCP连接队列大小不固定为backlog的值，推测此时连接队列的大小受到多个参数的制约。</td></tr></tbody></table><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><h4 id="SYN-flood与TCP三次握手"><a href="#SYN-flood与TCP三次握手" class="headerlink" title="SYN flood与TCP三次握手"></a>SYN flood与TCP三次握手</h4><p>SYN<br>flood攻击的原理是利用了TCP协议中的三次握手过程。对于三次握手过程，TCP协议中规定，当一台主机A想向另一台主机B发起TCP连接时，A需要先发送TCP<br>SYN 包给B，B收到后发送一个TCP SYN+ACK包回复至A，A此时再发送TCP<br>ACK包回给B，此时三次握手才结束，连接建立成功，对于B，连接的过程有“SYN_RECV”-“TIME_WAIT”-“ESTABLISHED”。</p><p>其中B在“SYN_RECV”状态，即半开连接状态下，在等待TCP<br>SYN+ACK包发送回来前，系统要先分配好一个数据区专门服务于这个即将形成的TCP连接。</p><p>SYN<br>flood攻击则是利用在短时间内伪造大量的源地址，向被攻击主机发送大量的SYN包，以让靶机为每一个SYN包分配一个数据区，以建立预期的TCP连接，这样就会导致大量资源消耗，系统也不能对后面正常的TCP连接进行响应。</p><h4 id="SYN-cookie抵御SYN-Flood攻击的原理"><a href="#SYN-cookie抵御SYN-Flood攻击的原理" class="headerlink" title="SYN cookie抵御SYN Flood攻击的原理"></a>SYN cookie抵御SYN Flood攻击的原理</h4><p>SYN cookies是对TCP服务器端的三次握手做一些修改，专门用来防范SYN<br>Flood攻击的一种手段。它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN +<br>ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN<br>ACK包的初始序列号。当客户端返回一个ACK包时，根据包头信息计算cookie，与返回的确认序列号(初始序列号<br>+<br>1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接。这样就不需要等待客户的响应，防止其占用资源。</p><p>实现的关键在于cookie的计算，cookie的计算应该包含本次连接的状态信息，使攻击者不能伪造。cookie的计算过程为，服务器收到一个SYN包，计算一个消息摘要mac<br>= MAC(A,<br>k)；其中MAC是密码学中的一个消息认证码函数，也就是满足某种安全性质的带密钥的hash函数，它能够提供cookie计算中需要的安全性。在Linux中，MAC函数为SHA1。A的计算方式如下：</p><p>A = SOURCE_IP || SOURCE_PORT || DST_IP || DST_PORT || t || MSSIND</p><p>k为服务器独有的密钥，实际上是一组随机数。t为系统启动时间，每60秒加1，MSSIND为MSS对应的索引。</p><p>通过计算并验证cookie，SEEDUbuntu避免了守候半开放连接，从而能够有足够的资源响应SEEDUbuntu的SYN连接请求,因此当开启syn_cookies时，能够正常建立连接。</p><p>被攻击端不开启SYN Cookie，当遭受SYN<br>Flood攻击时，正常的TCP连接无法进行连接到被攻击。</p><p>SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN<br>Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP<br>SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP<br>ACK包时，TCP服务器在根据那个cookie值检查这个TCP<br>ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。</p><p>开启和不开启SYN Cookie的连接步骤如下图所示。</p><p><img src="/现代计算机网络lab02-实验报告/c1fd0f29009f8f2f81138e646a0ac3f5.png" alt></p><p>可以很容易的知道开启SYN Cookie 时可以很好的防范SYN Flood 攻击。</p><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><h5 id="SYN-cookie"><a href="#SYN-cookie" class="headerlink" title="SYN cookie"></a>SYN cookie</h5><p>SYN Cookie的原理是靶机在收到TCP<br>SYN包后，保持在半开连接状态下时，不再为每一个SYN包分配一个专门的数据区，而是根据加密算法计算出一个cookie值，并与TCP<br>SYN+ACK包一同发送。在后面收到返回的TCP<br>ACK包时再进行校验，根据返回的cookie值来检查这个TCP<br>ACK包的合法性。如果合法，再分配专门的数据区以建立未来的TCP连接，此时即有效地防范了SYN<br>flood攻击。</p><h5 id="tcp-max-syn-backlog"><a href="#tcp-max-syn-backlog" class="headerlink" title="tcp_max_syn_backlog"></a>tcp_max_syn_backlog</h5><p>tcp_max_syn_backlog的值应可以简单理解为TCP连接队列的大小，实验中，在SYN<br>cookie设置关闭时，主机的TCP连接队列的最大值即严格按照backlog的值；而在SYN<br>cookie设置打开时，变化backlog的值对TCP连接队列的最大值并无明显影响，推测是由于此时连接队列的最大值受到多个参数的制约。而不论SYN<br>cookie是否打开，在接受攻击时主机的TCP连接队列都在不断刷新，即应会在连接数增加到最大值时关闭旧连接。由此推测在SYN<br>cookie关闭时，调小backlog的值可以减少系统在等待TCP连接完成时的资源的消耗，但新连接很有可能在完成三次握手之前就被关闭；相反，如果增大backlog的值，有机会会使新连接在被攻击报文淹没之前完成三次握手，但相对会增大系统的资源消耗。</p><p>因而，相对来说不开启SYN cookie机制，调节backlog的值会可能会对SYN<br>flood攻击有一些效果，但相对于开启SYN cookie机制仍不够有效。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>网络攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[16]数值的整数次方</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B16%5D%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16:数值的整数次方"></a>面试题16:数值的整数次方</h1><p>题目：实现函数double Power(doubele base, iont exponent), 求base的exponent次方。 不得使用库函数，同时不需要考虑大数问题。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h2><p>下面这种解法只考虑了指数为正数的情况，并没有考虑指数小于1（0以及负正数）的情况：<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=exponent; ++i)</span><br><span class="line">        result*=base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p>当指数为负时，可以先对指数求绝对值，算出次方的结果之后再取倒数。但是要避免底数为0时，对其进行负幂运算。<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_InvalidInput=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>)&amp;&amp;exponent&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line"><span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">    absExponent=(<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result=PowerWithUnsignedExponent(base, basExponent);</span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)</span><br><span class="line">        result = <span class="number">1.0</span>/result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=exponent; ++i)</span><br><span class="line">        result *=base;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>另在上述代码中，我们用全局变量标识是否出错。如果出错，则返回值是0。为了区分出错的时候返回0，还是底数为0的时候正常运行返回的零，我们使用全局变量g_InvalidInput进行标识。</p><h2 id="完美解法"><a href="#完美解法" class="headerlink" title="完美解法"></a>完美解法</h2><p>加速运算，将指数运算拆分成若干指数运算的乘积：<br>$$a^n=\begin{cases}<br>a^{n/2}\cdot a^{n/2} &amp; n为偶数 \<br>a^{(n-1)/2}\cdot a^{(n-1)/2} &amp; n为奇数\<br>\end{cases}$$<br>然后使用递归法求运算结果。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span>  base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> result=PowerWithUnsignedExponent(base, exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    result *=result;</span><br><span class="line">    <span class="keyword">if</span>(exponent &amp; <span class="number">0x1</span>==<span class="number">1</span>)</span><br><span class="line">        result*=base;</span><br><span class="line">    <span class="keyword">return</span> result;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们还是用了两个小技巧：用右移运算符代替除以2，用位与运算符(%)来判断一个数是偶数还是奇数。因为位运算比size运算的效率要高很多，这样可以起到优化代码的作用。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Server网络配置</title>
    <url>/Ubuntu%20Server%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>需求：在进行内网穿透的实验过程中，需要将Ubuntu server的IPv4分配方式改为静态。</p><p>Ubuntu自17.10开始，就放弃使用/etc/network/interfaces进行Ip配置。因此，即使在新版本里对interfaces进行了配置，也不会生效。</p><p>新的方法是使用netplan方式进行配置 ，配置写在/etc/netplan/01-netcfg.yaml或者类似名称的yaml文件里。</p><p>Ubuntu Server 18.04的yaml配置文件是：/etc/netplan/50-cloud-init.yaml，修改配置以后不用重启，直接执行netplan apply 命令即可以让配置生效。</p><p>注意：以前的重启网络服务命令/etc/init.d/networking restart或者services network restrart也都会提示为无效命令。</p><h1 id="yaml配置模板"><a href="#yaml配置模板" class="headerlink" title="yaml配置模板"></a>yaml配置模板</h1><p>下面是我的配置模板：<br></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This file is generated from information provided by</span></span><br><span class="line"><span class="comment"># the datasource.  Changes to it will not persist across an instance.</span></span><br><span class="line"><span class="comment"># To disable cloud-init's network configuration capabilities, write a file</span></span><br><span class="line"><span class="comment"># /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following:</span></span><br><span class="line"><span class="comment"># network: &#123;config: disabled&#125;</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">        <span class="attr">enp9s0:</span></span><br><span class="line">            <span class="attr">addresses:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.133</span><span class="number">.120</span><span class="string">/24</span></span><br><span class="line">            <span class="attr">dhcp4:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.133</span><span class="number">.1</span></span><br><span class="line">            <span class="attr">nameservers:</span></span><br><span class="line">                <span class="attr">addresses:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="number">114.114</span><span class="number">.114</span><span class="number">.114</span></span><br><span class="line">                <span class="attr">search:</span> <span class="string">[]</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络lab02-SYN flood攻击及SYN cookie原理分析</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab02-SYN%20flood%E6%94%BB%E5%87%BB%E5%8F%8ASYN%20cookie%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul><li><p>SEED：计算机安全教育的教学实验平台 • <a href="http://www.cis.syr.edu/~wedu/seed/" target="_blank" rel="noopener">http://www.cis.syr.edu/~wedu/seed/</a> • 纽约雪城大学 杜文亮 (Du, Wenliang)教授设计和实现，从2002年 开始得到NSF 1.2M$的资助</p></li><li><p>SEED内容包含以下几类</p></li><li><p>网络安全主要包括十大实验</p></li><li>分为攻击类、破解类、实现类</li><li>难度越大、消耗的时间越长</li></ul><h1 id="二、TCP-IP-攻击实验"><a href="#二、TCP-IP-攻击实验" class="headerlink" title="二、TCP/IP 攻击实验"></a>二、TCP/IP 攻击实验</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>• Netwox Tools作为报文生成工具<br>• Wireshark 报文截获工具<br>• 启动 ftp and telnet Servers</p><p>• Task 1 : SYN Flooding Attack<br>• Task 2 : TCP RST Attacks on telnet and ssh Connections<br>• Task 3 : TCP RST Attacks on Video Streaming Applications<br>• Task 4 : TCP Session Hijacking<br>• Task 5 : Creating Reverse Shell using TCP Session Hijacking<br>• 注意：攻击者可以观察到被攻击者的流<br>• netwox Tools一共提供了200多个工具<br>• 运行netwox，进入界面后<br>• 选项3搜索工具<br>• 选项4显示帮助</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>• VirtualBox新建虚拟机</p><p>• 导入SEED 虚拟机镜像文件，运行虚拟机</p><p>• 普通用户登陆，有特权操 作再su<br>• 超级用户 User ID: root, Password: seedubuntu.<br>• 普通用户 User ID: seed, Password: dees</p><p>• 利用GNS3配置如图网络<br>• SEED ubuntu 攻击 SEED Ubuntu target<br>• 配置好两台主机的地址和路由</p><h3 id="配置IP地址命令："><a href="#配置IP地址命令：" class="headerlink" title="配置IP地址命令："></a>配置IP地址命令：</h3><p>• ip address显示地址<br>• sudo ip address add 192.168.1.1/24 dev eth0 添加IP<br>• sudo ip address del 192.168.1.1/24 dev eth0 删除IP</p><h3 id="增加路由"><a href="#增加路由" class="headerlink" title="增加路由"></a>增加路由</h3><p>• ip route显示路由<br>• sudo ip route add 192.168.1.0/24 dev eth0<br>• sudo ip route del 192.168.1.0/24 dev eth0</p><h3 id="增加路由-1"><a href="#增加路由-1" class="headerlink" title="增加路由"></a>增加路由</h3><p>• ip route add {NETWORK/MASK} via {GATEWAYIP}</p><h3 id="增加默认路由"><a href="#增加默认路由" class="headerlink" title="增加默认路由"></a>增加默认路由</h3><p>• ip route add default via 192.168.1.1<br>• 永久修改网络配置，图形界面配置</p><p>• SEED Ubuntu target上启动telnet服务： service service openbsd-inetd start<br>• 攻击命令： netwox 76 -i 192.168.1.1 –dst-port 23<br>• 可以在SEED ubuntu 或者 SEED Ubuntu target 上用 tcpdump或者wireshark观察攻击报文： 如左图<br>• 可以在SEED ubuntu 或者 SEED Ubuntu target 上用 tcpdump或者wireshark观察建立连接： netstat –n –tcp</p><h1 id="进一步观察linux内核tcp-syn-cookie机制"><a href="#进一步观察linux内核tcp-syn-cookie机制" class="headerlink" title="进一步观察linux内核tcp syn cookie机制"></a>进一步观察linux内核tcp syn cookie机制</h1><p>配置内核参数的两种方式：<br>• cat /proc/sys/net/ipv4/tcp_syncookies<br>• echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies<br>• sysctl –a | grep net.ipv4.tcp_max_syn_backlog<br>• sysctl -w net.ipv4.tcp_max_syn_backlog = 5<br>比较打开和关闭SEED Ubuntu target内核tcp syn cookie参数，syn flood攻击的效果：</p><ol><li>设置SEED Ubuntu target上， net.ipv4.tcp_max_syn_backlog=5 2.</li><li>设置SEED Ubuntu target上， net.ipv4. tcp_syncookies=0</li><li>从SEED Ubuntu 上用netwox的syn flood攻击SEED Ubuntu target</li><li>同时从SEED Ubuntu 上用telnet 主机 SEED Ubuntu target，看能否建立连 接？</li></ol><p>打开SEED Ubuntu target内核tcp syn cookie参数，同时从SEED Ubuntu 上用 telnet 主机 SEED Ubuntu target，看能否建立连接？</p><h1 id="实验报告要求"><a href="#实验报告要求" class="headerlink" title="实验报告要求"></a>实验报告要求</h1><ol><li>写出完整的实验配置过程，包括拓扑结构和配置命令</li><li>用截图的方式描述实验结果</li><li>描述tcp syn cookie的原理</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>网络空间安全</category>
        <category>网络实验</category>
      </categories>
      <tags>
        <tag>网络实验</tag>
        <tag>网路攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置多https站点</title>
    <url>/Nginx%E9%85%8D%E7%BD%AE%E5%A4%9Ahttps%E7%AB%99%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:03 GMT+0800 (China Standard Time) --><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>最近需要在一台云服务器上使用Nginx同时部署多个http与https服务。使得多个http以及https站点分别监听80以及443端口。</p><h1 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a>思考过程</h1><p>在此之前，我已经成功地在服务器上部署了单对http以及https服务，并强制使http跳转到https。在部署多https时，参考了很多博客，有的说使用正向代理，也有说使用反向代理的，后来仔细学习了Nginx，才发现原来事情根本没有那么复杂，只需要像配置单对http以及https服务那样，将配置文件重新复制一份就行了。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>现有domain, domian2, …, domianN 一共N个站点需要同时监听80以及443端口，且使用80端口访问其中任一站点时，nginx将会将这些请求发送到此站点对应的443端口。<br>下面是Nginx对于<a href="http://www.domain.com站点的配置文件，将其存储在/etc/nginx/conf.d目录下，习惯将其命名为domain.conf。" target="_blank" rel="noopener">www.domain.com站点的配置文件，将其存储在/etc/nginx/conf.d目录下，习惯将其命名为domain.conf。</a><br></p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/nginx/domain.conf</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line"><span class="comment">#填写绑定证书的域名</span></span><br><span class="line"><span class="attribute">server_name</span> www.domain.com; </span><br><span class="line"><span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"><span class="comment">#网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span></span><br><span class="line"><span class="attribute">root</span> /var/www/www.domain.com; </span><br><span class="line"><span class="attribute">index</span> index.html index.htm;   </span><br><span class="line"><span class="comment">#证书文件名称</span></span><br><span class="line"><span class="attribute">ssl_certificate</span>  1_www.domain.com_bundle.crt; </span><br><span class="line"><span class="comment">#私钥文件名称</span></span><br><span class="line"><span class="attribute">ssl_certificate_key</span> 2_www.domain.com.key; </span><br><span class="line"><span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line"><span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line"><span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line"><span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">   <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"><span class="comment">#填写绑定证书的域名</span></span><br><span class="line"><span class="attribute">server_name</span> www.domain.com; </span><br><span class="line"><span class="comment">#把http的域名请求转成https</span></span><br><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于其余的$N-1$个站点，只需要将此配置文件复制$N-1$份，并将其中domian名称以及对应的ssl文件存储位置进行替换即可。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[15]二进制中1的个数</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B15%5D%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题15"><a href="#面试题15" class="headerlink" title="面试题15"></a>面试题15</h1><p>题目：请事先一个函数，输入一个整数，输出该数二进制表示中1的个数。例如，把9表示1的个数。例如，把9表示成二进制是1001，有2位是1.因此，如果输入9，则该函数输出2。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：可能会引起死循环"><a href="#法一：可能会引起死循环" class="headerlink" title="法一：可能会引起死循环"></a>法一：可能会引起死循环</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            count++;</span><br><span class="line">            n=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二：常规解法"><a href="#法二：常规解法" class="headerlink" title="法二：常规解法"></a>法二：常规解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;flag)</span><br><span class="line">            count++;</span><br><span class="line">        flag=flag&lt;&lt;<span class="number">1</span>;&gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法三：推荐解法"><a href="#法三：推荐解法" class="headerlink" title="法三：推荐解法"></a>法三：推荐解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n=(n<span class="number">-1</span>)^n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[14]剪绳子</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B14%5D%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题14"><a href="#面试题14" class="headerlink" title="面试题14"></a>面试题14</h1><p>题目：给你一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度纪委k[0]，k[1]，…，k[m]。请问k[0]$\times$k[1]$\times$···$\times$k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2, 3, 3的三段，此时得到的最大乘积是18。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：动态规划"><a href="#法一：动态规划" class="headerlink" title="法一：动态规划"></a>法一：动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution1</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    products[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    products[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    products[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">int</span> product=products[j]*products[i-j];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">max</span>&lt;product)</span><br><span class="line">                <span class="built_in">max</span> = product;</span><br><span class="line">            products[i]=<span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">max</span>=products[length];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法二：贪婪算法"><a href="#法二：贪婪算法" class="headerlink" title="法二：贪婪算法"></a>法二：贪婪算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尽可能多地剪去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length/<span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当绳子最后剩下的长度为4时，不能再剪去长度为3的绳子短</span></span><br><span class="line">    <span class="comment">//此时更好的方法是把绳子剪成长度为2的两端，因为2*2&gt;3*1</span></span><br><span class="line">    <span class="keyword">if</span>(length-timesOf3*<span class="number">3</span>==<span class="number">1</span>)</span><br><span class="line">        timesOf3-=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf2=(length-timesOf3*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, timesOf3))*(<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>剑指Offer面试题[13]机器人的运动范围</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B13%5D%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题13"><a href="#面试题13" class="headerlink" title="面试题13"></a>面试题13</h1><p>题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格(35, 17)，因为3+5+3+8=18。但它不能进入方格(35, 38)，因为3+5+3+9=19，请问该机器人能够到达多少格子？</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threshold&lt;<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> *visited=<span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;rows*cols; ++i)</span><br><span class="line">        visited[i]=<span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> movingCountCore(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>*visited)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited))</span><br><span class="line">    &#123;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">true</span>;</span><br><span class="line">            count=<span class="number">1</span>+movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)+movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited)+movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)+movingCountCore(threshold, rows,cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols&amp;&amp;getDigitSum(row)+getDigitSum(col)&lt;=threshold&amp;&amp;!visited[row*cols+col])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(number&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=number%<span class="number">10</span>;</span><br><span class="line">        number/=<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[12]矩阵中的路径</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B12%5D%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题12"><a href="#面试题12" class="headerlink" title="面试题12"></a>面试题12</h1><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一个路径经过了矩阵的某一个，那么该路径不能再次进入该格子。例如，在下面的3$\times4$的矩阵中包含一条字符串“bfee”的路径（路径中的字母用下划线标出）。但矩阵中不包含字符串”abfb”的路径，因为字符串的第一个字符b占据了矩阵中第一行第二个格子之后，路径不能再次进入这个格子。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span>||rows&lt;<span class="number">1</span> ||cols&lt;<span class="number">1</span>||str==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows*cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pathLength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row&lt;rows; ++row)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;cols;++col)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str, pathlength, visited))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength]==<span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasPath=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;<span class="number">0</span>&amp;&amp;col&lt;cols &amp;&amp;matrix[row*cols+col]==str[pathLength]&amp;&amp;!visited[row*cols+col])</span><br><span class="line">    &#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[rows*cols+col]=<span class="literal">true</span>;</span><br><span class="line">        hasPath=hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>, str, pathLength, visited)||hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>, str, pathLength, visited)||hasPath(matrix, rows, cols, row+<span class="number">1</span>, col, str, pathLegnth, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!hasPath)</span><br><span class="line">        &#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[11]旋转数组的最小数字</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B11%5D%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题11"><a href="#面试题11" class="headerlink" title="面试题11"></a>面试题11</h1><p>题目：把一个数组最开始的若干数组搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最值为1.</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">intMin（<span class="keyword">int</span>*numbers， <span class="keyword">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid parameters"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = length <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">        <span class="keyword">while</span>(numbers[index1]&gt;=numbers[index2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index2-index1==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                indexMid=index2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            indexMid=(index1+index2)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1])</span><br><span class="line">                index1 indexMid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2])</span><br><span class="line">                index2 = indexMid</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span>* number, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">std</span>::exception(<span class="string">"invalid parameters"</span>);</span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = length <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMid = index1;</span><br><span class="line">    <span class="keyword">while</span>(numbers[index1]&gt;=numbers[index2])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2-index==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            indexMid=index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        indexMid=(index1+index2)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果下表为index1、index2和indexMid指向的三个数字相等，</span></span><br><span class="line">        <span class="comment">//则只能顺序查找</span></span><br><span class="line">        <span class="keyword">if</span>（numbers[index1]==numbers[index2]&amp;&amp;numbers[indexMid]==numbers[index1])</span><br><span class="line">            <span class="keyword">return</span> MinInOrder(numbers, index1, index2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(numbers[indexMid]&gt;=numbers[index1])</span><br><span class="line">            index1 = indexMid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[indexMid]&lt;=numbers[index2])</span><br><span class="line">            index2 = indexMid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[indexMid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[index1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index1+<span class="number">1</span>; i&lt;=index2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>（result&gt;numbers[i])</span><br><span class="line">        result=numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[9]用两个栈实现队列</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B9%5D%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题9：用两个栈实现队列"><a href="#面试题9：用两个栈实现队列" class="headerlink" title="面试题9：用两个栈实现队列"></a>面试题9：用两个栈实现队列</h1><p>题目：用两个栈实现一个队列。队列的生命如下，请事先它的菱格函数appendTail和deleteHead,分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">void</span>);</span><br><span class="line">    ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">    T.deleteHead();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>本题属于基本题，利用栈的先进后出的特性，使用两个栈便可实现队列的功能。代码如下：<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="keyword">void</span> CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>.<span class="built_in">size</span>()&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T&amp; data=stack1.top();</span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack2.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">    T head=stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[10]斐波那契数列</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B10%5D%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题10"><a href="#面试题10" class="headerlink" title="面试题10"></a>面试题10</h1><h2 id="题目一：求斐波那契数列的第n项"><a href="#题目一：求斐波那契数列的第n项" class="headerlink" title="题目一：求斐波那契数列的第n项"></a>题目一：求斐波那契数列的第n项</h2><p>写一个函数，输入$n$，求斐波那契(Fibonacci)数列的第$n$项。斐波那契数列的定义如下：<br>$$f(n)=\begin{cases}<br>0 &amp; n=0\<br>1 &amp; n=1\<br>f(n-1)+f(n-2) &amp; n&gt;1<br>\end{cases} $$</p><h2 id="题目二：青蛙跳台阶问题"><a href="#题目二：青蛙跳台阶问题" class="headerlink" title="题目二：青蛙跳台阶问题"></a>题目二：青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个$n$级台阶总共有多少种跳法。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><h3 id="效率很低的解法"><a href="#效率很低的解法" class="headerlink" title="效率很低的解法"></a>效率很低的解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实用解法"><a href="#实用解法" class="headerlink" title="实用解法"></a>实用解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result[<span class="number">2</span>]=&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusOne = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibNMinusTwo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fibN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i =<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fibN = fibNMinusOne +fibNMinusTwo;</span><br><span class="line">        fibNMinusTwo=fibNMinusOne;</span><br><span class="line">        fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度为-O-log-n-，但不够实用"><a href="#时间复杂度为-O-log-n-，但不够实用" class="headerlink" title="时间复杂度为$O(\log{n})$，但不够实用"></a>时间复杂度为$O(\log{n})$，但不够实用</h3><p>使用数学公式，可以将问题转化为如何求得矩阵$\left[<br>\begin{matrix}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{matrix}<br>\right]<br>$<br>的乘方。</p><p>$$<br>\left[<br>\begin{matrix}<br>f(n) &amp; f(n-1) \<br>f(n-1) &amp; f(n-2) \<br>\end{matrix}<br>\right]<br>=<br>\left[<br>\begin{matrix}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{matrix}<br>\right]<br>$$<br>考虑到乘方具有如下性质：<br>$$a^n=\begin{cases}<br>a^{n/2} &amp; n为偶数\<br>a^{(n-1)/2}\cdot a^{(n-1)/2}\cdot a&amp; n为奇数\<br>\end{cases} $$<br>因此，想求得$n$次方，只需要闲求得$n/2$次方，再把$n/2$次方的结果进行平方即可。可使用递归法求解。递归法的时间复杂度是$O(\log{n})$</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>题目二同样可以归结为斐波那契数列，使用同样的解法便可求得。在此不再赘述。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[8]二叉树的下一个节点</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B8%5D%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题8：二叉树的下一个节点"><a href="#面试题8：二叉树的下一个节点" class="headerlink" title="面试题8：二叉树的下一个节点"></a>面试题8：二叉树的下一个节点</h1><p>题目：给定一棵二叉树和其中一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>如果一个节点有右节点，那么它的下一个节点就是它的右子树中的最左节点。<br>如果一个节点没有右子树，且这个节点是其父节点的左子节点，那么它的下一个节点是其父节点。<br>如果一个节点没有右子树，且这个节点是其父节点的右子节点，那么我们需要经这个节点沿着指向其府机电的指针一直向上遍历，知道找到一个节点，这个节点是其父节点的左子节点，那么这个节点的父节点就是我们要找的节点。<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">GetNext</span><span class="params">(BinaryTreeNode* Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode ==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;m_pRight!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pRight =pNode-&gt;m_pRight;</span><br><span class="line">        <span class="keyword">while</span>(pRight-&gt;m_pLeft!=<span class="literal">nullptr</span>)</span><br><span class="line">            pRight=pRight-&gt;m_pLeft;</span><br><span class="line">        pNext=pRight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;m_pParent!=null)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode* pCurrent = pNode;</span><br><span class="line">        BinaryTreeNode* pParent = pNode-&gt;m_pParent;</span><br><span class="line">        <span class="keyword">while</span>(pParent!=<span class="literal">nullptr</span> &amp;&amp;pCurrent ==pParent-&gt;m_pRight)</span><br><span class="line">        &#123;</span><br><span class="line">            pCurrent = pParent;</span><br><span class="line">            pParent = pParent-&gt;m_pParent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext=pParent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>剑指Offer面试题[7]重建二叉树</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B7%5D%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题7：重建二叉树"><a href="#面试题7：重建二叉树" class="headerlink" title="面试题7：重建二叉树"></a>面试题7：重建二叉树</h1><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不喊重复的数字。例如，输入前序遍历序列{1, 2, 4, 7, 3, 5, 7, 8}和中序遍历{4, 7, 2, 1, 5, 3, 8 ,6}, 则重建如图2.6所示的二叉树并输出它的头结点。二叉树节点的定义如下：<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    BinaryTreeNode* m_pLeft;</span><br><span class="line">    BinaryTreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>前序遍历的特点：根左右<br>中序遍历的特点：左根右<br>我们可以根据前序遍历确定二叉树根节点，再对照根节点在中序遍历中的位置逐步确定其余节点与根节点的父子关系。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">Construct</span><span class="params">(<span class="keyword">int</span>* preorder, <span class="keyword">int</span>* inorder, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder == <span class="literal">nullptr</span>||inorder == <span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ConstructCore(preorder, preorder+length<span class="number">-1</span>, inorder, inorder+length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">BinaryTreeNode* ConstructCore</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* startPreorder, <span class="keyword">int</span>* endPreorder,</span><br><span class="line">    <span class="keyword">int</span>* startInorder, <span class="keyword">int</span>* endInorder</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//前序遍历序列的第一个数字是根节点的值</span></span><br><span class="line">    <span class="keyword">int</span> rootValue=startPreorder[<span class="number">0</span>];</span><br><span class="line">    BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode();</span><br><span class="line">    root-&gt;m_nValue = rootValue;</span><br><span class="line">    root-&gt;m_pLeft = root-&gt;m_pRight=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(startPreorder == endPreorder)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在中序遍历序列中找到根节点的值</span></span><br><span class="line">    <span class="keyword">int</span>* rootInorder = startInorder;</span><br><span class="line">    <span class="keyword">while</span>(rootInorder &lt;=endInorder &amp;&amp; *rootInorder !=rootValue)</span><br><span class="line">        ++rootInorder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rootInorder == endInorder &amp;&amp; *rootInorder !=rootValue)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(<span class="string">"Invalid input."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength=rootInorder-startInorder;</span><br><span class="line">        <span class="keyword">int</span>* leftPreorderEnd = startPreorder + leftLength;</span><br><span class="line">        <span class="keyword">if</span>(leftLength&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建左子树</span></span><br><span class="line">            root-&gt;m_pLeft=ConstructCore(startPreorder+<span class="number">1</span>, leftPreorderEnd, startInorder, rootInorder<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftLength&lt;endPreorder-startPreorder)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构建右子树</span></span><br><span class="line">            root-&gt;m_pRight=ConstructCore(leftPreorderEnd+<span class="number">1</span>, endPreorder, rootInorder+<span class="number">1</span>, endInorder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>剑指Offer面试题[6]从头到尾打印链表</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B6%5D%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题6"><a href="#面试题6" class="headerlink" title="面试题6"></a>面试题6</h1><p>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。链表节点定义如下：<br>struct ListNode<br>{<br>int m_nKey;<br>ListNode* m_pNext;<br>};</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：修改链表指针"><a href="#法一：修改链表指针" class="headerlink" title="法一：修改链表指针"></a>法一：修改链表指针</h2><p>设前后两个指针，从前往后，依次改变所有链表指针的方向。但是这样做就修改了原始链表的结构。在面试中，需要若打算修改输入的数据，需要实现征询面试官的意见。</p><h2 id="法二：使用辅助栈"><a href="#法二：使用辅助栈" class="headerlink" title="法二：使用辅助栈"></a>法二：使用辅助栈</h2><p>输出数据具有“后进先出”的特点，即遍历的最后一个节点需要最先输出，因此，我们可以利用同样具有“后进先出”特性的栈数据结构，来辅助完成此操作。<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Iteratively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;ListNode*&gt; nodes; <span class="comment">//辅助栈</span></span><br><span class="line">    </span><br><span class="line">    ListNode* pNode = pHead; <span class="comment">//让指针指向原始栈链表的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(pNode!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes.push(pNode); <span class="comment">//将头结点入栈</span></span><br><span class="line">        pNode = pNode-&gt;m_pNext; <span class="comment">//移动指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = nodes.top();</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"%d\t"</span>, pNode-&gt;m_nValue);</span><br><span class="line">        nodes.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="法三：使用递归"><a href="#法三：使用递归" class="headerlink" title="法三：使用递归"></a>法三：使用递归</h2><p>递归本质上就是一种栈的结构，因此很自然地，可以使用栈来完成这种操作：每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结构就反过来了。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintListReversingly_Recursively</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PrintListReversingly_Recursively(pHead-&gt;m_pNext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t"</span>, pHead-&gt;m_nValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[5]替换空格</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B5%5D%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题5：替换空格"><a href="#面试题5：替换空格" class="headerlink" title="面试题5：替换空格"></a>面试题5：替换空格</h1><p>题目：请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”, 则输出We%20are%20happy.”</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="时间复杂度为-O-n-2-的解法"><a href="#时间复杂度为-O-n-2-的解法" class="headerlink" title="时间复杂度为$O(n^2)$的解法"></a>时间复杂度为$O(n^2)$的解法</h2><p>从头到尾扫描字符串，每次碰到空格字符的时候进行替换。每次替换完毕之后，都把之后的字符往后移动两位。<br>假设字符串的长度是n。对于每个空格字符，需要移动后边$O(n)$个字符，因此对于含有$O(n)$个空格字符的字符串而言，总的时间效率是$O(n^2)$。<br><a id="more"></a></p><h2 id="时间复杂度为-O-n-的解法"><a href="#时间复杂度为-O-n-的解法" class="headerlink" title="时间复杂度为$O(n)$的解法"></a>时间复杂度为$O(n)$的解法</h2><p>上边的做法，时间复杂度太高。我们还可以采用下边这种解法，这样可以将时间复杂度降低到$O(n)$:<br>首先，遍历一次字符串，统计出字符串内空格的数量。由此可以计算出替换之后的字符的总长度。设原长度为$L$，现长度为$L’$，字符串内包含有$n$个空格，则$L$与$L’$应存在下列关系：<br>$$L’=L+2 n$$<br>接着，准备两个指针$P_1$和$P_2$从字符串的后面开始进行复制和替换。其中$P_1$指向原始字符串的末尾，$P_2$指向替换之后的字符串的末尾。<br>接着，我们将$P_1$逐步往前移动，逐个将它们复制到$P_2$指向的位置。如果碰到空格,则先将$P_1$P往前移动1个，在P2之前插入字符串”%20”，由于”%20”的长度为3，同时需要把$P_2$往前移动三格。以此类推。<br>当指针$P_1$和$P_2$指向同一位置时，则表明，所有空格已经被替换完毕。<br>代码如下:<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//length为字符数组string的总容量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ReplaceBlank</span><span class="params">(<span class="keyword">char</span> <span class="built_in">string</span>[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">nullptr</span>||length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//originallLength为字符串string的实际长度</span></span><br><span class="line">        <span class="keyword">int</span> originalLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//顺序遍历数组，统计出数组中空格的个数numberOfBlank</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">string</span>[i]!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++originalLength;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">string</span>[i]==<span class="string">' '</span>)</span><br><span class="line">                ++numberOfBlank;</span><br><span class="line">                ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//newLength 为把空格替换成'%20'之后的长度</span></span><br><span class="line">        <span class="keyword">int</span> newLength  OriginalLength+numberOfBlank*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newLength&gt;length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> indexOfOriginal = originalLength; <span class="comment">//相当于p1指针</span></span><br><span class="line">        <span class="keyword">int</span> indexOfNew = newLength; <span class="comment">//相当于p2指针</span></span><br><span class="line">        <span class="keyword">while</span>(indexOfOringal &gt;=<span class="number">0</span> &amp;&amp; indexOfNew &gt;indexOfOriginal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">string</span>[indexOfOriginal]==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="string">'0'</span>;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="string">'2'</span>;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span>[indexOfNew--]=<span class="built_in">string</span>[indexOfOringal]; <span class="comment">//把p1指针指向的数据复制到p2指针指向的的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            --indexOfOriginal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>剑指Offer面试题[4]二维数组中的查找</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B4%5D%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题4"><a href="#面试题4" class="headerlink" title="面试题4"></a>面试题4</h1><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。清完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> columns, <span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(matrix!= <span class="literal">nullptr</span> &amp;&amp; rows&gt;<span class="number">0</span> &amp;&amp; columns&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> column = columns<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;rows&amp;&amp;column&gt;=<span class="number">0</span>)</span><br><span class="line">        ]&#123;</span><br><span class="line">            ]<span class="keyword">if</span>(matrix[row*columns+column]==number)</span><br><span class="line">            &#123;</span><br><span class="line">                found=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row*columns+column]&gt;number)</span><br><span class="line">                --column;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++row;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[3]数组中重复的数字</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B3%5D%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题3：数组中重复的数字"><a href="#面试题3：数组中重复的数字" class="headerlink" title="面试题3：数组中重复的数字"></a>面试题3：数组中重复的数字</h1><p>题目一：找出数组中重复的数字<br>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有就几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}, 那么对应的输出是重复的数字2或者3。</p><p>题目二：不修改数组找出重复的数字<br>在一个长度为n+1的数组里所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}, 那么对应的输出是重复的数字2或者3。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="题一解法"><a href="#题一解法" class="headerlink" title="题一解法"></a>题一解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> ||length&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i]&lt;<span class="number">0</span>||numbers[i]&gt;length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i]!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">            *dupliction = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//swap numbers[i] and numbers[numbers[i]]</span></span><br><span class="line">        <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">        numbers[i] = numbers[temp;</span><br><span class="line">        numbers[temp]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题二解法"><a href="#题二解法" class="headerlink" title="题二解法"></a>题二解法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* nujmber, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span>||length ==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> start =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">end</span> &gt;= start)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> middle =((<span class="built_in">end</span>-start)&gt;&gt;<span class="number">1</span>)+start;</span><br><span class="line">        <span class="keyword">int</span> count = countRange(numbers, length, start, middle)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">end</span> == start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(count &gt;(middle-start+<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">end</span> - middle;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[2]实现Singleton模式</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B2%5D%E5%AE%9E%E7%8E%B0Singleton%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="面试题2：实现Singleton模式"><a href="#面试题2：实现Singleton模式" class="headerlink" title="面试题2：实现Singleton模式"></a>面试题2：实现Singleton模式</h1><p>题目：设计一个类，我们只能生成该类的一个实例</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="法一：只适用于单线程环境"><a href="#法一：只适用于单线程环境" class="headerlink" title="法一：只适用于单线程环境"></a>法一：只适用于单线程环境</h2><p>因为要求只产生一个实例，所以我们碧玺把构造函数设为私有函数，以禁止他人创建实例。我们可以定义一个静态实例，这样就可以在需要的时候创建该实例。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = null;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == null)</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><h2 id="法二：适用于多线程，但是效率不高"><a href="#法二：适用于多线程，但是效率不高" class="headerlink" title="法二：适用于多线程，但是效率不高"></a>法二：适用于多线程，但是效率不高</h2><p>法一中的代码在单线程的时候可以正常工作，但在多线程的时候，加入两个线程线程同时运行到了if语句，同时instance没有创建时，这是两个线程都会创建一个实例，此时类型Singleton1就不在满足单例模式的要求了。为了保证多线程环境下我们还只能得到类型的一个实例，需要加上一个同步锁<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> readonly object syncOjb = <span class="keyword">new</span> object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = null;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 Instance;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock(syncObj)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == null)</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="法三：加同步锁前后两次判断实例是否存在"><a href="#法三：加同步锁前后两次判断实例是否存在" class="headerlink" title="法三：加同步锁前后两次判断实例是否存在"></a>法三：加同步锁前后两次判断实例是否存在</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> object syncObj = <span class="keyword">new</span> object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = null;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == null)</span><br><span class="line">            &#123;</span><br><span class="line">                lock(syncObj)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(instance == null)</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="法四：使用静态构造函数"><a href="#法四：使用静态构造函数" class="headerlink" title="法四：使用静态构造函数"></a>法四：使用静态构造函数</h2><p>在C#中，可以通过使用静态构造函数来确保一个函数只调用一次，我们可以使用C#的这种特性实现单例模式。<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span></span></span><br><span class="line"><span class="class">[&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton34</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton4 Instance;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p></p><p>我们在初始化变量instance时，创建了一个实例。由于C#实在调用静态构造函数时初始化仅该变量 ，.NET运行时能够确保只调用一次静态构造函数，这样我们就能够保证只初始化一次instance。<br>值得注意的是：在Singleton4中，实例instance并不是在第一次调用属性Singleton4.Instance的时候被创建的，而是第一次用到Singleton4的时候就被创建。</p><h2 id="法五：实现按需创建实例"><a href="#法五：实现按需创建实例" class="headerlink" title="法五：实现按需创建实例"></a>法五：实现按需创建实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Singleton5()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Nested.instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="title">Nested</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        internal <span class="keyword">static</span> readonly Singleton5 instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在类的内部定义一个私有类型Nested， 当第一次调用这个嵌套类型时，会首先调用静态构造函数创建Singleton5的实例。类型Nested只有在Singleton5.Instance中被使用，其他人无法使用Nested类型。<br>当我们第一次通过属性Singleton5.Instance得到 Sigleton5的实例时，会自动调用Nested的静态构造函数创建实例。如果不调用属性Singleton5.Instance，就不会出发.NET运行时调用Nested，也不会创建实例。这样就真正做到了按需创建。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode精解[5]最长回文子串</title>
    <url>/leetcode%E7%B2%BE%E8%A7%A3%5B5%5D%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>最长回文子串<br>Category | Difficulty | Likes | Dislikes<br>———|————|——-|———<br>algorithms | Medium (27.60%) | 1453 | -</p><p>Tags: 字符串处理 | 动态规划<br>Companies：amazon | bloomberg | microsoft</p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p><p>输入: “cbbd”<br>输出: “bb”</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = expandAroundCenter(s, i, i);</span><br><span class="line">        <span class="keyword">int</span> len2 = expandAroundCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span> &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) &#123;</span><br><span class="line">        L--;</span><br><span class="line">        R++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> R - L - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>EJS教程</title>
    <url>/EJS%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:03 GMT+0800 (China Standard Time) --><h1 id="EJS教程"><a href="#EJS教程" class="headerlink" title="EJS教程"></a>EJS教程</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在建本站的过程中需要使用到EJS语言，因此我对 <a href="https://github.com/mde/ejs/" target="_blank" rel="noopener">https://github.com/mde/ejs/</a> 这篇教程进行了翻译，一些地方增加了注解。</p><a id="more"></a><h1 id="EJS"><a href="#EJS" class="headerlink" title="EJS"></a>EJS</h1><p>EJS是一种将JavaScript中嵌入JavaScript的Web脚本语言。</p><h1 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h1><p>使用npm命令安装ejs:<br></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">$ npm install ejs</span><br></pre></td></tr></table></figure><p></p><p>特性<br>Complies with the Express view system<br>Static caching of intermediate JavaScript<br>Unbuffered code for conditionals etc &lt;% code %&gt;<br>Escapes html by default with &lt;%= code %&gt;<br>Unescaped buffering with &lt;%- code %&gt;<br>Supports tag customization<br>Filter support for designer-friendly templates<br>Includes<br>Client-side support<br>Newline slurping with &lt;% code -%&gt; or &lt;% -%&gt; or &lt;%= code -%&gt; or &lt;%- code -%&gt;</p><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (user) &#123; %&gt;</span><br><span class="line">    &lt;h2&gt;<span class="xml"><span class="tag">&lt;<span class="name">%=</span> <span class="attr">user.name</span> %&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>Try EJS online at: <a href="https://ionicabizau.github.io/ejs-playground/" target="_blank" rel="noopener">https://ionicabizau.github.io/ejs-playground/</a>.</p><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = ejs.compile(str, options);</span><br><span class="line">template(data);</span><br><span class="line"><span class="comment">// =&gt; Rendered HTML string</span></span><br><span class="line"></span><br><span class="line">ejs.render(str, data, options);</span><br><span class="line"><span class="comment">// =&gt; Rendered HTML string</span></span><br><span class="line"></span><br><span class="line">ejs.renderFile(filename, data, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// str =&gt; Rendered HTML string</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>It is also possible to use ejs.render(dataAndOptions); where you pass everything in a single object. In that case, you’ll end up with local variables for all the passed options. However, be aware that your code could break if we add an option with the same name as one of your data object’s properties. Therefore, we do not recommend using this shortcut.</p><h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><ul><li>cache Compiled functions are cached, requires filename</li><li>filename The name of the file being rendered. Not required if you are using renderFile(). Used by cache to key caches, and for includes.</li><li>root Set project root for includes with an absolute path (/file.ejs).</li><li>context Function execution context</li><li>compileDebug When false no debug instrumentation is compiled</li><li>client When true, compiles a function that can be rendered in the browser without needing to load the EJS Runtime (ejs.min.js).</li><li>delimiter Character to use with angle brackets for open/close</li><li>debug Output generated function body</li><li>strict When set to true, generated function is in strict mode</li><li>_with Whether or not to use with() {} constructs. If false then the locals will be stored in the locals object. Set to false in strict mode.</li><li>destructuredLocals An array of local variables that are always destructured from the locals object, available even in strict mode.</li><li>localsName Name to use for the object storing local variables when not using with Defaults to locals</li><li>rmWhitespace Remove all safe-to-remove whitespace, including leading and trailing whitespace. It also enables a safer version of -%&gt; line slurping for all scriptlet tags (it does not strip new lines of tags in the middle of a line).</li><li>escape The escaping function used with &lt;%= construct. It is used in rendering and is .toString()ed in the generation of client functions. (By default escapes XML).</li><li>outputFunctionName Set to a string (e.g., ‘echo’ or ‘print’) for a function to print output inside scriptlet tags.</li><li>async When true, EJS will use an async function for rendering. (Depends on async/await support in the JS runtime.</li><li>This project uses JSDoc. For the full public API documentation, clone the repository and run npm run doc. This will run JSDoc with the proper options and output the documentation to out/. If you want the both the public &amp; private API docs, run npm run devdoc instead.</li></ul><h1 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h1><ul><li>&lt;% ‘Scriptlet’ tag, for control-flow, no output</li><li>&lt;%_ ‘Whitespace Slurping’ Scriptlet tag, strips all whitespace before it</li><li>&lt;%= Outputs the value into the template (escaped)</li><li>&lt;%- Outputs the unescaped value into the template</li><li>&lt;%# Comment tag, no execution, no output</li><li>&lt;%% Outputs a literal ‘&lt;%’</li><li>%%&gt; Outputs a literal ‘%&gt;’</li><li>%&gt; Plain ending tag</li><li>-%&gt; Trim-mode (‘newline slurp’) tag, trims following newline</li><li>_%&gt; ‘Whitespace Slurping’ ending tag, removes all whitespace after it</li></ul><p>For the full syntax documentation, please see docs/syntax.md.</p><h2 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h2><p>Includes are relative to the template with the include statement, for example if you have “./views/users.ejs” and “./views/user/show.ejs” you would use &lt;% include user/show %&gt;.<br>You must specify the filename option for the template with the include call unless you are using renderFile().</p><p>You’ll likely want to use the raw output tag (&lt;%-) with your include to avoid double-escaping the HTML output.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% users.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>)</span>&#123; %&gt;</span><br><span class="line">    &lt;% include user/show %&gt;</span><br><span class="line">  &lt;% &#125;) %&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure><p>Includes are inserted at runtime, so you can use variables for the path in the include call (for example &lt;%- include(somePath) %&gt;). Variables in your top-level data object are available to all your includes, but local variables need to be passed down.</p><p>NOTE: Include preprocessor directives (&lt;% include user/show %&gt;) are still supported.</p><h2 id="Custom-delimiters"><a href="#Custom-delimiters" class="headerlink" title="Custom delimiters"></a>Custom delimiters</h2><p>Custom delimiters can also be applied globally:</p><p>let ejs = require(‘ejs’),<br>users = [‘geddy’, ‘neil’, ‘alex’];</p><p>// Just one template<br>ejs.render(‘&lt;?= users.join(“ | “); ?&gt;’, {users: users}, {delimiter: ‘?’});<br>// =&gt; ‘geddy | neil | alex’</p><p>// Or globally<br>ejs.delimiter = ‘$’;<br>ejs.render(‘&lt;$= users.join(“ | “); $&gt;’, {users: users});<br>// =&gt; ‘geddy | neil | alex’</p><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>EJS ships with a basic in-process cache for caching the intermediate JavaScript functions used to render templates. It’s easy to plug in LRU caching using Node’s lru-cache library:</p><p>let ejs = require(‘ejs’),<br>LRU = require(‘lru-cache’);<br>ejs.cache = LRU(100); // LRU cache with 100-item limit<br>If you want to clear the EJS cache, call ejs.clearCache. If you’re using the LRU cache and need a different limit, simple reset ejs.cache to a new instance of the LRU.</p><p>var ejs = require(‘ejs’);<br>ejs.open = ‘; ejs.close = ‘;:<br>Which would make the following a valid template:</p><h2 id="Client-side-support"><a href="#Client-side-support" class="headerlink" title="Client-side support"></a>Client-side support</h2><p>Go to the Latest Release, download ./ejs.js or ./ejs.min.js. Alternately, you can compile it yourself by cloning the repository and running jake build (or $(npm bin)/jake build if jake is not installed globally).</p><p>Include one of these files on your page, and ejs should be available globally.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"output"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"ejs.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> people = [<span class="string">'geddy'</span>, <span class="string">'neil'</span>, <span class="string">'alex'</span>],</span><br><span class="line">      html = ejs.render(<span class="string">'&lt;%= people.join(", "); %&gt;'</span>, &#123;<span class="attr">people</span>: people&#125;);</span><br><span class="line">  <span class="comment">// With jQuery:</span></span><br><span class="line">  $(<span class="string">'#output'</span>).html(html);</span><br><span class="line">  <span class="comment">// Vanilla JS:</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>).innerHTML = html;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats"></a>Caveats</h3><p>Most of EJS will work as expected; however, there are a few things to note:</p><p>Obviously, since you do not have access to the filesystem, ejs.renderFile() won’t work.<br>For the same reason, includes do not work unless you use an include callback. Here is an example:<br>let str = “Hello &lt;%= include(‘file’, {person: ‘John’}); %&gt;”,<br>fn = ejs.compile(str, {client: true});</p><p>fn(data, null, function(path, d){ // include callback<br>// path -&gt; ‘file’<br>// d -&gt; {person: ‘John’}<br>// Put your code here<br>// Return the contents of file as a string<br>}); // returns rendered string<br>See the examples folder for more details.</p><h3 id="IDE-Integration-with-Syntax-Highlighting"><a href="#IDE-Integration-with-Syntax-Highlighting" class="headerlink" title="IDE Integration with Syntax Highlighting"></a>IDE Integration with Syntax Highlighting</h3><p>VSCode:Javascript EJS by DigitalBrainstem</p><h1 id="Related-projects"><a href="#Related-projects" class="headerlink" title="Related projects"></a>Related projects</h1><p>There are a number of implementations of EJS:</p><p>TJ’s implementation, the v1 of this library: <a href="https://github.com/tj/ejs" target="_blank" rel="noopener">https://github.com/tj/ejs</a><br>Jupiter Consulting’s EJS: <a href="http://www.embeddedjs.com/" target="_blank" rel="noopener">http://www.embeddedjs.com/</a><br>EJS Embedded JavaScript Framework on Google Code: <a href="https://code.google.com/p/embeddedjavascript/" target="_blank" rel="noopener">https://code.google.com/p/embeddedjavascript/</a><br>Sam Stephenson’s Ruby implementation: <a href="https://rubygems.org/gems/ejs" target="_blank" rel="noopener">https://rubygems.org/gems/ejs</a><br>Erubis, an ERB implementation which also runs JavaScript: <a href="http://www.kuwata-lab.com/erubis/users-guide.04.html#lang-javascript" target="_blank" rel="noopener">http://www.kuwata-lab.com/erubis/users-guide.04.html#lang-javascript</a><br>DigitalBrainstem EJS Language support: <a href="https://github.com/Digitalbrainstem/ejs-grammar" target="_blank" rel="noopener">https://github.com/Digitalbrainstem/ejs-grammar</a></p><h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p>Licensed under the Apache License, Version 2.0 (<a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">http://www.apache.org/licenses/LICENSE-2.0</a>)</p><p>EJS Embedded JavaScript templates copyright 2112 <a href="mailto:mde@fleegix.org" target="_blank" rel="noopener">mde@fleegix.org</a>.</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>EJS</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络课程笔记（三）</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="Lesson-3"><a href="#Lesson-3" class="headerlink" title=" Lesson 3 "></a><p align="center">Lesson 3</p></h1><p align="center">主讲老师：李伟明，于俊清</p><p>1.3 报文交换<br>直连网络存在两个问题：</p><ol><li>由于共享链路，所以仅仅允许少量的节点连接到网络， 例如早期的以太网最多不超过1024个节点</li><li>仅仅能分布在很小的范围，早期以太网距离不超过2500m<br>所以出现Packet Switch这样的设备，将多个直连网络连接起 来，组建更大范围的网络。</li></ol><p>而且交换机提供了另外一个好处：每个host到Switch是独立的带宽。所 以后来进一步，有的时候干脆通过Packet Switch直接将多个主机连接， 组合成交换网络。<br><a id="more"></a><br><img src="/现代计算机网络课程笔记（三）/1.png" alt></p><p><img src="/现代计算机网络课程笔记（三）/2.png" alt></p><p>多个Packet Switch连接起来后，马上就需要解决如何确定转发路径 的问题，每个交换机需要建立一个forwarding table（通过自学习的方法建立一个分组交换表）</p><p><img src="/现代计算机网络课程笔记（三）/3.png" alt></p><p>教科书3.1节介绍了三种交换的方法：</p><ol><li>Datagram (or connectionless) model</li><li>Virtual Circuit Switching（ATM）</li><li>Source Routing</li></ol><p>我们重点介绍是交换式以太网使用的第一种方法，也是TCP/IP默认的 通信子网连接方式</p><p>1975年纯ALOHA原始Ethernet：单工竞争系统，基本思想：</p><ul><li>无连接，先说后听，想发就发，错了重发；</li><li>对数据帧不编号，不要求对方发回确认；不可靠交付，尽力而为</li><li>建立在近距离、信道出错概率小–&gt;局域网 + 随机接入协议（发展）</li><li>普通ALHOA和Time sloted ALHOA + CSMA（载波侦听多路访问）：先听后说+指数退避 + 1坚持CSMA、非坚持CSMA、P坚持CSMA + CSMA/CD：多点接入、载波监听、碰撞检测 + 信道效率：传送距离越短，发送帧时T0越长，效率越高 + 以太网优势 + 可扩展（10M—10G），灵活（多种媒介、全/半双工、共享/交换），便宜、 易于安装使用、稳健性好。</li></ul><p>网卡功能</p><ul><li>数据的封装与解封 + 链路管理：CSMA/CD + bit的编码与解码</li><li>MAC地址</li><li>Unicast:单播帧地址,仅对某个网卡</li><li>Broadcast:广播帧地址,仅对某个子网</li><li>Multicast:多播帧地址,组地址</li><li>杂收模式：Promiscuous mode:接收总线上所有的可能接收的帧</li></ul><h1 id="高速局域网：快速以太网100Mbps"><a href="#高速局域网：快速以太网100Mbps" class="headerlink" title="高速局域网：快速以太网100Mbps"></a>高速局域网：快速以太网100Mbps</h1><p>对10Mbps 802.3 LAN的改进 + 局域网发展史上重要里程碑</p><ul><li>Fast Ethernet标准 + 1995年，IEEE通过802.3u标准，实际上是802.3的一个补充。 原有的帧格式、接口、规程不变，只是将每比特时间从100ns 缩短为10ns。</li></ul><p><img src="/现代计算机网络课程笔记（三）/4.png" alt></p><ul><li>100Base-TX + 使用2对5类平衡双绞线或150屏蔽平衡电缆，1对 to the hub，1对from the hub，支持全双工；</li><li>5类双绞线使用125 MHz的信号；</li><li>4B/5B编码，5个时钟周期发送4个比特，物理层与FDDI兼容使用NRZ-I编码 ，比特率为125 * 4/5 = 100 Mbps；</li><li>100Base-FX + 使用2根多模光纤，支持全双工，物理层和FDDI兼容 + 100Base-T4（4根线收发） 和 100Base-TX（2根线收发） 统称 100Base-T</li><li>两种类型的HUB</li><li>共享式HUB，一个冲突域，工作方式与802.3相同，CSMA/CD，二进制指数 后退算法，半双工 … + 交换式HUB，输入帧被缓存，一个端口构成一个冲突域。</li></ul><p>随着网络速度的提高，共享信道方式越来越不适应发展</p><ul><li>共享信道跟全双工是矛盾的</li><li>100Base-FX在半双工模式下，为了兼容以太网报文，为了确保检测到碰 撞，最大长度为412米。但是在全双工模式下，则可达到2000m，如果用 Repeater，可以到10公里</li><li><p>共享信道意味着所有主机在一个冲突域，主机数量一多冲突的概率大大 增加。</p><ul><li>工作方式<ul><li>IEEE 802.3定义的10M/100M以太网一致的CSMA/CD帧格式</li><li>以太网交换机（全双工模式）中的千兆端口不能采用共享信道方式访问 介质，不使用 CSMA/CD 协议，而只能采用全双工方式.</li><li>在使用双绞线的情况下，可以通过自动协商机制，切换到半双工方式下 仍使用 CSMA/CD 协议</li><li>编码采用8b/10b encoding和NRZ</li><li>双绞线很少用，因为同时5对线收发产生串扰</li></ul></li></ul></li></ul><p><img src="/现代计算机网络课程笔记（三）/5.png" alt></p><ul><li>PAUSE协议<ul><li>规范发展完善了PAUSE协议，不采用CSMA/CD协议完成全双工操作。</li><li>该协议采用不均匀流量控制方法，最先应用于100M以太网中。</li></ul></li><li><p>流控</p><ul><li>利用802.3定义的Pause控制帧进行流量控制，要求发送数据节点暂停 数据发送，避免缓冲区溢出造成的丢包。</li><li>只有在全双工时，才支持Pause流控，半双工时不支持流控</li></ul></li><li><p>2002.6月正式发布802.3ae 10GE标准</p><ul><li>只全双工，不支持单工和半双工，也不采用CSMA/CD</li><li>不持自协商；提供广域网物理层接口。</li></ul></li><li>长距离(40-50KM)网络<ul><li>扩展了网络的覆盖区域，且标准简化。</li><li>支持现存的大量SONET网络兼容</li></ul></li><li><p>两种物理层技术：</p><ul><li>局域网物理层LAN PHY；10.000Gbps精确10G；</li><li>广域网物理层WAN PHY；OC-192，异步SONET/SDH</li><li>与10M/100M/1000Mbps帧格式完全相同；</li></ul></li><li><p>以太网封装比SONET/ SDH更简单且成本更低</p></li><li>40 Gbps已成为过渡产品</li><li>2010年6月22日， IEEE802.3ba和100Gb/s以 太网技术标准已经正式获 审通过。</li><li>国内华为、中兴；国外 Juniper Network、 CISCO；上海贝尔已经开 发出了自有标准100Gbps 以太网接口路由器</li></ul><p><img src="/现代计算机网络课程笔记（三）/6.png" alt><br><img src="/现代计算机网络课程笔记（三）/7.png" alt></p><ul><li>以太网可以是一组直连的主机</li><li>以太网也可以通过网桥（bridge）、集线器（HUB）、交换机 (Switch)这些连接设备进行扩展</li></ul><p>以太网的连接设备</p><ul><li>集线器（HUB）:物理层互连设备<ul><li>1进多出，相同速率，无帧缓冲/线障 隔离，使用方便</li><li>带宽受限 ，广播风暴 ，单工传输， 通信效率低</li></ul></li><li><p>交换机（Switch）：链路层互连 设备</p><ul><li>依帧头信息转发以太帧；</li><li>实现方法<ul><li>直接交换方式</li><li>存储转发方式</li><li>改进直接交换方式。<br><img src="/现代计算机网络课程笔记（三）/8.png" alt><br><img src="/现代计算机网络课程笔记（三）/9.png" alt></li></ul></li></ul></li><li><p>不依赖三层交换，通过虚拟局域网VLAN，可以将同一交换 机或者多个交换机的广播域划分多个广播域</p></li><li>每个虚拟局域网一个广播域</li><li><img src="/现代计算机网络课程笔记（三）/10.png" alt></li><li>最简单的情况： 右边的转发表是可以通过交换机学习自动得到的<br><img src="/现代计算机网络课程笔记（三）/11.png" alt></li></ul><ul><li>交换机的自学习机制可以工作良好，但 是一旦交换机连接存在环路，会造成严 重后果</li><li>B1, B4, and B6 form a loop</li><li>当交换机之间存在多条活动链路时，容 易形成环路，导致转发表的不正确与不 稳定，并且还会导致重复的数据包在网 络中传递，引起广播风暴，使网络不稳 定。<br><img src="/现代计算机网络课程笔记（三）/12.png" alt></li></ul><p>1.3.3 交换机生成树协议</p><ul><li>为了防止交换机之间由于多条活动链路而导致的网络故障，必须将多 余的链路置于非活动状态，即不转发用户数据包，而只留下单条链路 作为网络通信。</li><li>要实现此功能，需要依靠生成树协议（Spanning Tree Protocol）来 完成，STP将交换网络中任何两个点之间的多余链路置于Blocking（ 关闭）状态，而只留一条活动链路，当使用中的活动链路失效时，立 即启用被Block的链路，以此来提供网络的冗余效果。</li></ul><p>1.3.3 交换机生成树协议</p><ul><li>从理论上一个LAN可以看作一个图graph，这个图可能循环 (cycles)</li><li>spanning tree实际是这个图的一个子图sub-graph，但是可以到达 所有节点</li></ul><p><img src="/现代计算机网络课程笔记（三）/13.png" alt></p><p>1.3.3 交换机生成树协议<br>Spanning Tree协议</p><ul><li>需要所有交换机支持</li><li>IEEE 802.1 标准规定了LAN 交换机必须支持</li><li><p>每个交换机实际上需要disable掉自己的某些端口，不转发frame + 极端情况下，可能一个交换机完全不参与任何frame的转发</p></li><li><p>STP为IEEE标准协议，并且有多个协议版本，版本与协议 号的对应关系如下：</p><ul><li>Common Spanning Tree (CST) = IEEE 802.1D + Rapid Spanning Tree Protocol (RSTP)=IEEE 802.1w + Per-VLAN Spanning-Tree plus (PVST+)=Per-VLAN IEEE 802.1D + Rapid PVST+=Per-VLAN IEEE 802.1w</li><li><p>Multiple Spanning Tree Protocol (MSTP)=IEEE 802.1s</p></li><li><p>去掉环路的方法：所有交换机按照树的方式进行连通</p></li><li>STP的核心思想是网络中选出一台交换机做为核心交换机，STP称其为Root， 也就是根，功能相当于hub-spoke网络中的Hub。</li><li>其它不是Root的交换机则需要留出一条活动链路去往根交换机，因为只要普通 交换机到根是通的，到其它交换机也就是通的。</li></ul></li></ul><p><img src="/现代计算机网络课程笔记（三）/14.png" alt></p><ul><li>只有在一个广播能够到达的范围内，才需要进行相同的STP计算与选举 ，也就是一个广播域内独立选举STP</li><li>下图中网络被路由器分割成两个广播域，所以在两个网段中，需要进行 独立的STP计算与选举。<br><img src="/现代计算机网络课程笔记（三）/15.png" alt></li></ul><p>+交换机之间选举根交换机（Root）</p><ul><li>一个广播域内只能选举一台根交换机。Birdge-ID中优先级最高（即数 字最小）的为根交换机，优先级范围为0-65535，如果优先级相同，则 MAC地址小的为根交换机。<ul><li>交换机端口之间选举根交端口（Root Port）</li></ul></li><li>所有非根交换机都要选举根端口，选举规则为到根交换机的Path Cost 值最小的链路。 非根交换机选择指定端口(Designated Port) + 简单地理解为每条连接交换机的link有两个端口（属于不同交换机）中 ，有一个要被选举为指定端口。</li><li>选举规则和选举根端口一样，即：到根交换机的Path Cost值最小的端 口，如果多条链路到达根交换机的Path Cost值相同，则选举上一跳交 换机Bridge-ID最小的链路。</li></ul><ul><li>剩余端口状态为Blocking<ul><li>在STP选出根交换机，根端口以及指定端口后，其它所有端口全部为 Blocking状态，为了防止环路，所有Blocking端口只有在根端口或指 定端口失效、拓扑改变的时候才会被启用。</li><li>一个端口，在STP中只能处于一种角色，不可能是两种角色</li></ul></li></ul><p>BPDU（Bridge Protocol Data Unit） 交换机间用BPDU报文来选举，目的地址为layer 2 multicast address 01:80:C2:00:00:00 ：</p><ul><li>Protocol ID 固定为0。</li><li>Version：0为802.1d，1为802.1w，2为 802.1s。</li><li>Message type：0为普通BPDU，80为TCN（ Topology Change Notification）。</li><li>Flags字段：802.1d时只用到0位和7位，都和 TCN相关，TCN的ACK报文里0位置1，TC报 文里7位置1。</li><li>Root ID，Cost of path，Bridge ID，Port ID ：用于选举。<br><img src="/现代计算机网络课程笔记（三）/16.png" alt></li></ul><p>Path cost计算</p><ul><li>每个交换机会把自己链路的代价加上接收到 的邻居交换机的Path Cost，得到总的Path Cost。<br><img src="/现代计算机网络课程笔记（三）/17.png" alt></li></ul><ol><li>当交换机打开的时候，所有的端口都处于Listening状态，每个交换 机都会认为自己是根交换机（Root ID为自己），然后都每隔两秒就 向外发送一次自己的BPDU。</li><li>如果收到的BPDU的Bridge ID比自己的小，则停止转发自己的 BPDU，开始转发更优的BPDU，如果比自己的Bridge ID大或者和 自己的Bridge ID相等，则丢弃该BPDU。</li><li>持续15s（转发延迟）等到BPDU扩散完毕之后，开始各种端口的选 举，这时候每个BID最小的交换机成了根交换机，各个交换机通过收 到的BPDU来确定根端口和指定端口。剩下的成为非指定端口转 到blocking状态。然后进入learning状态</li><li>进入Learning状态之后，填写MAC地址表，经过15s（转发延迟） 之后进入Forwarding状态。<br>进入Forwarding状态之后，开始转发数据，并且同时接受转发来 自于根的BPDU（Root ID为根交换机），维护拓扑。这时只有根 交换机发BPDU，其他交换机都只是转发BPDU。</li><li>当一个新的交换机加入的时候，端口状态是Learning，新的交换机 认为自己是根交换机开始发送BPDU，也接收对端的BPDU，然后 进行进一步的竞选。</li><li><p>若竞选成功，则网络拓扑就重新变化了，若竞选失败则计算根端 口指定端口和非指定端口。（30s可以完成）</p><p>举一个具体例子：<br>根交换机（Root） 因为4台交换机的优先级分别为 SW1（4096） ，SW2（24576 ），SW3（32768），SW4（ 32768），选举优先级最高的 （数字最低的）为根交换机， 所以SW1被选为根交换机，如 果优先级相同，则比较MAC地 址。</p></li></ol><p>所有链路为100 Mb/s，即Path Cost值为19；128为port ID<br><img src="/现代计算机网络课程笔记（三）/18.png" alt></p><p>根端口（Root port） 根端口需要在除SW1外的非根交换机 上选举。</p><ul><li>SW2上从端口F0/23到达根的Path Cost值为19，从F0/19和F0/20到达 根的Path Cost值都为19×3=57。 因此，F0/23被选为根端口。</li><li>SW3上F0/19被选为根端口。</li><li>SW4上从所有端口到达根的Path Cost值都为19×2=38，接下来比较 上一跳交换机Bridge-ID，选择SW2 ，再比较对端端口优先级，选择 F0/20<br><img src="/现代计算机网络课程笔记（三）/19.png" alt></li></ul><p>指定端口（Designated port）</p><ul><li>根交换机上所有的端口都应该是指 定端口。</li><li>在SW3连接SW4的两个网段中，同 样也是SW3上的两个端口离根交换 机最近，所以在这两个网段中，选 举SW3上的端口为指定端口。</li><li>在SW2连接SW4的两个网段中，同 样也是SW2上的两个端口离根交换 机最近，所以在这两个网段中，选 举SW2上的端口为指定端口。<br><img src="/现代计算机网络课程笔记（三）/20.png" alt></li></ul><p>总结：</p><ul><li>根交换机（Root） SW1</li><li>根端口（Root Port） SW2：F0/23 SW3：F0/19 SW4： F0/20</li><li>指定端口(Designated Port) SW1：F0/19，F0/23 SW2：F0/19 ，F0/20 SW3：F0/23，F0/24</li><li>Blocking端口 SW4：F0/19，F0/23，F0/24<br><img src="/现代计算机网络课程笔记（三）/21.png" alt><br>一个根（Root）交换机上实际的STP状态：<br><img src="/现代计算机网络课程笔记（三）/22.png" alt><br>第二种类型的BPDU包：Topology Change Notification(TCN) BPDU。</li></ul><ol><li>当一台交换机检测到拓扑变化后,它就可以发送TCN给root bridge,注意 TCN是通过root port向root bridge方向发出的.</li><li>当交换机从它的designate port接收到TCN类BPDU时,它必须为其做转 发,从它自已的root port上发送出去TCN类型的BPDU包,这样一级一级 地传到root bridge后,TCN的任务才算完成.</li><li><p>在以上的过程中,无论是哪台交换机从它的designate port上收到了 TCN类型的BPDU包,它都必须给一个回复,必须从designate port上发 出TCA位被置1的normal configuration BPDU包</p></li><li><p>那么当TCN传遍全网,直至到达ROOT BRIDGE后,root bridge也要做出 一种回应,它会发出一个正常的configuration BPDU包,当然会有一些不 同,就是包内的TC字段会被置1,TC即topology change,表示发现拓扑变 化。</p></li><li>这个包会被所有交换机转发,同样的TC位会置1,直至传遍全网,所有交 换机都得知拓扑变化为止，原来转发表作废，重新开始选举。</li></ol><p>其他问题：</p><ul><li>如何加快STP的选举速度？</li><li><ul><li>如何根据VLAN虚拟局域网进行优化？</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>【论文注解】Embedding Multimodal Relational Data for Knowledge Base Completion</title>
    <url>/%5B%E8%AE%BA%E6%96%87%E6%B3%A8%E8%A7%A3%5DEmbedding%20Multimodal%20Relational%20Data%20for%20Knowledge%20Base%20Completion/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在<a href="https://github.com/pouyapez/mkbe" target="_blank" rel="noopener">https://github.com/pouyapez/mkbe</a>上的DesGAN实验，因为不知道代码中中间需要的.npy文件从哪里产生，因此，在对对论文进行翻译的基础上进一步进行深层次的注解。</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在嵌入空间中表示实体和关系是关系数据机器学习的一种很好的方法然而，现有的方法主要集中于有限集合的实体之间的简单链接结构，而忽略了通常在知识库中使用的数据类型的多样性，例如文本、图像和数值。在本文中，我们提出了多模态知识库嵌入（MKBE），使用不同的神经编码器的各种观察到的数据，并结合它们与现有的关系模型，以了解嵌入的实体和多模态数据。此外，利用这些学习到的嵌入和不同的神经解码器，我们引入了一种新的多模态插补模型，从知识库中的信息生成缺失的多模态值，如文本和图像我们丰富现有的关系数据集，以创建两个新的基准，包含额外的信息，如文本描述和原始实体的图像。我们证明，我们的模型利用这一额外的信息，以有效地提供更准确的链路预测，实现国家的最先进的结果与现有方法相比，有5-7%的相当大的差距。此外，我们通过用户研究评估生成的多模态值的质量我们已经在<a href="https://github.com/pouyapez/mkbe" target="_blank" rel="noopener">https://github.com/pouyapez/mkbe</a> 上发布了数据集和模型的开源实现。</p><a id="more"></a><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>知识库（knowledgebase，KB）是许多计算系统的重要组成部分，在搜索、结构化数据管理、推荐、问答和信息检索等领域有着广泛的应用然而，在不确定性条件下，知识库往往存在不完全性、条目噪声和推理效率低下等问题为了解决这些问题，学习关系知识表征一直是积极研究的重点（Bordes等人，2011、2013；Y ang等人，2015；Nickel等人，2016；Trouillon等人，2016；Dettmers等人，2018）这些方法通过从观察中学习每个实体和关系的固定的低维表示，对不确定性进行编码，并准确有效地推断缺失的事实，来表示由主体实体、关系和对象实体组成的关系三元组主题和对象实体来自知识库中出现的一组固定的、可枚举的实体。<br>然而，现实世界中的知识库除了这些直接链接之外，还包含各种各样的数据类型除了与固定实体集的关系外，知识库通常不仅包括数字属性（如年龄、日期、财务和地理信息），还包括文本属性（如名称、说明和标题/名称）和图像（剖面照片、旗帜、海报等）这些不同类型的数据可以作为知识库完成的额外证据发挥关键作用例如，文本描述和图像可以为一个人的年龄、职业和称号提供证据例如，在图1所示的多模态知识库中，图像有助于预测Carles Puyol的职业，而描述包含他的国籍不幸的是，将这些信息作为实体合并到现有的方法中是有挑战性的，因为它们通过枚举可能的值来分配每个实体不同的向量，并预测缺失的链接（或属性），如果实体来自一个小的可枚举集合，那么它们都是可能的。因此，关系建模的关键需求不仅仅是基于链路的KB完成视图，它不仅利用多模态信息来在现有实体之间进行更好的链路预测，而且能够生成丢失的多模式值。<br>在本文中，我们引入多模态知识库嵌入（MKBE）来建模包含各种数据类型（如链接、文本、图像、数值和分类值）的知识库我们建议使用神经编码器和解码器来替换任何基于嵌入的关系模型的初始层；我们将它们应用于DistMult（Y ang et al.，2015）和conv（Dettmers et al.，2018）具体来说，MKBE没有为每个实体学习一个不同的向量，而是使用枚举来预测链接，它包括以下扩展：（1）引入额外的神经编码器来嵌入关系模型用于预测链接的多模态证据类型（2）引入神经解码器，使用实体的嵌入来生成其多模态属性（如图像和文本）例如，当三元组的对象是图像时，我们使用CNN将其编码为固定长度的向量，而文本对象则使用基于RNN的序列编码器进行编码评分模块与基础关系模型保持一致；给定三元组的主语、关系和宾语的向量表示，我们使用DistMult或conv生成一个分数，指示三元组正确的概率在学习知识库表示之后，神经解码器使用实体嵌入来生成缺失的多模态属性，例如，从知识库中的结构化信息生成对人的描述这个统一的框架允许信息跨不同的关系类型（多模式或其他）流动，提供了更精确的关系数据建模。<br>我们对我们提出的方法在两个关系型知识库上进行了评估由于我们引入了多模式KB完成设置，我们提供了两个基准，通过扩展现有的Y AGO-10和MOVIELSEN-100K数据集来包括附加的关系，如文本描述、数字属性和实体的图像。我们证明，MKBE有效地利用附加信息来提高链路预测精度，在DistMult和conv评分函数的这些数据集上实现最新结果我们通过用户研究来评估解码器生成的多模态属性的质量，这些研究展示了解码器的真实性和信息内容，并给出了生成的文本和图像的示例。</p><h1 id="2-多模式知识库完成"><a href="#2-多模式知识库完成" class="headerlink" title="2. 多模式知识库完成"></a>2. 多模式知识库完成</h1><p>如前所述，KBs通常包含关于实体的不同类型的信息，包括链接、文本描述、分类属性、数值和图像在本节中，我们简要介绍了现有的关系嵌入方法，重点是使用不同的密集向量建模链接数据。然后，我们描述了将这些方法扩展到多模式设置的MKBE，即使用所有不同的信息来预测丢失的链接并输入丢失的属性来建模KB。</p><h2 id="2-1-链路预测背景"><a href="#2-1-链路预测背景" class="headerlink" title="2.1 链路预测背景"></a>2.1 链路预测背景</h2><p>知识库中的事实陈述用主语、关系和宾语的三元组hs、r、oi表示，其中s、o∈ζ是一组实体，r∈r是一组关系我们分别考虑了关系建模的两个目标：（1）训练一个机器学习模型，该模型可以对任何事实陈述的真实值进行评分；（2）预测实体之间缺少的链接在现有的方法中，一个打分函数为：x×r×r（有时为0，0），根据模型评估任何给定的事实是否为真。为了预测实体之间的链接，由于集合ζ小到可以枚举，丢失了形式hs，r，？通过枚举所有对象并使用Ψ对三元组进行评分（即假设结果实体来自已知集合）来识别i例如，在图1中，目标是预测Carles Puyol为巴塞罗那效力。<br>链接预测的许多最新进展使用了一种基于嵌入的方法；ζ中的每个实体和R中的关系被赋予不同的稠密向量，然后由Ψ来计算得分例如，在DistMult（Yang等人，2015）中，每个实体i映射到一个d维稠密向量（ei∈Rd），每个关系r映射到一个对角矩阵Rr∈Rd×d，因此，任何三重hs，r，oi的得分计算为Ψ（s，r，o）=et sRreo按照类似的思路，Conv（Dettmers et al.，2018）使用向量来表示实体和关系，e s，e o，r r∈Rd×1，然后，在e s and rr上应用CNN层后，将其与eo结合以得分三元组，即得分函数Ψ（s，r，o）是f（vec（f（[‘/es；’/rr*w]）eo其他关系嵌入方法在评分函数的设计上主要有所不同（Bordes等人，2013；Yang等人，2015；Nickel等人，2016；Trouillon等人，2016），但也有一个缺点，即为每个实体分配不同的向量，并假设可以枚举可能的对象实体在这项工作中，我们关注DistMult，因为它的简单、流行和高精度，而conv则因为它的最先进的结果。</p><h2 id="2-2-问题设置"><a href="#2-2-问题设置" class="headerlink" title="2.2 问题设置"></a>2.2 问题设置</h2><p>当面对以多模态数据形式出现的附加三元组时，链路预测的设置略有不同考虑一组所有可能的多模态对象，M，即可能的图像、文本、数值和分类值，以及多模态证据三元组，hs，r，o i，其中s∈ζ，r∈r，和o∈M。我们将多模态信息合并到KB中的目标保持不变：我们希望能够得到任何三元组hs，r，oi的真值其中o来自ζ（链路数据）或M（多模数据），并且能够预测丢失的值hs，r，？i可能来自于ζ或M（取决于r）对于图1中的示例，除了从多模态证据中预测Carles Puyol为巴塞罗那效力外，如果Carles Puyol的图像丢失，我们还希望为其生成图像。</p><p>该问题的现有方法假定对象和对象来自固定的实体集合ZEI，因此被视为该集合中的索引，其主要针对两个原因而失败于多模态设置。首先，为每个对象实体学习不同的向量并不适用于多模态值，因为它们将忽略多模态属性的实际内容例如，无法将训练期间学习到的向量归纳为可能出现在测试中的不可见值；这对于标准设置来说不是问题，因为假设在训练期间观察到了所有实体其次，为了预测丢失的多模态值，hs，r，？枚举是不可能的，因为搜索空间可能是无限的（或者至少是难以搜索的）。</p><h2 id="2-3-多模式KB嵌入（MKBE）"><a href="#2-3-多模式KB嵌入（MKBE）" class="headerlink" title="2.3 多模式KB嵌入（MKBE）"></a>2.3 多模式KB嵌入（MKBE）</h2><p>为了将这样的多模态对象集成到现有的关系模型中，例如，我们建议学习这些类型的数据的嵌入。我们利用深度学习的最新进展来构造这些对象的编码器来表示它们，本质上为任何对象值提供了一个嵌入的eo。</p><p>总体目标保持不变：模型需要利用不同数据类型中所有观察到的主题、对象和关系，以估计任何事实hs、r、oi是否成立我们在图2a中给出了一个包含Y个AGO实体的知识库的MKBE实例。对于任何三元组hs、r、oi，我们使用直接查找嵌入主题（Carles Puyol）和关系（例如playsFor、wasBornOn或playsFor）对于对象，根据域（分别为索引、字符串、数字或图像），我们使用适当的编码器来计算其嵌入eo在DistMult和conver中，这些嵌入用于计算三元组的分数。</p><p>通过这些神经编码器，该模型可以利用多模态对象的信息量来预测对象来自ζ的丢失链路，然而，学习M中对象的嵌入不足以产生丢失的多模态值，即hs、r、，？因此，我们引入了一组神经解码器D:ζ×R→M，它使用实体嵌入来生成多模态值图2b描绘了我们估算缺失值模型的概要。我们将在第2.5节描述这些解码器。</p><h2 id="2-4-编码多模数据"><a href="#2-4-编码多模数据" class="headerlink" title="2.4 编码多模数据"></a>2.4 编码多模数据</h2><p>这里我们描述了我们用于多模态对象的编码器图2a提供了一个简单的MKBE示例，如图所示，我们使用不同的编码器嵌入每个特定的数据类型。<br>结构化知识是以hs，r，oi形式存在的三元组信息为了将主题实体s和关系r表示为独立的嵌入向量（如前所述），我们将它们的一个热编码通过密集层此外，对于对象实体是分类的情况，我们通过最近引入的selu激活（Klambauer et al.，2017）将其嵌入到密集层中，节点数与嵌入空间维度相同。<br>实数形式的数字对象可以提供有用的信息源，而且通常很容易获得在标准化输入之后，我们使用一个前馈层来嵌入数字（事实上，我们将数字从R→Rd投影到更高的维空间）值得注意的是，现有的方法将数字视为不同的实体，例如，学习数字39和40的独立向量，依靠数据来了解这些值彼此相似。<br>文本由于文本可以用来存储各种不同类型的信息，例如名称和段落长的描述，我们根据所涉及字符串的长度创建不同的编码器对于相当短的属性，例如名称和标题，我们使用基于字符的堆叠双向GRU对它们进行编码，类似于V erga等人（2016），使用顶层的最终输出作为字符串的表示对于更长的字符串，例如由多个句子组成的实体的详细描述，我们将它们视为一个单词序列，并在单词嵌入上使用CNN，类似于Francis Landau等人（2016年），以了解这些价值观的嵌入这两个编码器提供了一个固定长度的编码，已被证明是多个任务字符串的精确语义表示（Dos Santos和Gatti，2014）。<br>图像还可以为实体建模提供有用的证据例如，我们可以从人的图像（利维和Hassner，2015）中提取人的细节，例如性别、年龄、工作等，或者从地图图像（Wyand等人，2016）的位置信息，如它的近似坐标、相邻位置和大小。多种模型被用来紧凑地表示图像中的语义信息，并成功地应用于图像分类、字幕（Karpathy and Fei Fei，2015）和问答（Yang et al.，2016）等任务为了嵌入图像，使编码代表这样的语义信息，我们使用Imagenet上VGG预训练网络的最后一个隐藏层（Simonyan和Zisserman，2015），然后使用紧致双线性池（Gao等人，2016）来获得图像的嵌入。<br>训练我们遵循Dettmers等人的设置（2018）包含二元交叉熵损失，对流和DisMult评分均无负采样特别是，对于给定的subjectrelation对（s，r），我们使用一个二进制标签向量ts，rover all entities，指示在训练期间是否观察到hs，r，oi进一步，我们用ps，r o来表示任何三元组hs，r，oi的模型的真值概率，用s，r，o来表示因此，二元交叉熵损失定义为：<br>对于多模态三元组，我们也使用相同的损失，只是总和仅限于相同模态的对象，即对于实体及其文本描述，ts，ris是训练期间观察到的所有描述的一个热向量。</p><h2 id="2-5-解码多模数据"><a href="#2-5-解码多模数据" class="headerlink" title="2.5 解码多模数据"></a>2.5 解码多模数据</h2><p>在这里，我们描述了用于从实体的嵌入生成多模态值的解码器多模输入模型如图2b所示，该模型使用不同的神经解码器生成缺失属性（更多细节见补充材料）。<br>为了恢复缺失的数字和分类数据，如日期、性别和职业，我们在实体嵌入上使用简单的前馈网络来预测缺失的属性换句话说，我们在问模型，如果一个实体的实际出生日期不在KB中，那么考虑到其余的关系信息，最有可能的日期是什么这些解码器使用第2.4节中的嵌入进行训练，具有适当的损失（RMSE表示数值，交叉熵表示类别）。<br>文本一些方法考虑了生成性对抗网络（GANs）来生成语法和语言上连贯的句子（Y u et al.，2017；Rajeswar et al.，2017；Guo et al.，2017）在这项工作中，我们使用逆正则化自动编码器（ARAE）（Zhao等人，2017）来训练从连续码解码文本的生成器，但是，我们不使用随机噪声向量z，而是将生成器设置在实体嵌入上。<br>图像类似于文本恢复，为了找到处理图像，我们使用条件GAN结构具体来说，我们将BE-GAN（Berthelot et al.，2017）结构与pix2pix-GAN（Isola et al.，2017）模型相结合，生成高质量的图像，使生成器在知识库表示中嵌入实体。</p><h1 id="3-相关工作"><a href="#3-相关工作" class="headerlink" title="3. 相关工作"></a>3. 相关工作</h1><p>关于使用低维表示对知识库建模的文献非常丰富，不同的是用于对三元组进行评分的运算符特别是，他们使用矩阵和张量乘法（Nickel等人，2011年；Y ang等人，2015年；Socher等人，2013年）、欧几里德距离（Bordes等人，2013年；Wang等人，2014年；Lin等人，2015年）、循环相关（Nickel等人，2016年）或Hermitian点积（Trouillon等人，2016年）作为评分函数然而，所有这些方法的对象都是一组固定的实体，即它们只嵌入实体之间的结构化链接这里，我们在编码组件中将不同类型的信息（文本、数值、图像等）视为关系三元组。<br>许多方法利用额外类型的信息作为实体的观察特征，通过合并、连接或平均实体及其特征来计算其嵌入，例如数值（Garcia Duran和Niepert2017年）（我们使用这项工作中的KBLN将其与仅使用数值作为额外属性的方法进行比较）、图像（Xie等人，2017年；Oenoro Rubio等人，2017年）（我们使用第一项工作中的IKRL将其与仅使用图像作为额外属性的方法进行比较）、文本（McAuley和Leskovec，2013年；Zhong等人，2015年；Toutanova等人，2015年2016；Xie等人，2016；Tu等人，2017），以及文本和图像的组合（Sergieh等人，2018）此外，V erga等人（2016）解决多语言关系提取任务，通过将不带注释的原始文本作为额外特征，并使用矩阵分解联合嵌入知识库和文本关系，获得通用模式（Riedel等人，2013）除了将额外信息视为特征外，图嵌入方法（Schlichtkrull等人，2017；Kipf和Welling，2016）在编码时考虑观察到的属性，以实现更精确的嵌入。<br>MKBE与上述方法的区别在于三个方面：（1）我们首先在一个统一的模型中使用不同类型的信息，（2）我们将这些不同类型的信息（数字、文本、图像）视为结构化知识的关系三元组，而不是预先确定的特征，即知识库的一级公民而不是辅助特征，（3）我们的模型表示它们中的不确定性，支持缺失值并促进缺失值的恢复。</p><h1 id="4-评价基准"><a href="#4-评价基准" class="headerlink" title="4. 评价基准"></a>4. 评价基准</h1><p>为了评估我们的多模态关系嵌入方法的性能，我们通过扩展现有的数据集来提供两个新的基准。表1提供了这些数据集的统计信息。<br>MovieLens-100k数据集（Harper和Konstan，2016）是推荐系统中一个流行的基准，用于预测具有上下文特征的用户评分，包含1700部电影中的约1000名用户MovieLens已经包含了关于职业、性别、邮政编码、用户年龄、类型、发行日期和电影标题的丰富关系数据我们用从TMDB（<a href="https://www.themoviedb.org/）收集的电影海报来补充这些数据我们将5点评分作为5种不同的关系，采用KB三重格式，即huser，r=5，moviei，并在引入其他关系的情况下对评分预测进行评估。" target="_blank" rel="noopener">https://www.themoviedb.org/）收集的电影海报来补充这些数据我们将5点评分作为5种不同的关系，采用KB三重格式，即huser，r=5，moviei，并在引入其他关系的情况下对评分预测进行评估。</a><br>Y AGO-10尽管MovieLens有多种数据类型，但它仍然很小，而且是在一个专门的域上我们还考虑了第二个数据集，该数据集更适合于知识图的完成，并且在链路预测中很受欢迎，即Y AGO3-10知识图（Suchanek等人，2007；Nickel等人，2012）该图由大约120000个实体（如人员、位置和组织）和37个关系（如亲属关系、工作关系和居住关系）组成，因此更接近于传统的信息提取目标我们使用DBpedia提供的文本描述（作为附加关系）和与每个实体相关联的图像（用于一半实体）扩展了这个数据集（Lehmann等人，2015）我们还包括一些附加关系，比如wasBornOnDate，它们的值是日期。</p><h1 id="5-实验结果"><a href="#5-实验结果" class="headerlink" title="5. 实验结果"></a>5. 实验结果</h1><p>在这一部分中，我们首先通过比较DistMult和conver在各种任务中的使用情况来评估MKBE利用多模态信息的能力然后，以恢复丢失的多模态值（文本、图像和数值）为动机，我们检验了模型的生成能力补充材料中提供了超参数和模型配置的详细信息，可在<a href="https://github.com/pouyapez/mkbe上获取源代码和用于再现结果的数据集。" target="_blank" rel="noopener">https://github.com/pouyapez/mkbe上获取源代码和用于再现结果的数据集。</a></p><h2 id="5-1-链路预测"><a href="#5-1-链路预测" class="headerlink" title="5.1 链路预测"></a>5.1 链路预测</h2><p>在本节中，我们将评估MKBE在链路预测任务中的能力目标是计算MRR和Hits@metric（排名评估），通过对所有实体进行排名并计算正确实体的排名，从测试数据集中的三个实体中恢复丢失的实体与前面的工作类似，这里我们专注于在过滤设置中提供结果，也就是说，我们只将测试数据中的三元组与从未出现在列车或测试数据集中的三元组进行比较。<br>MovieLens-100k我们使用评分作为用户和电影之间的关系来训练模型我们对电影标题使用字符级GRU，对年龄、邮政编码和发行日期使用单独的前馈网络，最后，我们在海报上使用VGG网络（对于使用密集层的其他关系）表2显示了当测试数据仅由三个评级组成时，MovieLens的链接（评级）预测估值我们通过对表示评级而不是对象实体的五个关系进行排序来计算度量我们将使用分级的模型标记为R，电影属性标记为M，用户属性标记为U，电影标题标记为T，海报标记为P如图所示，R+M+U+T模型的性能优于其他模型，但存在相当大的差距，表明了合并额外信息的重要性基线的命中率为1，匹配现有的推荐系统（Guime*等人，2012）。从这些结果中，我们可以看出，与海报相比，模特们从标题中获益更多。<br>YAGO-10我们的Y AGO数据集的链接预测结果如表3所示我们使用结构化信息标记模型为S，实体描述为D，数字信息标记为N，实体图像标记为I。我们发现编码所有类型信息的模型比其他模型表现得更好，这表明该模型在利用额外信息方面是有效的另一方面，只使用文本的模型性能次优，这表明实体描述包含的信息比其他模型更多值得注意的是，模型S的性能优于所有其他模型，这表明了使用不同数据类型以获得更高精度的重要性这一观察结果在DistMult和conv上都是一致的，conv上获得的结果是该数据集的新技术状态（与Dettmers等人相比）（2018年）。此外，我们还实现了KBLN（Garcia Duran和Niepert，2017）和IKRL（Xie等人，2017），将它们与我们的S+N和S+I模型进行比较我们的模型优于这些方法，部分原因是这两种方法在每个三元组中的主语和宾语都需要相同的多模态属性。<br>关系分解我们对Y AGO数据集执行额外的分析，以便使用表5：预测Y AGO（日期）和MovieLens（流派）的数量和类别，使用具有不同信息访问权限的模型，更深入地了解我们模型的性能。<br>对流法表4比较了我们的模型中一些最常见的关系如图所示，包含文本描述的模型对于关联和关系的播放有显著的好处，因为这些信息经常出现在文本中此外，图像对于hassegend和isMarriedTo是有用的，而对于不相关的关系，数字（日期）比图像更有效。</p><h2 id="5-2-输入多模态属性"><a href="#5-2-输入多模态属性" class="headerlink" title="5.2 输入多模态属性"></a>5.2 输入多模态属性</h2><p>在这里，我们提出了一个关于输入多模态属性（文本，图像和数字）的评估。<br>数值和分类表5a显示了预测数据中缺失数值的性能，通过保留10%的数据进行评估我们只考虑最近于公元1000年的数值（日期），以关注更相关的实体除了神经解码器，我们还通过考虑区间[10002017]中所有1017个选项来训练基于搜索的解码器，并且对于测试数据中的每三个选项，找到模型得分最高的数字；我们使用这个值来计算RMSE。我们可以看到，在这两个数据集中，所有信息都优于其他方法演示MKBE能够利用不同的多模态值来模拟数值信息此外，神经解码器的性能优于基于搜索的解码器，显示了正确解码器的重要性，即使对于有限的可枚举集也是如此同样，表5b显示了10%heldout MovieLens数据集的类型预测精度同样，使用所有信息的模型优于其他方法。<br>电影片名的生成，我们随机选取其中200个作为测试，100个作为验证，其余的作为训练数据这里的目标是使用前面提到的GAN结构在测试数据中生成电影的标题为了评估我们的结果，我们在Amazon Mechanical Turk（AMT）上进行了一个人体实验，询问参与者两个问题：（1）他们是否发现电影标题是真实的，以及（2）四种类型中哪一种最适合给定的标题我们将30部电影分别视为参考片名，将仅由收视率产生的假片名视为条件数据，并将所有信息视为假片名此外，每个问题都是针对3名参与者提出的，在大多数选择中计算出的结果如表6所示使用所有信息生成的伪标题与参考电影标题更为相似，这表明可以访问更多信息的嵌入程序可以有效地生成更高质量的标题。<br>YAGO Descriptions此处的目标是从实体的嵌入生成描述文本由于最初的描述可能很长，我们考虑少于30个标记的第一个句子，得到96405个句子我们随机考虑其中3000个作为测试，3000个作为验证，剩下的作为解码器的训练数据为了评估生成的描述的质量，以及它们是否适合实体，我们进行了一项用户研究，询问参与者是否能够从描述中猜测句子的真实性和主题实体的职业（艺人、运动员或政治家）、性别和年龄（35岁以上或以下）我们为每一个模型提供30个例子，从3个参与者提出每个问题，并计算多数票的准确性表7所示的结果表明，这些模型在向用户通知实体信息方面具有相当的能力，而且，从能够访问更多信息的嵌入生成的描述优于仅使用结构化数据的模型表8提供了生成描述的示例（除了用户研究的屏幕截图外，补充材料中还提供了更多生成描述的示例和MovieLens标题）。<br>在这里，我们评估由人类嵌入实体生成的图像的质量（31520，分为train/text）类似于描述，我们进行了一项研究，要求用户猜测图像的真实性以及主题的职业、性别和年龄我们为每个模型提供了30个例子，从3个参与者中提出每个问题，并使用多数选择。<br>表7的结果表明，基于所有信息的嵌入生成的图像对于性别和职业更为准确从图片中猜测年龄是很困难的，因为DBpedia上的图片可能与人的年龄不符，即一些年长的名人有他们年轻时的照片生成图像的示例如表9所示。</p><h1 id="6-讨论和限制"><a href="#6-讨论和限制" class="headerlink" title="6. 讨论和限制"></a>6. 讨论和限制</h1><p>关于知识库嵌入方法的一个重要问题是它们的可伸缩性虽然大KBS是所有基于嵌入的链路预测技术的问题，但MKBE并不比现有的更差，因为我们将多模式信息视为额外的三元组。具体而言，尽管多模态编码器/解码器比现有的关系模型训练更昂贵，但成本仍然是附加的，因为我们正在有效地增加训练数据集的大小。<br>除了可伸缩性之外，在使用多模态属性时几乎没有其他挑战尽管多模态证据提供了更多的信息，但是对于预测知识库的关系结构来说，这些额外数据的哪些部分是有用的并不明显，而且模型容易过度拟合MKBE基于对特定模式有效的神经编码器和解码器的设计，结果表明它能够有效地利用信息然而，仍然需要进一步研究以更有效和准确的方式捕获多模态属性的模型。<br>由于我们的输入多模态属性模型是基于GAN结构和从KB表示中学习到的嵌入，生成的属性直接受到GAN模型的能力和嵌入向量中信息量的限制尽管我们生成的属性传达了对应实体的几个方面由于我们的数据集的大小（我们的图像和文本数据集都比现有文本/图像生殖器文献中的公共数据集小），以及通过嵌入向量捕获的信息量（知识图是稀疏的），它们的质量远不是理想的。在未来，我们希望（1）扩展多模态数据集，使其具有更多的属性（使用更多Y之前的实体）；（2）不要使用学习的嵌入来生成缺少的属性，而是直接使用知识图来生成。</p><h1 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a>7. 结论</h1><p>由于需要利用文本和图像等多种信息源来实现更精确的链接预测，我们提出了一种新的多模态关系学习的神经方法我们介绍了一个链路预测模型MKBE，该模型包括（1）组合编码组件，用于联合学习实体和多模态嵌入，以对每个实体可用的信息进行编码，以及（2）使用这些实体嵌入来输入丢失的多模态值的经对手训练的解码组件我们丰富的两个现有的数据集，Y-AGO-10和MOVIELSEN-100K，与多模态信息引入基准。我们表明，MKBE，相比现有的链路预测器DistMult和CONVE，可以实现更高的准确性，链路预测利用多模态证据。此外，我们还证明了MKBE有效地结合了相关信息来生成高质量的多模态属性，如图像和文本我们已经在<a href="https://github.com/pouyapez/mkbe上发布了数据集和模型的开源实现。" target="_blank" rel="noopener">https://github.com/pouyapez/mkbe上发布了数据集和模型的开源实现。</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识嵌入</tag>
        <tag>论文注解</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络课程笔记（二）</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h3 id="1-1-5-Internet管理"><a href="#1-1-5-Internet管理" class="headerlink" title="1.1.5 Internet管理"></a>1.1.5 Internet管理</h3><p>We reject kings, presidents and voting. We believe in: rough consensus and running code. –– David D. Clark<br><img src="/现代计算机网络课程笔记（二）/1.png" alt><br>.png)<br>From 1981 to 1989, he acted as chief protocol architect in the development of the Internet</p><ul><li><p>Internet Society (ISOC): Founded in 1992, an international nonprofit professional organization that provides administrative support for the Internet. ISOC is the organizational home for the standardization bodies of the Internet.</p></li><li><p>互联网工程任务组Internet Engineering Task Force (IETF): Forum that coordinates the development of new protocols and standards. Organized into working groups that are each devoted to a specific topic or protocol. Working groups document their work in reports, called Request For Comments (RFCs).请求评议</p></li><li><p>IRTF (Internet Research Task Force): The Internet Research Task Force is a composed of a number of focused, long-term and small Research Groups.<br>Internet Architecture Board (IAB): a technical advisory group of the Internet Society, provides oversight of the architecture for the protocols and the standardization process</p></li><li><p>The Internet Engineering Steering Group (IESG): The IESG is responsible for technical management of IETF activities and the Internet standards process. Standards. Composed of the Area Directors of the IETF working groups.</p></li><li><p>IETF是各种工作组提出RFC，是互联网工程师主要活动组织</p></li><li>ISOC是非盈利组织，为IETF、IAB、IESG、IRTF提供经济和法律支持 ，但不负责具体事务，董事会选举IAB和IESG</li><li>IAB负责长期规划和对IESG投诉处理</li><li>IESG负责管理IETF，分为各个领域总监</li></ul><a id="more"></a><h4 id="网络三个基本问题："><a href="#网络三个基本问题：" class="headerlink" title="网络三个基本问题："></a>网络三个基本问题：</h4><ul><li>Who:网络与端实体的身份标识</li><li>Where:节点在网络何处</li><li>How:如何把数据传输到指定端实体<ul><li>IP、域名、端口到底由谁分配？（Who）</li><li>教课书上几种不同的说法</li></ul></li><li>Who gives the university the domain name “virginia.edu”</li><li>Who assigns it the network prefix “128.143.0.0/16”?</li><li>Who assigns port 80 as the default port for web servers?<ul><li>IANA：早期互联网编号分配机构，The functions associated with the assignment of numbers is referred to as Internet Assigned Number Authority</li><li>IANA used to be managed by Jon Postel at ISI （Information Sciences Institute）</li><li>Internet在90年代之前一直是一个为军事、科研服务的网络。在90年代初， 克林顿政府开始逐渐介入互联网日常管理。由美国国家科学基金会(NSF）为 Internet提供资金并代表美国政府与NSI公司（Network Solutions Inc.）签 定了协议，将Internet顶级域名系统的注册、协调与维护的职责从IANA转交 给了NSI。</li><li>而Internet的地址资源分配则还是交由IANA来分配，由IANA通过Regional Internet Registries (RIRs) 将地址分配到ARIN（北美地区）、RIPE（欧洲 地区）和APNIC（亚太地区），然后在由这些地区性组织将地址分配给各个 ISP。</li><li>但是，随着Internet的全球性发展，越来越多的国家对由美国独自对Internet 进行管理的方式表示不满，强烈呼吁对Internet的管理进行改革。</li><li>美国商业部在98年初发布了Internet域名和地址管理的绿皮书，认为美国政 府有对 Internet的直接管理权，因此在它发布后遭到了除美国外几乎所有国 家及机构的反对。</li><li>美国政府在征求了大量意见后，于6月5日发布了”绿皮书”的修改稿”白皮书” 。白皮书提议在保证稳定性、竞争性、民间协调性和充分代表性的原则下， 在1998年10月成立一个民间性的非盈利公司，即ICANN，开始参与管理 Internet域名及地址资源的分配。2009年ICANN和美国政府脱离关系，完全 独立</li><li>互联网名称与数字地址分配机构：The Internet Corporation for Assigned Names and Numbers (ICANN) is an internationally organized, non-profit corporation that has responsibility for Internet Protocol (IP) address space allocation, protocol identifier assignment, Top-Level Domain name system management, and root server system management functions.</li></ul></li><li>ICANN performs the IANA functions</li><li>ICANN accredits domain-name registrar for .com, .org., .net (and other domain)<ul><li>Since ICANN performs the IANA functions, it is in charge for allocating all numbers. However, the main concern is the allocation of domain names.</li><li>ICANN role is to oversee the domain-name registration system’s transition from government hands to private hands and to coordinate its decentralization and the integration into a global community.</li></ul></li></ul><h4 id="ICANN是非盈利组织，域名为什么收费？"><a href="#ICANN是非盈利组织，域名为什么收费？" class="headerlink" title="ICANN是非盈利组织，域名为什么收费？"></a>ICANN是非盈利组织，域名为什么收费？</h4><ul><li>GoDaddy在全球的9个数据中心运行着37000台服务器，这些数据中心位于亚利桑那州 、加利福尼亚州、伊利诺斯州、维吉尼亚、荷兰和新加坡。凤凰城数据中心位于亚利 桑那州：<br><img src="/现代计算机网络课程笔记（二）/3.png" alt></li><li>2013年，GoDaddy平均每天处理的超过110亿个域名系统查询。2013年 GoDaddy同样也在产权和设备上花了超过4200万美元。<br><img src="/现代计算机网络课程笔记（二）/4.png" alt><h4 id="随着Internet的发展，根域名服务器分布到了全球"><a href="#随着Internet的发展，根域名服务器分布到了全球" class="headerlink" title="随着Internet的发展，根域名服务器分布到了全球"></a>随着Internet的发展，根域名服务器分布到了全球</h4></li><li>截至2014年10月，全球有504台根服务器，被编号为A到M 共13个标号。</li><li>大部分借由任播（Anycast,RFC1546,BGP支持）技术，编 号相同的根服务器使用同一个IP，504台根服务器总共只 使用13个IP，因此可以抵抗针对其所进行的分布式拒绝 服务攻击（DDoS）。</li><li>中国大陆在北京有两台编号为L的镜像，编号为F、I、J 的镜像各一台，共5台；香港有编号为D、J的镜像各2台 ，编号为A、F、I、L的镜像各一台，共8台；台湾则有编 号为F、I、J各一台，共3台。</li></ul><h4 id="单播、组播、广播、Anycast"><a href="#单播、组播、广播、Anycast" class="headerlink" title="单播、组播、广播、Anycast"></a>单播、组播、广播、Anycast</h4><ul><li>Anycast需要BGP支持，所以服务器可以分布在不同AS</li><li>BGP路由最小单位是C类地址，所以一定要自己或ISP拥有一个C类地址，才能实现 Anycast</li><li>Ancast是UDP友好，而TCP不友好</li></ul><p><img src="/现代计算机网络课程笔记（二）/5.png" alt></p><p style="text-indent:2em">腾讯云AIA（Anycast Internet Acceleration）使用 Anycast技术对于全球访问&lt;/&gt;<br></p><p style="text-indent:2em">AIA用 Anycast 的方式同时把IP发布到多个地域，请求包根据传输协议会到达最优的 IP 发布地域，优先进入腾讯云，然后走腾讯云的内网专线到达主机，达到减少时延的效果 。IP 入口无需额外部署流量接收设备，且IP无需区分地域，简化了 DNS 部署<br></p><p><img src="/现代计算机网络课程笔记（二）/6.png" alt></p><ul><li>区域地址注册机构：Registration and management of IP address is done by Regional Internet Registries (RIRs)</li><li>Where do RIRs get their addresses from: IANA maintains a high-level registry that distributes large blocks to RIRs</li><li>RIR are administer allocation of:<br>IPv4 address blocks<br>IPv6 address blocks<br>Autonomous system (AS) numbers</li><li><p>There are currently 4 RIRs worldwide:</p><ul><li>APNIC (Asia/Pacific Region),</li><li>ARIN (North America and Sub-Sahara Africa),</li><li>LACNIC (Latin America and some Caribbean Islands)</li><li>RIPE NCC (Europe, the Middle East, Central Asia, and African countries located north of the equator).</li><li>A fifth regional registry (AfriNIC) is in formation for Africa.</li></ul></li><li><p>Working groups present their work of the Internet are published as RFC (Request for Comments). RFCs are the basis for Internet standards.</p></li><li>Not all RFCs become Internet Standards !</li><li>A typical (but not only) way of standardization is RFC 2026 and RFC 6410:<ul><li>Internet Drafts</li><li>RFC</li><li>Proposed Standard</li><li>Draft Standard (requires 2 working implementation)</li><li>Internet Standard (declared by IAB)</li></ul></li></ul><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ul><li>一局域网最大距离为2KM，对于100Byte的数据包，在带宽 为多少时，传播时延等于传输时延？512Byte的数据包呢？ （光速为3*108 M/S）</li></ul><h1 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h1><ul><li>假设在地球和月球间建立一点对点100MPS的连接，地 月距离为385,000KM，数据传播速度为光速（3<em>108 M/S）<br>A．计算最小的RTT<br>B．use the RTT as the delay , calculate the delay</em>bandwidth product for the link<br>C. 在B中计算的delay*bandwidth有何意义？<br>D．在月球照的照片，并以数字格式存在磁盘上。如果地球上的 控制中心想下载25M的最新的图形，那么从发出数据到传输完成 所要的最小时间是多少</li></ul><h2 id="1-2-Direct-Link-Networks的基本理论与技术"><a href="#1-2-Direct-Link-Networks的基本理论与技术" class="headerlink" title="1.2 Direct Link Networks的基本理论与技术"></a>1.2 Direct Link Networks的基本理论与技术</h2><h3 id="1-2-1-直连网络-Nodes"><a href="#1-2-1-直连网络-Nodes" class="headerlink" title="1.2.1 直连网络-Nodes"></a>1.2.1 直连网络-Nodes</h3><p><img src="/现代计算机网络课程笔记（二）/7.png" alt></p><p></p><p style="text-indent:2em">香农定理决定了一个链路传输能力上限<br>这个传输能力C用bps为单位，跟链路上信号的信噪比相 关（S/N，decibels or dB）<br>C = B*log2(1+S/N)</p><br>Where B = 3300 – 300 = 3000Hz, S is the signal power, N the average noise.<br>The signal to noise ratio (S/N) is measured in decibels is related to dB = 10 x log10(S/N). If there is 30dB of noise then S/N = 1000.<br>Now C = 3000 x log2(1001) = 30kbps.<br>(发射功率越高，衰减地越快)<p></p><ul><li>How can we get 56kbps?<br><img src="/现代计算机网络课程笔记（二）/8.png" alt></li></ul><h4 id="电磁波谱与媒介"><a href="#电磁波谱与媒介" class="headerlink" title="电磁波谱与媒介"></a>电磁波谱与媒介</h4><ul><li>传输媒介：<ul><li>导向媒介：电磁波被固体媒体导向传播（金属线或光纤）</li><li>非导向媒体：自由空间球面传播，常称为无线传输</li></ul></li></ul><p><img src="/现代计算机网络课程笔记（二）/9.png" alt></p><p><img src="/现代计算机网络课程笔记（二）/10.png" alt></p><h4 id="WiFi频率"><a href="#WiFi频率" class="headerlink" title="WiFi频率"></a>WiFi频率</h4><ul><li>Wi-Fi 技术被 IEEE 802.11b/g/n 定义被操作在2.4 GHz 的频率中，在其中这个 2.4 GHz 频谱被划分为14个交叠的、错列的20 MHz 无线载波信道，它们的中心 频率分别为5 MHz。802.11a/n 被操作在有更多信道的 5.0GHz 频谱中。</li><li>一些微波炉也同在2.4G频段内，其功率有在千瓦以上，这已经是Wi-Fi的万倍数 量级了</li></ul><p><img src="/现代计算机网络课程笔记（二）/11.png" alt></p><ul><li>太阳光功率密度约是1.3千瓦/平方米，GSM手机，最大发射功率为2瓦， 而平均发射功率仅为125毫瓦。当周围信号较好时，手机能够比较轻易的 获得信号，所以发射功率就 会减小，此时辐射也比较小。当周围信号不 好时，手机就会加强辐射强度，以便接受更多的信号，辐射强度也就随之 增强。</li><li>WiFi等效全向辐射功率（EIRP）在欧盟被限制为100mW</li></ul><table><thead><tr><th>线路速率Mbps</th><th>SONET符号</th><th>ITU-TSDH 符号</th><th>速率近似值</th></tr></thead><tbody><tr><td>51.840</td><td>OC-1/STS-1</td><td>STM-0</td><td></td></tr><tr><td>155.520</td><td>OC-3/STS-3</td><td>STM-1</td><td>155Mbps</td></tr><tr><td>466.560</td><td>OC-9/STS-9</td><td>STM-3</td><td></td></tr><tr><td>622.080</td><td>OC-12/STS-12</td><td>STM-4</td><td>622Mbps</td></tr><tr><td>933.120</td><td>OC-18/STS-18</td><td>STM-6</td><td></td></tr><tr><td>1244.160</td><td>OC-24/STS-24</td><td>STM-8</td><td></td></tr><tr><td>1866.240</td><td>OC-36/STS-36</td><td>STM-12</td><td></td></tr><tr><td>2488.320</td><td>OC-48/STS-48</td><td>STM-16</td><td></td></tr><tr><td>2.5Gbps</td><td>4876.460</td><td>OC-96/STS-96</td><td>STM-32</td></tr><tr><td>9953.280</td><td>OC-192/STS-192</td><td>STM-64</td><td>10Gbps</td><td></td></tr><tr><td>DWDM</td><td>40 Gbps</td><td>DWDM</td><td>100 Gbps</td></tr></tbody></table><ul><li><p>OC：Optical Carrier Synchronous Optical Networking (SONET)的传输单 位</p></li><li><p>STS:Synchronous Transport Signal SONET的帧，决定了传输速率</p></li><li><p>SDH:Synchronous Digital Hierarchy 同步光纤网通过分时来加快传 输速度，到达10G的瓶颈后引 入了分频的光波复用技术</p></li></ul><h4 id="主干线路带宽"><a href="#主干线路带宽" class="headerlink" title="主干线路带宽"></a>主干线路带宽</h4><p><img src="/现代计算机网络课程笔记（二）/12.png" alt></p><h2 id="1-2-2-编码技术"><a href="#1-2-2-编码技术" class="headerlink" title="1.2.2 编码技术"></a>1.2.2 编码技术</h2><ul><li>信号：表示信息的物理量<ul><li>模拟信号：一组特别的数据点之间及所有可能点之间都是连续的信号</li><li>数字信号：离散点构成的信号</li></ul></li><li>信号调制：修改信号的幅度、频率和相位及其组合形式来标示和携带数据信息的过程</li><li>调制的另一个原因<ul><li>我们知道链路上信噪比的重要性，影响信号的噪声在不同频率上的强度并 非完全一样。</li><li>如果能把原始信号移动到噪声频率谱上噪声强度最低的频率上去，就可以 避开本底噪声很高的区域，和其他没有被彻底屏蔽掉的干扰信号。</li><li>信号调制时，需要选择一个「载波」——这个载波就可以选择系统噪声强 度最低区域的频率。</li></ul></li><li>信号的物理层处理<ul><li>模拟-&gt;模拟；（调制）</li><li>模拟-&gt;数字；（编码）</li><li>数字-&gt;数字；（编码）</li><li>数字-&gt;模拟。（调制）</li></ul></li><li>比特的逻辑层编码<ul><li>4B/5B</li><li>8B/10B</li><li>64B/66B</li></ul></li></ul><h4 id="基带传输信号"><a href="#基带传输信号" class="headerlink" title="基带传输信号"></a>基带传输信号</h4><ul><li>未经调制的电脉冲信号呈方波形式，所占频宽从直流和 低频开始。</li><li>近距离内，基带的功率衰减不大</li><li>RS-232/Ethernet/Token Ring<br><img src="/现代计算机网络课程笔记（二）/13.png" alt><h4 id="模拟-rightarrow-数字编码"><a href="#模拟-rightarrow-数字编码" class="headerlink" title="模拟$\rightarrow$ 数字编码"></a>模拟$\rightarrow$ 数字编码</h4>PAM:Pulse Amplitude Modulation（脉冲幅度调制）  PCM:Pulse Code Modulation（脉冲码调制）也是一个 重要的模拟到数字的传换方法</li></ul><h4 id="数字-rightarrow-模拟编码"><a href="#数字-rightarrow-模拟编码" class="headerlink" title="数字$\rightarrow$模拟编码"></a>数字$\rightarrow$模拟编码</h4><ul><li>ASK:Amplitude Shift Keying</li><li>幅移键控 FSK:Frequency Shift Keying</li><li>频移键控 PSK:Phase Shift Keying</li><li>相移键控 QAM:Quadrature Amplitude Modulation</li><li>正交幅度编码（有线电视）</li></ul><h4 id="比特率与波特率"><a href="#比特率与波特率" class="headerlink" title="比特率与波特率"></a>比特率与波特率</h4><ul><li>比特率Bit Rate：bps = bit/s</li><li>每秒内传输的比特数。</li><li>波德率Baud Rate:Buad</li><li>每秒内为表示某些比特而需要的信号单元数（或码元数）</li><li>当仅当一个信号单元表示一比特时，比特率才等于波德率。</li><li>Bit Rate = log2(Bit Units)×Baud Rate</li></ul><h4 id="8-2-3-2-2相位-times2-1幅度-QAM"><a href="#8-2-3-2-2相位-times2-1幅度-QAM" class="headerlink" title="$8(2^3)=(2^2相位\times2^1幅度) -QAM$"></a>$8(2^3)=(2^2相位\times2^1幅度) -QAM$</h4><h4 id="模拟-gt-模拟调制"><a href="#模拟-gt-模拟调制" class="headerlink" title="模拟-&gt;模拟调制"></a>模拟-&gt;模拟调制</h4><h4 id="逻辑层编码"><a href="#逻辑层编码" class="headerlink" title="逻辑层编码"></a>逻辑层编码</h4><ul><li>问题：逻辑层编码显然是数字到数字的编码，为什么要啊哦做逻辑层编码?</li></ul><p>信号中肯能有连续0和连续1，造成两个不好的影响：</p><ul><li>信号平均值的飘逸</li><li><p>信号时钟的不同步</p></li><li><p>Problem with NRZ</p><ul><li>Baseline wander（)</li><li>hao</li><li>Clock Recovery</li></ul></li><li><p>改进的NRZI编码方案(对于连续1，采用跳变的方法)</p></li></ul><ul><li><p>曼彻斯特编码(频率的利用率太低，比NRZ效率低了一倍)</p><ul><li>0:low -&gt; ihigh transition</li><li>1:high-&gt;low transition</li></ul></li><li><p>如何解决NRZ和Manchester两种编码的矛盾呢?<br>4B/5B encoding</p></li></ul><ul><li>计算4B/5B编码方案效率:</li></ul><h3 id="成帧技术（Framing）"><a href="#成帧技术（Framing）" class="headerlink" title="成帧技术（Framing）"></a>成帧技术（Framing）</h3><p>Frame = 数据部分+ 发送和接受站点的物理地址 + 处理控制部分</p><h4 id="面向字节的协议"><a href="#面向字节的协议" class="headerlink" title="面向字节的协议"></a>面向字节的协议</h4><p>Bianca帧最老的方法</p><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><p>英文版(4rd)第二章</p><ul><li>第9题</li></ul><ul><li>第10题</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>在一台服务器同时部署多个CUDA环境</title>
    <url>/%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AACUDA%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p style="text-indent:2em">最近需要复现一篇关于表示学习文章的实验，因此需要在已经安装CUDA10.0, tensorflow2.0的Ubuntu18.04服务器上搭建CUDA8.0, tensorflow1.4的开发环境。因为目前虚拟机还无法对Nvidia显卡进行虚拟化，所以，我们不能通过使用Vmware或Virtue Box等虚拟机来创建适用于深度学习的CUDA环境。在这里，我推荐使用两种方法——Docker与多CUDA版本共存法，来完成CUDA基础环境配置。</p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p style="text-indent:2em">我们在这里以使用Docker安装1.4版本的Tensorflow为例，进行讲解。您还可以访问[<a href="https://hub.docker.com/]获取更多Docker镜像。" target="_blank" rel="noopener">https://hub.docker.com/]获取更多Docker镜像。</a></p><br><p style="text-indent:2em">首先，我们需要安装Docker与[Nvidia-Docker][<a href="https://github.com/NVIDIA/nvidia-docker]以支持GPU版本的Docker镜像。在此之前，主机需要实现安装Nvidia镜像，而无需安装CUDA" target="_blank" rel="noopener">https://github.com/NVIDIA/nvidia-docker]以支持GPU版本的Docker镜像。在此之前，主机需要实现安装Nvidia镜像，而无需安装CUDA</a> Tookit。</p><a id="more"></a><p style="text-indent:2em">在安装nvidia-docker之前，让我们检查 GPU 是否可用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci | grep -i nvidia</span><br></pre></td></tr></table></figure><p style="text-indent:2em">由于nvidia docker是基于docker基础之上运行的，因此需要安装原生的docker:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker</span><br></pre></td></tr></table></figure><p style="text-indent:2em">安装 nvidia-docker 可启动支持 NVIDIA® GPU 的 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Add the package repositories </span></span><br><span class="line">$ distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">$ curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">$ curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line">$ sudo systemctl restart docker</span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">验证 nvidia-docker 安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure><p style="text-indent:2em">接着，访问Docker上的Tensorflow仓库：[<a href="https://hub.docker.com/r/tensorflow/tensorflow]，选择Tags：" target="_blank" rel="noopener">https://hub.docker.com/r/tensorflow/tensorflow]，选择Tags：</a></p><p><img src="/在一台服务器同时部署多个CUDA环境/tensorflow_repo.png" alt="tensorflow仓库"></p><p>之后Tags标签页下跳转页面，选择我们需要的1.4.0-gpu镜像，点击箭头，进行复制:</p><p><img src="/在一台服务器同时部署多个CUDA环境/tf1.4.png" alt="tensorflow仓库"></p><p style="text-indent:2em">打开terminal，运行复制的命令，即可将镜像下载到本地。</p><br><p style="text-indent:2em">输入以下命令运行Tensorflow1.4.0-gpu镜像：</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">docker run --runtime=nvidia -it tensorflow/tensorflow:1.4.0-gpu bash</span><br></pre></td></tr></table></figure><p style="text-indent:2em">这个命令以-it方式运行，会在terminal退出以后中断进程。我们在实际使用时，一般希望其作为daemon进程一直运行下去</p><br><p style="text-indent:2em">在Tensorflow1.4.0-gpu镜像中集成了Jupyter 可以通过追加-p来指定Jupyter端口:</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">nvidia-docker run -it -p 8888:10000 tensorflow/tensorflow:1.4.0<span class="string">'</span></span><br></pre></td></tr></table></figure><p style="text-indent:2em">其中”:”前为容器内端口，”:”后为主机端口，-p参数相当于将容器内Jupyter端口映射到了外部主机的端口上。</p><br><p style="text-indent:2em"><br>接下来就可以通过浏览器地址+端口号来(<a href="http://localhost:10000)对容器内Jupyter进行访问了" target="_blank" rel="noopener">http://localhost:10000)对容器内Jupyter进行访问了</a>!<br></p><br><p style="text-indent:2em">同一浏览器首次登陆，提示需要输入token：</p><p><img src="/在一台服务器同时部署多个CUDA环境/token.png" alt="Jupyter Notebook Token"><br>token位于：</p><p><img src="/在一台服务器同时部署多个CUDA环境/terminal_token.png" alt="token"></p><p style="text-indent:2em">复制粘贴token后就可以进入Notebook了！可以通过运行三个样例程序测试容器环境配置是否正确。</p><br><p style="text-indent:2em">至此，我们完成了使用Docker对CUDA8.0的Tensorflow1.4版本进行部署的任务。</p><br><p style="text-indent:2em">接下来，我们讲解如何在同一台主机上安装多版本CUDA与CuDNN。</p><br># 三、多版本CUDA与cuDNN共存<br>## 1. 安装新版本CUDA及cuDNN<br><p style="text-indent:2em">我们的主机上已经安装了CUDA10.0的版本及对应版本的cuDNN，现在我们要安装CUDA8.0及其对应的cuDNN。</p><p style="text-indent:2em">安装另一版本的CUDA及cuDNN时，需要遵循以下步骤</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 cuda_8.0.44_linux.run</span><br><span class="line">./cuda_8.0.44_linux.run</span><br></pre></td></tr></table></figure><p style="text-indent:2em">接下来需要选择安装内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Do you accept the previously <span class="built_in">read</span> EULA?</span><br><span class="line">accept/decline/quit: accept</span><br><span class="line"></span><br><span class="line">Install NVIDIA Accelerated Graphics Driver <span class="keyword">for</span> Linux-x86_64 384.81?</span><br><span class="line">(y)es/(n)o/(q)uit: n  <span class="comment"># 已安装新版驱动，不需要安装旧版驱动</span></span><br><span class="line"></span><br><span class="line">Install the CUDA 8.0 Toolkit?</span><br><span class="line">(y)es/(n)o/(q)uit: y</span><br><span class="line"></span><br><span class="line">Enter Toolkit Location</span><br><span class="line"> [ default is /usr/<span class="built_in">local</span>/cuda-8.0 ]:	</span><br><span class="line"></span><br><span class="line">/usr/<span class="built_in">local</span>/cuda-8.0 is not writable.</span><br><span class="line">Do you wish to run the installation with <span class="string">'sudo'</span>?</span><br><span class="line">(y)es/(n)o: y</span><br><span class="line">Please enter your password: </span><br><span class="line"></span><br><span class="line">Do you want to install a symbolic link at /usr/<span class="built_in">local</span>/cuda? </span><br><span class="line">(y)es/(n)o/(q)uit: n <span class="comment">#不需要在/usr/local/cuda出创建软连接</span></span><br><span class="line"></span><br><span class="line">Install the CUDA 8.0 Samples?</span><br><span class="line">(y)es/(n)o/(q)uit: n</span><br></pre></td></tr></table></figure><p style="text-indent:2em">然后安装 cuDNN： cudnn-8.0-linux-x64-v6.0.tgz，使用以下命令安装（将cuDNN中的/include和/lib文件夹分别复制到CUDA安装目录下的/include和/lib文件夹中，同时赋予所有用户读权限）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvzf cudnn-8.0-linux-x64-v6.0.tgz</span><br><span class="line">sudo cp cuda/include/cudnn.h /usr/<span class="built_in">local</span>/cuda-8.0/include</span><br><span class="line">sudo cp cuda/lib64/lib* /usr/<span class="built_in">local</span>/cuda-8.0/lib64</span><br><span class="line">sudo chmod a+r /usr/<span class="built_in">local</span>/cuda-8.0/include/cudnn.h /usr/<span class="built_in">local</span>/cuda-8.0/lib64/libcudnn*</span><br></pre></td></tr></table></figure><p style="text-indent:2em">至此,CUDA8.0及其对应版本的cuDNN6.0的安装就完成了。</p><h2 id="自由切换CUDA版本"><a href="#自由切换CUDA版本" class="headerlink" title="自由切换CUDA版本"></a>自由切换CUDA版本</h2><p style="text-indent:2em">上一步之后，/usr/local/ 目录下可以找到三个文件夹：</p><figure class="highlight plain"><figcaption><span># 软链接</span></figcaption><table><tr><td class="code"><pre><span class="line">cuda-8.0</span><br><span class="line">cuda-10.0</span><br></pre></td></tr></table></figure><p style="text-indent:2em">实现多版本CUDA及cuDNN共存并自由切换的思路是创建指向同一环境变量位置处的不同CUDA对应的软连接:我们在此使用 cuda 为路径，需要 cuda-8.0 时就将 cuda 指向 cuda-8.0 ，需要 cuda-10.0 时就将 cuda 指向 cuda-10.0。</p><p style="text-indent:2em">我们先修改用户环境变量</p><br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc		<span class="comment"># 中岳使用的是zsh，bash用户可以更改~/.bashrc</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/<span class="built_in">local</span>/cuda-10.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/<span class="built_in">local</span>/cuda-10.0/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure><br><br><p style="text-indent:2em">将其中的 cuda-10.0 改为 cuda，这样，我们就完成了环境变量位置的统一。</p><br><p style="text-indent:2em">这时，想要切换到cuda8只需运行，创建指向修改后的环境变量位置的软连接就可以了！对于CUDA8.0来说，运行一下命令，即可完成从CUDA10.0到CUDA8.0的转换：</p><br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/cuda</span><br><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/cuda sudo ln -s /usr/<span class="built_in">local</span>/cuda-8.0 /usr/<span class="built_in">local</span>/cuda</span><br></pre></td></tr></table></figure><br><br><p style="text-indent:2em">同理，我们可以完成CUDA8.0到CUDA10.0的转换。</p><p style="text-indent:2em">以上命令，还可以通过创建一个脚本来实现批量化处理，创建一个名为cuda8.0的文件，在里面写入：</p><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/<span class="built_in">local</span>/cuda</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/cuda-8.0 /usr/<span class="built_in">local</span>/cuda		</span><br><span class="line">nvcc -V		<span class="comment"># 显示当前版本号，以判断是否切换成功</span></span><br></pre></td></tr></table></figure><br><br><p style="text-indent:2em">然后保存，执行：</p><br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">chmod 777 cuda8</span><br><span class="line">sudo cp cuda8 /bin</span><br></pre></td></tr></table></figure><br><br><p style="text-indent:2em">然后以后想要切换到，cuda-8.0 只需在终端里输入 cuda8 就可以了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p style="text-indent:2em">使用Docker可以在不改变现有开发环境的情况下快速部署在不同开发环境下发布的产品，具有迅捷，性能无损的优点，缺点是Docker官方提供的镜像往往只能解决底层硬件驱动问题，需要开发人员重新在其基础上，重新安装上层开发环境，而直接在主机上安装多个CDUA版本，则可以避免这个问题，缺点就是安装过程可能稍复杂。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Linux系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer面试题[1]赋值运算符函数</title>
    <url>/%E5%89%91%E6%8C%87Offer%E9%9D%A2%E8%AF%95%E9%A2%98%5B1%5D%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="赋值运算符函数"><a href="#赋值运算符函数" class="headerlink" title="赋值运算符函数"></a>赋值运算符函数</h1><p>题目：如下类型CMyString的声明，请为该类型添加赋值运算符函数<br></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">        CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">        ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">char</span>* m_Dtata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h1 id="考察内容"><a href="#考察内容" class="headerlink" title="考察内容"></a>考察内容</h1><ul><li>是否把返回值得类型声明为该类型的引用，并在函数结束前返回实例自身的引用（*this）。只有返回一个引用，才可以允许连续赋值。否则，如果函数额返回值是void，则应用该赋值运算符函数将不能进行连续赋值。</li><li>是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数。把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。</li><li>是否释放实例自身已有的内存。如果我们忘记在分配内存之前释放内存，则程序将出现内存泄漏。</li><li>判断传入的参数和当前的实例(<em>this)是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行复制，那么在释放实例自身内存的时候就会导致严重的问题：当</em>this和传入的参数是同一个实例时，一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="经典解法——初级程序员"><a href="#经典解法——初级程序员" class="headerlink" title="经典解法——初级程序员"></a>经典解法——初级程序员</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> = &amp;str)</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[]m_pData;</span><br><span class="line">	m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	m_pData = <span class="keyword">new</span>  <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考虑异常安全性的解法——高级程序员"><a href="#考虑异常安全性的解法——高级程序员" class="headerlink" title="考虑异常安全性的解法——高级程序员"></a>考虑异常安全性的解法——高级程序员</h2><h3 id="经典解法的缺陷"><a href="#经典解法的缺陷" class="headerlink" title="经典解法的缺陷"></a>经典解法的缺陷</h3><p>在经典解法中，先试用delete释放了实例m_pData的内存。如果此时内存不知导致new char抛出异常，那么m_pData将是一个空指针，这样非常容易导致程序崩溃。也就是说，一旦在赋值运算符函数内部抛出一个异常，CMyString的实例将不再保持有效的状态，这就违背了<strong>异常安全性(Exception Safety)</strong>原则。</p><h3 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h3><p>要想在赋值运算符函数中实现异常安全性，有两种方法:</p><ol><li>先试用new分配新内容，再用delete释放已有的内存。</li><li>先创建一个临时实例，在交换临时实例和原来的实例。</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>!=&amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        CMyString strTemp(str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* pTemp=strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData=m_pData;</span><br><span class="line">        m_pData=pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>现代计算机网络lab01-基础网络配置</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9Clab01-%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><p align="center">主讲老师：李伟明，于俊清</p><h1 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h1><ol><li>安装GNS3<br>GNS3提供了网络和网络连接的模拟功能，到网站 <a href="http://www.gns3.net/" target="_blank" rel="noopener">http://www.gns3.net/</a> 下载并安装Windows版本</li><li>安装开源虚拟机管理系统VirtualBox</li><li><p>导入slitaz linux虚拟机文件（也可以用Ubuntu）<br>slitaz为一个轻量级的linux发行版本。创建一个slitaz虚拟机取名字为：PC1，可以设置跟host的文件共 享目录和剪贴板共享选项。启动虚拟机，用户名和密码都为tux，root用户口令为root。 slitaz文档：<a href="http://doc.slitaz.org" target="_blank" rel="noopener">http://doc.slitaz.org</a><br>简单配置命令： slitaz下每次sudo要输入root口令<br>linux配置网络工具主要有net-tools (提供 ifconﬁg, route, netstat), 或者 iproute2 (提供 ip, ss)。采用后 者配置更方便。<br>如果网卡名称不是eth0，eth1，eth2，那么：<a id="more"></a></p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">rm /etc/udev/rules.d/70-persistent-net.rules </span><br><span class="line">reboot</span><br><span class="line">```  </span><br><span class="line">如果网卡没有启动使用命令：  </span><br><span class="line">```zsh</span><br><span class="line">sudo ip link <span class="built_in">set</span> eth0 up</span><br></pre></td></tr></table></figure><p>配置IP地址命令：<br>ip address显示地址<br>sudo ip address add 192.168.1.1/24 dev eth0 添加IP sudo ip address del 192.168.1.1/24 dev eth0 删除IP<br>永久增加IP地址： 修改/etc/network.conf设置IP 或者直接把命令写到/etc/init.d/local.sh 增加路由</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">sudo ip route add 192.168.1.0/24 dev eth0 </span><br><span class="line">sudo ip route del 192.168.1.0/24 dev eth0</span><br></pre></td></tr></table></figure><p>ip route显示路由<br>增加路由</p><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">ip route add &#123;NETWORK/MASK&#125; via &#123;GATEWAYIP&#125;</span><br></pre></td></tr></table></figure><p>增加默认路由<br>ip route add default via 192.168.0.196</p></li><li>Clone PC1多个为PC2，PC3（完整复制，不是链接复制）</li><li>配置GNS3<ul><li>打开GNS3新建一个项目</li><li>进入edit菜单，然后打开preferences，然后选择VirtualBox和VirtualBox VMs</li><li>对每个PCx虚拟机 • 选择 new 按钮 选择一个PCx虚拟机 选择创建的虚拟机然后edit 修改网卡数量为3 选择 Apply 然后 OK</li></ul></li><li>创建一个新项目<br><img src="/现代计算机网络lab01-基础网络配置/description.png" alt><br>将三台PCx按照如图方式连接起来，配置IP地址<br>PC1启动转发功能 echo “1” &gt; /proc/sys/net/ipv4/ip_forward<br>实验要求：PC2和PC3之间能够互相ping通</li><li>注意<br>Reserve ﬁrst NIC for VirtualBox NAT to host OS is to you have your ﬁrst network interface card (e.g. eth0 on Linux) conﬁgured with network address translation (NAT), allowing your VM to access your host network and Internet (if your host can access it of course).</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络实验</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode精解[4]寻找两个有序数组的中位数</title>
    <url>/leetcode%E7%B2%BE%E8%A7%A3%5B4%5D%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><table><thead><tr><th>Category</th><th>Difficulty</th><th>Likes</th><th>Dislikes</th></tr></thead><tbody><tr><td>algorithms</td><td>Hard (36.26%)</td><td>1725</td><td>-</td></tr></tbody></table><p>array | binary-search | divide-and-conquer<br>Companies adobe | apple | dropbox | google | microsoft | yahoo | zenefits</p><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><a id="more"></a><p>示例 1:</p><p>nums1 = [1, 3]<br>nums2 = [2]</p><p>则中位数是 2.0<br>示例 2:</p><p>nums1 = [1, 2]<br>nums2 = [3, 4]</p><p>则中位数是 (2 + 3)/2 = 2.5</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法来自：力扣（LeetCode）：<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/</a></p><p>方法：递归法<br>为了解决这个问题，我们需要理解 “中位数的作用是什么”。在统计中，中位数被用来：</p><p>将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。</p><p>如果理解了中位数的划分作用，我们就很接近答案了。</p><p>首先，让我们在任一位置 ii 将 \text{A}A 划分成两个部分：</p><pre><code>      left_A             |        right_A
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
</code></pre><p>由于 \text{A}A 中有 mm 个元素， 所以我们有 m+1m+1 种划分的方法（i = 0 \sim mi=0∼m）。</p><p>我们知道：</p><p>\text{len}(\text{left_A}) = i, \text{len}(\text{right_A}) = m - ilen(left_A)=i,len(right_A)=m−i.</p><p>注意：当 i = 0i=0 时，\text{left_A}left_A 为空集， 而当 i = mi=m 时, \text{right_A}right_A 为空集。</p><p>采用同样的方式，我们在任一位置 jj 将 \text{B}B 划分成两个部分：</p><pre><code>      left_B             |        right_B
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
</code></pre><p>将 \text{left_A}left_A 和 \text{left_B}left_B 放入一个集合，并将 \text{right_A}right_A 和 \text{right_B}right_B 放入另一个集合。 再把这两个新的集合分别命名为 \text{left_part}left_part 和 \text{right_part}right_part：</p><pre><code>      left_part          |        right_part
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
</code></pre><p>如果我们可以确认：</p><p>\text{len}(\text{left_part}) = \text{len}(\text{right_part})len(left_part)=len(right_part)<br>\max(\text{left_part}) \leq \min(\text{right_part})max(left_part)≤min(right_part)<br>那么，我们已经将 {\text{A}, \text{B}}{A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。那么：</p><p>\text{median} = \frac{\text{max}(\text{left}_\text{part}) + \text{min}(\text{right}_\text{part})}{2}<br>median=<br>2<br>max(left_part)+min(right_part)<br>​</p><p>要确保这两个条件，我们只需要保证：</p><p>i + j = m - i + n - ji+j=m−i+n−j（或：m - i + n - j + 1m−i+n−j+1）<br>如果 n \geq mn≥m，只需要使 \ i = 0 \sim m,\ j = \frac{m + n + 1}{2} - i \ i=0∼m, j=<br>2<br>m+n+1<br>​<br>−i</p><p>\text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 以及 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]</p><p>ps.1 为了简化分析，我假设 \text{A}[i-1], \text{B}[j-1], \text{A}[i], \text{B}[j]A[i−1],B[j−1],A[i],B[j] 总是存在，哪怕出现 i=0i=0，i=mi=m，j=0j=0，或是 j=nj=n 这样的临界条件。<br>我将在最后讨论如何处理这些临界值。</p><p>ps.2 为什么 n \geq mn≥m？由于0 \leq i \leq m0≤i≤m 且 j = \frac{m + n + 1}{2} - ij=<br>2<br>m+n+1<br>​<br>−i，我必须确保 jj 不是负数。如果 n &lt; mn&lt;m，那么 jj 将可能是负数，而这会造成错误的答案。</p><p>所以，我们需要做的是：</p><p>在 [0，m][0，m] 中搜索并找到目标对象 ii，以使：</p><p>\qquad \text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 且 \text{A}[i-1] \leq \text{B}[j],A[i−1]≤B[j], 其中 j = \frac{m + n + 1}{2} - ij=<br>2<br>m+n+1<br>​<br>−i</p><p>接着，我们可以按照以下步骤来进行二叉树搜索：</p><p>设 \text{imin} = 0imin=0，\text{imax} = mimax=m, 然后开始在 [\text{imin}, \text{imax}][imin,imax] 中进行搜索。</p><p>令 i = \frac{\text{imin} + \text{imax}}{2}i=<br>2<br>imin+imax<br>​<br>， j = \frac{m + n + 1}{2} - ij=<br>2<br>m+n+1<br>​<br>−i</p><p>现在我们有 \text{len}(\text{left}_\text{part})=\text{len}(\text{right}_\text{part})len(left_part)=len(right_part)。 而且我们只会遇到三种情况：</p><p>\text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 且 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]：<br>这意味着我们找到了目标对象 ii，所以可以停止搜索。</p><p>\text{B}[j-1] &gt; \text{A}[i]B[j−1]&gt;A[i]：<br>这意味着 \text{A}[i]A[i] 太小，我们必须调整 ii 以使 \text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i]。<br>我们可以增大 ii 吗？<br>是的，因为当 ii 被增大的时候，jj 就会被减小。<br>因此 \text{B}[j-1]B[j−1] 会减小，而 \text{A}[i]A[i] 会增大，那么 \text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 就可能被满足。<br>我们可以减小 ii 吗？<br>不行，因为当 ii 被减小的时候，jj 就会被增大。<br>因此 \text{B}[j-1]B[j−1] 会增大，而 \text{A}[i]A[i] 会减小，那么 \text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 就可能不满足。<br>所以我们必须增大 ii。也就是说，我们必须将搜索范围调整为 [i+1, \text{imax}][i+1,imax]。<br>因此，设 \text{imin} = i+1imin=i+1，并转到步骤 2。</p><p>\text{A}[i-1] &gt; \text{B}[j]A[i−1]&gt;B[j]：<br>这意味着 \text{A}[i-1]A[i−1] 太大，我们必须减小 ii 以使 \text{A}[i-1]\leq \text{B}[j]A[i−1]≤B[j]。<br>也就是说，我们必须将搜索范围调整为 [\text{imin}, i-1][imin,i−1]。<br>因此，设 \text{imax} = i-1imax=i−1，并转到步骤 2。</p><p>当找到目标对象 ii 时，中位数为：</p><p>\max(\text{A}[i-1], \text{B}[j-1]),max(A[i−1],B[j−1]), 当 m + nm+n 为奇数时</p><p>\frac{\max(\text{A}[i-1], \text{B}[j-1]) + \min(\text{A}[i], \text{B}[j])}{2},<br>2<br>max(A[i−1],B[j−1])+min(A[i],B[j])<br>​<br>, 当 m + nm+n 为偶数时</p><p>现在，让我们来考虑这些临界值 i=0,i=m,j=0,j=ni=0,i=m,j=0,j=n，此时 \text{A}[i-1],\text{B}[j-1],\text{A}[i],\text{B}[j]A[i−1],B[j−1],A[i],B[j] 可能不存在。<br>其实这种情况比你想象的要容易得多。</p><p>我们需要做的是确保 \text{max}(\text{left}_\text{part}) \leq \text{min}(\text{right}_\text{part})max(left_part)≤min(right_part)。 因此，如果 ii 和 jj 不是临界值（这意味着 \text{A}[i-1], \text{B}[j-1],\text{A}[i],\text{B}[j]A[i−1],B[j−1],A[i],B[j] 全部存在）, 那么我们必须同时检查 \text{B}[j-1] \leq \text{A}[i]B[j−1]≤A[i] 以及 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j] 是否成立。<br>但是如果 \text{A}[i-1],\text{B}[j-1],\text{A}[i],\text{B}[j]A[i−1],B[j−1],A[i],B[j] 中部分不存在，那么我们只需要检查这两个条件中的一个（或不需要检查）。<br>举个例子，如果 i = 0i=0，那么 \text{A}[i-1]A[i−1] 不存在，我们就不需要检查 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j] 是否成立。<br>所以，我们需要做的是：</p><p>在 [0，m][0，m] 中搜索并找到目标对象 ii，以使：</p><p>(j = 0(j=0 or i = mi=m or \text{B}[j-1] \leq \text{A}[i])B[j−1]≤A[i]) 或是<br>(i = 0(i=0 or j = nj=n or \text{A}[i-1] \leq \text{B}[j]),A[i−1]≤B[j]), 其中 j = \frac{m + n + 1}{2} - ij=<br>2<br>m+n+1<br>​<br>−i</p><p>在循环搜索中，我们只会遇到三种情况：</p><p>(j = 0(j=0 or i = mi=m or \text{B}[j-1] \leq \text{A}[i])B[j−1]≤A[i]) 或是 (i = 0(i=0 or j = nj=n or \text{A}[i-1] \leq \text{B}[j])A[i−1]≤B[j])，这意味着 ii 是完美的，我们可以停止搜索。<br>j &gt; 0j&gt;0 and i &lt; mi<m and \text{b}[j - 1]>\text{A}[i]B[j−1]&gt;A[i] 这意味着 ii 太小，我们必须增大它。<br>i &gt; 0i&gt;0 and j &lt; nj<n and \text{a}[i - 1]>\text{B}[j]A[i−1]&gt;B[j] 这意味着 ii 太大，我们必须减小它。<br>感谢 @Quentin.chen 指出：i &lt; m \implies j &gt; 0i&lt;m⟹j&gt;0 以及 i &gt; 0 \implies j &lt; ni&gt;0⟹j&lt;n 始终成立，这是因为：</n></m></p><p>m \leq n,\ i &lt; m \implies j = \frac{m+n+1}{2} - i &gt; \frac{m+n+1}{2} - m \geq \frac{2m+1}{2} - m \geq 0<br>m≤n, i&lt;m⟹j=<br>2<br>m+n+1<br>​<br>−i&gt;<br>2<br>m+n+1<br>​<br>−m≥<br>2<br>2m+1<br>​<br>−m≥0</p><p>m \leq n,\ i &gt; 0 \implies j = \frac{m+n+1}{2} - i &lt; \frac{m+n+1}{2} \leq \frac{2n+1}{2} \leq n<br>m≤n, i&gt;0⟹j=<br>2<br>m+n+1<br>​<br>−i&lt;<br>2<br>m+n+1<br>​<br>≤<br>2<br>2n+1<br>​<br>≤n</p><p>所以，在情况 2 和 3中，我们不需要检查 j &gt; 0j&gt;0 或是 j &lt; nj&lt;n 是否成立。</p><p>JavaPython<br>class Solution {<br>public double findMedianSortedArrays(int[] A, int[] B) {<br>int m = A.length;<br>int n = B.length;<br>if (m &gt; n) { // to ensure m&lt;=n<br>int[] temp = A; A = B; B = temp;<br>int tmp = m; m = n; n = tmp;<br>}<br>int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;<br>while (iMin &lt;= iMax) {<br>int i = (iMin + iMax) / 2;<br>int j = halfLen - i;<br>if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i]){<br>iMin = i + 1; // i is too small<br>}<br>else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) {<br>iMax = i - 1; // i is too big<br>}<br>else { // i is perfect<br>int maxLeft = 0;<br>if (i == 0) { maxLeft = B[j-1]; }<br>else if (j == 0) { maxLeft = A[i-1]; }<br>else { maxLeft = Math.max(A[i-1], B[j-1]); }<br>if ( (m + n) % 2 == 1 ) { return maxLeft; }</p><pre><code>            int minRight = 0;
            if (i == m) { minRight = B[j]; }
            else if (j == n) { minRight = A[i]; }
            else { minRight = Math.min(B[j], A[i]); }

            return (maxLeft + minRight) / 2.0;
        }
    }
    return 0.0;
}
</code></pre><p>}<br>复杂度分析</p><p>时间复杂度：O\big(\log\big(\text{min}(m,n)\big)\big)O(log(min(m,n)))，<br>首先，查找的区间是 [0, m][0,m]。<br>而该区间的长度在每次循环之后都会减少为原来的一半。<br>所以，我们只需要执行 \log(m)log(m) 次循环。由于我们在每次循环中进行常量次数的操作，所以时间复杂度为 O\big(\log(m)\big)O(log(m))。<br>由于 m \leq nm≤n，所以时间复杂度是 O\big(\log\big(\text{min}(m,n)\big)\big)O(log(min(m,n)))。</p><p>空间复杂度：O(1)O(1)，<br>我们只需要恒定的内存来存储 99 个局部变量， 所以空间复杂度为 O(1)O(1)。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode精解[3]无重复字符的最长子串</title>
    <url>/leetcode%E7%B2%BE%E8%A7%A3%5B3%5D%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><table><thead><tr><th>Category</th><th>Difficulty</th><th>Likes</th><th>Dislikes</th></tr></thead><tbody><tr><td>algorithms</td><td>Medium (31.86%)</td><td>2649</td><td>-</td></tr></tbody></table><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><a id="more"></a><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法来自：力扣（LeetCode）：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetcod/</a></p><p>方法一：暴力法<br>题目更新后由于时间限制，会出现 TLE。</p><p>思路</p><p>逐个检查所有的子字符串，看它是否不含有重复的字符。</p><p>算法</p><p>假设我们有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。</p><p>现在让我们填补缺少的部分：</p><p>为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 ii 和 jj。那么我们有 0 \leq i \lt j \leq n0≤i&lt;j≤n（这里的结束索引 jj 是按惯例排除的）。因此，使用 ii 从 0 到 n - 1n−1 以及 jj 从 i+1i+1 到 nn 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。</p><p>要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。</p><p>Java<br>public class Solution {<br>public int lengthOfLongestSubstring(String s) {<br>int n = s.length();<br>int ans = 0;<br>for (int i = 0; i &lt; n; i++)<br>for (int j = i + 1; j &lt;= n; j++)<br>if (allUnique(s, i, j)) ans = Math.max(ans, j - i);<br>return ans;<br>}</p><pre><code>public boolean allUnique(String s, int start, int end) {
    Set&lt;Character&gt; set = new HashSet&lt;&gt;();
    for (int i = start; i &lt; end; i++) {
        Character ch = s.charAt(i);
        if (set.contains(ch)) return false;
        set.add(ch);
    }
    return true;
}
</code></pre><p>}<br>复杂度分析</p><p>时间复杂度：O(n^3)O(n<br>3<br>) 。</p><p>要验证索引范围在 [i, j)[i,j) 内的字符是否都是唯一的，我们需要检查该范围中的所有字符。 因此，它将花费 O(j - i)O(j−i) 的时间。</p><p>对于给定的 i，对于所有 j \in [i+1, n]j∈[i+1,n] 所耗费的时间总和为：</p><p>\sum_{i+1}^{n}O(j - i)<br>i+1<br>∑<br>n<br>​<br>O(j−i)</p><p>因此，执行所有步骤耗去的时间总和为：</p><p>O\left(\sum_{i = 0}^{n - 1}\left(\sum_{j = i + 1}^{n}(j - i)\right)\right) = O\left(\sum_{i = 0}^{n - 1}\frac{(1 + n - i)(n - i)}{2}\right) = O(n^3)<br>O(<br>i=0<br>∑<br>n−1<br>​<br>(<br>j=i+1<br>∑<br>n<br>​<br>(j−i)))=O(<br>i=0<br>∑<br>n−1<br>​</p><p>2<br>(1+n−i)(n−i)<br>​<br>)=O(n<br>3<br>)</p><p>空间复杂度：O(min(n, m))O(min(n,m))，我们需要 O(k)O(k) 的空间来检查子字符串中是否有重复字符，其中 kk 表示 Set 的大小。而 Set 的大小取决于字符串 nn 的大小以及字符集/字母 mm 的大小。</p><p>方法二：滑动窗口<br>算法</p><p>暴力法非常简单，但它太慢了。那么我们该如何优化它呢？</p><p>在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 ii 到 j - 1j−1 之间的子字符串 s_{ij}s<br>ij<br>​<br>已经被检查为没有重复字符。我们只需要检查 s[j]s[j] 对应的字符是否已经存在于子字符串 s_{ij}s<br>ij<br>​<br>中。</p><p>要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n^2)O(n<br>2<br>) 的算法，但我们可以做得更好。</p><p>通过使用 HashSet 作为滑动窗口，我们可以用 O(1)O(1) 的时间来完成对字符是否在当前的子字符串中的检查。</p><p>滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)[i,j) 向右滑动 11 个元素，则它将变为 [i+1, j+1)[i+1,j+1)（左闭，右开）。</p><p>回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)[i,j)（最初 j = ij=i）中。 然后我们向右侧滑动索引 jj，如果它不在 HashSet 中，我们会继续滑动 jj。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 ii 开头。如果我们对所有的 ii 这样做，就可以得到答案。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`<br>复杂度分析</p><p>时间复杂度：O(2n) = O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 ii 和 jj 访问两次。</p><p>空间复杂度：O(min(m, n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k) 的空间，其中 kk 表示 Set 的大小。而 Set 的大小取决于字符串 nn 的大小以及字符集 / 字母 mm 的大小。</p><p>方法三：优化的滑动窗口<br>上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。</p><p>也就是说，如果 s[j]s[j] 在 [i, j)[i,j) 范围内有与 j’j<br>′<br>重复的字符，我们不需要逐渐增加 ii 。 我们可以直接跳过 [i，j’][i，j<br>′<br>] 范围内的所有元素，并将 ii 变为 j’ + 1j<br>′<br>+1。</p><p>Java（使用 HashMap）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java（假设字符集为 ASCII 128）</p><p>以前的我们都没有对字符串 s 所使用的字符集进行假设。</p><p>当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。</p><p>常用的表如下所示：</p><p>int [26] 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’<br>int [128] 用于ASCII码<br>int [256] 用于扩展ASCII码<br></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>]; <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            i = Math.max(index[s.charAt(j)], i);</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            index[s.charAt(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，索引 jj 将会迭代 nn 次。</p><p>空间复杂度（HashMap）：O(min(m, n))O(min(m,n))，与之前的方法相同。</p><p>空间复杂度（Table）：O(m)O(m)，mm 是字符集的大小。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>现代计算机网络课程笔记（一）</title>
    <url>/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="Lesson-1"><a href="#Lesson-1" class="headerlink" title=" Lesson 1 "></a><p align="center">Lesson 1</p></h1><p align="center">主讲老师：李伟明，于俊清</p><h1 id="课程目标-结构-计划"><a href="#课程目标-结构-计划" class="headerlink" title="课程目标/结构/计划"></a>课程目标/结构/计划</h1><h2 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h2><ul><li><p>网络基础（深入）：</p><ul><li>Ch1. 体系结构</li><li>Ch2. 网络互联</li><li>Ch3. 拥塞控制</li></ul></li><li><p>现代网络：</p><ul><li>Ch4. 无线和移动网络</li><li>Ch5: P2P网络</li><li>Ch6: SDN</li><li>Ch7: IPv6网络</li></ul></li><li><p>扩展网络技术</p><ul><li>Ch8: 网络空间安全</li></ul></li></ul><a id="more"></a><h2 id="教材"><a href="#教材" class="headerlink" title="教材"></a>教材</h2><ol><li><p>Cmputer Network -A System Approach(4nd), Larry Peterson 机械工业出版社有中文版（开元）<br><a href="https://github.com/SystemsApproach" target="_blank" rel="noopener">https://github.com/SystemsApproach</a></p></li><li><p>computer Networking -A Top-Down Approch Featuring the Internet, Third Edition, James F.Kurose</p></li></ol><h2 id="3个实验"><a href="#3个实验" class="headerlink" title="3个实验"></a>3个实验</h2><ol><li>TCP三次握手攻击以及Syn Cookie机制(GNS3, Linux, VirtualBox)</li><li>TCP的拥塞控制算法比较(GNS#, Linux, VirtualBox)</li><li>SDN配置实验(Mininet, Python)</li></ol><h2 id="1-1-什么是网络？"><a href="#1-1-什么是网络？" class="headerlink" title="1.1 什么是网络？"></a>1.1 什么是网络？</h2><p>在计算机网络出现之前，就有很多网络了，例如大型机连接哑终端、电话网络、广播网络。<br>这些网络的共同点是连接不同设备，交换信息。特点是针对特定信号，连接特殊设备。<br>计算机网络最大的特点是通用性，传输的是通用数据，连接的是通用的计算机。</p><h3 id="1-1-1-什么是计算机网络"><a href="#1-1-1-什么是计算机网络" class="headerlink" title="1.1.1 什么是计算机网络"></a>1.1.1 什么是计算机网络</h3><ul><li>计算机网络是互联的通用的计算机的集合<ul><li>互联</li><li>自治</li><li>作为一个通用的网络，需要满足不同的网络需求<br>（计算机网络显著的特点：end to end）</li></ul></li><li>分布式系统和网络区别<ul><li>分布式系统展现给用户的是一个统一的整体系统</li><li>对用户来说，分布式系统只有一个模型或范型（WWW）、集群</li><li>计算机网络展现给用户的是互联的不同节点，每个节点是自治的</li><li>分布式系统一般建立在网络之上.</li></ul></li></ul><h3 id="1-1-2-计算机网络的需求与约束"><a href="#1-1-2-计算机网络的需求与约束" class="headerlink" title="1.1.2 计算机网络的需求与约束"></a>1.1.2 计算机网络的需求与约束</h3><ul><li>Constraints &amp; Requirements<ul><li>Application Programmer<br>应用程序需求</li><li>Network Designer<br>设计的成本</li><li>Network Provider<br>易于管理</li><li>Network Supervisor<br>来自检测、监控、保障的需求</li></ul></li><li><p>网络的设计者、设备的制造者、网络运营者和网络监管者, 4维共同作用于网络</p><p>需求总结起来最重要的是三个点</p><ol><li>互联(Connectivity)</li><li>维用户㧈搞笑的资源共享</li></ol></li></ul><h3 id="1-1-2-Connectivity"><a href="#1-1-2-Connectivity" class="headerlink" title="1.1.2 Connectivity"></a>1.1.2 Connectivity</h3><p>仅仅一个网络需求，就会变得非常复杂</p><ul><li><p>网络= ${节点, 链路} = {V，L}, V = { v_1, v_2 ,… , v_n} ,L = { l_1, l_2 ,… , l_m }$</p></li><li><p>节点(Node):</p><ul><li>端节点：自身拥有计算机资源的源宿用户设备</li><li>转接节点：支持网络连通并在网络中对数据起交换和转接的节点，如 交换机/路由器/集线器</li></ul></li><li><p>链路(link):</p><ul><li>物理链路：在物理层连接两个节点的物理介质，如电话线、同轴电缆 、光纤、无线电波</li></ul></li><li><p>逻辑链路：</p><ul><li>在两点间通过通信协议的作用建立起来的数据联接通路</li></ul></li><li><p>通路（Path）</p><ul><li>从源点到宿点所经过的一串节点和链路的有序集。或端到端的通路</li></ul></li><li><p>协议（Protocol）</p><ul><li>多个进程为完成一个任务而共同遵守的动作序列规范</li><li>三要素：语法、语义、规则(同步时序)</li></ul></li><li><p>网络云<br>区分通信子网交换节点（云内）和资源主机节点（云外）的分解心啊，可表示任何网络</p></li></ul><p><img src="/public/现代计算机网络课程笔记（一）/1.png" alt></p><p><img src="/public/现代计算机网络课程笔记（一）/2.png" alt><br>物理：传输网络+计算机网络<br>逻辑：主干通信+接入资源（包括主机与用户）<br><img src="/public/现代计算机网络课程笔记（一）/3.png" alt></p><h3 id="1-1-3-网络体系结构"><a href="#1-1-3-网络体系结构" class="headerlink" title="1.1.3 网络体系结构"></a>1.1.3 网络体系结构</h3><ul><li>当网络规模越来越大，网络变得越来越复杂，需求和约束越来越多 ，就需要引入“网络体系结构”来指导网络设计和实现</li><li>体系结构本质是将一个复杂事物分解为元素和结构，结构描述元素 之间的关系</li><li><p>网络体系结构的元素就是Protocols，Protocols之间最重要的关系就 是Layering</p></li><li><p>一个典型的分层网络体系结构，将不同人物分到不同层次<br><img src="/public/现代计算机网络课程笔记（一）/4.png" alt></p></li><li><p>同一个层次可以有不同抽象，满足不同的需求：<br><img src="/public/现代计算机网络课程笔记（一）/5.png" alt></p></li><li><p>Protocol:<br>Protocol defines the interfaces between the layers in the same system and with the layers of peer system</p></li><li>Building blocks of a network architecture</li><li>Each protocol object has two different interfaces<ul><li>service interface: operations on this protocol</li><li>peer-to-peer interface: messages exchanged with peer<br>+Term “protocol” is overloaded</li><li>specification of peer-0Peerinterface</li><li>module that implements this interface</li></ul></li></ul><p><img src="/public/现代计算机网络课程笔记（一）/6.png" alt></p><p><img src="/public/现代计算机网络课程笔记（一）/7.png" alt></p><p><img src="/public/现代计算机网络课程笔记（一）/8.png" alt></p><p><img src="/public/现代计算机网络课程笔记（一）/9.png" alt></p><h3 id="1-1-3-网络体系结构-OSI"><a href="#1-1-3-网络体系结构-OSI" class="headerlink" title="1.1.3 网络体系结构-OSI"></a>1.1.3 网络体系结构-OSI</h3><ul><li><p>Session Layer: X.225 or ISO 8327</p><ul><li>Authentication</li><li>authorization</li><li>Session restoration(checkpointing and recovery)</li></ul></li><li><p>Presentation Layer:</p><ul><li>Data conversion</li><li>Character code translation</li><li>Compression</li><li>Encryption and Decryption<br><img src="/public/现代计算机网络课程笔记（一）/10.png" alt></li></ul></li><li><p>Internet Protocol Graph<br>为什么TCP/IP可以取代OSI?<br><img src="/public/现代计算机网络课程笔记（一）/11.png" alt></p><ul><li>The Internet architecure does not imply strict layering</li><li>An hourglass shape_wide at th etop, narrow in the middle, and wide at the bottom</li><li>The existence of working implementation is required for standards to be adopted by the IETF</li></ul></li><li><p>成功的另外一个原因:<br>功能由软件在通用机上提供，加入新功能是很容易的事情</p></li><li>应用编程接API（Sockets）:<br>Socket interface<br>int socket(int domain,int type,int protocol)创建一个插口（套接字），支持 任何现行协议，返回socket的一个句柄，以后引用的标识符</li><li><p>Domain：</p><ul><li>PF_INET ;表示因特网协议</li><li>PF_UNIX；表示UNIX协议</li><li>type ：</li><li>SOCK_DGRAM ;面向报文的服务</li><li>SOCK_STREAM；面向字节流服务</li><li>protocol：IPPROTO_TCP 或IPPTOTO_UDP，如果是TCP/IP协议，那么可以从前两个 参数得到协议。</li><li>int bind(int socket,struct addr *address,int addr_len) 给刚创建的插口绑定IP地址和端口结构</li><li>int listen(int socket,int backlog) 定义在指定插口上有多少待处理的连接</li><li>int accept(int socket,struct addr *address,int addr_len) 执行被动打开</li><li>int connect(int socket,structaddr *address,int addr_len) 主动打开，建立连接</li><li>int send(int socket,char *message,int message_len,int flags) 在给定插口上发送数据</li><li>int recv(int socket,char *buffer,int buffer_len,int flags) 在给定插口上接收数据到给定缓冲</li></ul></li><li><p>客户端Socket程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* active open */</span> </span><br><span class="line"><span class="keyword">if</span> ((s = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>); &#125; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(s, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">&#123; <span class="built_in">close</span>(s); <span class="built_in">exit</span>(<span class="number">1</span>); &#125; </span><br><span class="line"><span class="comment">/* main loop: get and send lines of text */</span> </span><br><span class="line"><span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>)) </span><br><span class="line">&#123; buf[MAX_LINE<span class="number">-1</span>] = ’\<span class="number">0</span>’;</span><br><span class="line"> len = <span class="built_in">strlen</span>(buf) + <span class="number">1</span>;</span><br><span class="line">  send(s, buf, len, <span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器端Socket程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* setup passive open */</span> </span><br><span class="line"><span class="keyword">if</span> ((s = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>) </span><br><span class="line">&#123; <span class="built_in">exit</span>(<span class="number">1</span>); &#125; <span class="keyword">if</span> ((bind(s, (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>))) &lt; <span class="number">0</span>)</span><br><span class="line"> &#123; <span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line"> <span class="built_in">listen</span>(s, MAX_PENDING);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)  &#123; </span><br><span class="line">    <span class="keyword">if</span> ((new_s = accept(s, (struct sockaddr *)&amp;<span class="built_in">sin</span>, &amp;len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="keyword">while</span> (len = recv(new_s, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>)) </span><br><span class="line">    <span class="built_in">fputs</span>(buf, <span class="built_in">stdout</span>); </span><br><span class="line">    <span class="built_in">close</span>(new_s); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>两种体系结构，Internet证明了了Internet architecture的胜利<br>什么是Internet？</p><ol><li>The largest network of networks in the world.</li><li>Uses TCP/IP protocols and packet switching .</li><li>Runs on any communications substrate.</li></ol><p>第一层：Backbone中转网：国家或世界级网络主干<br>美NFSnet/欧Ebone/中Chinanet/CERNET<br>第二层：Transit地区性网：覆盖省、洲、国家,<br>提供到因特网的连接 因特网服务提供者ISP<br>第三层：Stub组织性网：本地服务提供商；是一个自治网络系统，有AS号 校园网、企业网、公司网、政府网 由外围网关接入地区性网络</p><p>In 1994, the Clinton Administration privatized the internet backbone. Commercial firms took over the job of carrying long-distance internet traffic<br><img src="/public/现代计算机网络课程笔记（一）/12.png" alt></p><p><img src="/public/现代计算机网络课程笔记（一）/13.png" alt><br><a href="https://live.infrapedia.com/" target="_blank" rel="noopener">https://live.infrapedia.com/</a><br><img src="/public/现代计算机网络课程笔记（一）/14.png" alt></p><h3 id="1-1-4-网络性能测量与评价"><a href="#1-1-4-网络性能测量与评价" class="headerlink" title="1.1.4 网络性能测量与评价"></a>1.1.4 网络性能测量与评价</h3><ul><li><p>性能测量的两个参数：带宽和延迟</p><ul><li>带宽(Bandwidth):Hz,KHz,MHz,GHz，bps<ul><li>信号带宽：构成一信号的各种不同频率成分所占据的频率范围。如人类声音 带宽为：3300Hz－300＝声音带宽3000Hz</li><li>媒体带宽：通信媒体允许通过的信号频带范围</li><li>比特率：某时段内网络上可能传输的比特数，或传输每比特数据所需的时间 宽度。习惯把“带宽”作为数字信道的数据率或比特率</li><li>比特率越高，高频分量越多，频率范围越大，信号带宽越高。</li></ul></li><li><p>吞吐率(Throughput)：bps</p><ul><li>数字信号的发送速率，因此发送带宽也成为吞吐率</li><li>由于各种影响 10M 带宽实际完成 2Mbps</li><li>吞吐率：链路上实际每秒传输的比特数</li></ul></li><li><p>延迟：</p><ul><li>Delay : 把一个报文从网络一端传输到另一端所需的时间one way，光传播 速度：<ul><li>3.0x108m/s ;光在真空内传播的速率  2.8x108m/s ;电在Cable内传播的速率</li><li>2.0x108m/s ;光在Fiber内传播的速率</li></ul></li><li>Round Trip Time (RTT):发收来回时间（2次时延）</li><li>定义：延迟 = 处理＋排队+传输+传播，主要考虑后两个<ul><li>处理时延：检查包首部、决定导向何处；比特差错检测，高速Router一般在微秒 或更低数量级，接收完整的一个分组的时间＝包容量/链路速率</li><li>排队时延：等待输出链路空闲，与当时流量和排队规则有关</li><li>传输时延：数据量/带宽；微秒到毫秒级</li><li>传播时延：距离/光速(光缆中1000km传播延迟约5ms) 广域网在毫秒级</li></ul></li></ul></li><li><p>传输/传播的比较</p><ul><li>传输时延是路由器把分组发送出去所需时间，由数据量和链路实际带宽 决定，与两个路由器间距离无关，</li><li>传播时延是一个比特从发送路由器到接收路由器传播所需的时间，是距 离的函数，ms级</li></ul></li><li>例子：10辆汽车（P）在两个收费站（R）间的高速公路上行驶（ 总距离=车身+路）<br>处理 排队 传输 传播<br>RA</li></ul></li></ul><p>端到端吞吐率 = 实际传输 大小/传输时间  实际传输时间 = RTT+ 传输 大小/信道带宽<br>RTT：请求与回答时间<br>发送器<br>传播 延迟<br>传输 延迟<br>节点A<br>节点B正在链路上传输的比特数＝链路的容量<br>问题：信道带宽1Gbps，一端到另一端传播时 延τ= 10ms，TCP发送窗口65535字节。问可 能达到的最大吞吐率T ？信道利用率ρ？<br>解析：T= size/(2τ+size/BW)<br>= size<em>BW/(2τ</em>BW+size) bps<br>= 65535<em>8</em>109/(20<em>109</em>10-3s+65535<em>8)bps<br>= 524280</em>103/(20 *106 +524280)Mbps<br>= 25.5 Mbps，ρ=25.5M/1000M=2.55%</p><p>此图表示 RTT 和传输时延对整个传输效 果的影响，纵轴表示整体感觉到时延</p><p>对 1byte 对象（键盘）其延迟同 RTT 几 乎相等，故不能区别 1.5M 和 10M 的网络</p><p>对 2Kb 对象（ email ）链路速率是 RTT=1ms 时和 1byte 区别很大，然在 RTT=100ms 时差别又可忽略</p><p>对 1 Mb 对象（数字图象）， RTT 没有造 成不同，带宽支配延迟性</p><p>1-MB object, 1.5-Mbps link 1-MB object, 10-Mbps link 2-KB object, 1.5-Mbps link 2-KB object, 10-Mbps link 1-byte object, 1.5-Mbps link 1-byte object, 10-Mbps link</p><p>带宽和延迟的组合可描述链路或信道的特征，其相对重 要性取决于具体的应用<br> 有些应用延迟支配带宽（SSH），如端客户发送1字节到服务器 并依次收到1字节就是延迟重要，如果响应中没有大量的计算， 由于跨洲信道要100ms的RTT，同一房间内仅1ms RTT，所以不 同延迟导致完全不同效果<br> 数字图书馆来说是带宽支配延迟。设带宽10Mbps,则需 20s(2.5MByte的一个图片)，信道是1ms或者100ms延迟不重要， 20.001s和20.1s之差可略</p><p>延迟带宽积（以太网相关参数）  一对进程通道间的延迟(总体延迟)带宽积：信道管道的体积=链路上所 容纳的比特数  一个信道延迟=50ms ,带宽45Mbps, 则能容纳=50ms<em> 45Mbps=50</em>103 sec*45Mbits/sec =2.25Mbits  等价于信道上同时可以存在281K个Byte信号（2.25M/8）<br>Bandwidth<br>Delay</p><p> Quality of Service  连通性，  吞吐量，带宽，  延迟，延迟抖动  丢包，丢包率  可靠性、可用性  Experience of Service  与网络QoS、应用特质、用户感受相关</p><p>电子邮件 Telnet 声音 组播视频通信 延迟 几分～几小时 几分～几秒 几秒 毫秒～秒 丢失率 0％ 0％ 小于 25％ 允许/平均分布 连续性 无要求 可等待 连续 连续 同步 无要求 无要求 无 有 抖动 无要求 无要求 无串音 不允许</p><p>加性参数<br>时延、抖动、路径长度、路由代价…<br>满足可加性：通道特性由沿途各段链路相加决定<br>乘性参数  可靠性、丢包率  满足可乘性：度量为各链路或设备的乘积…<br>极性参数（最短木板原理）  带宽、剩余能量、生存时间、吞吐量…  满足极值要求（凹性或凸性），由通道或设备的瓶颈属性（极 值）决定</p><p>什么是传输可靠性  数据最小颗粒能正确到达  数据不同分片能有序到达（当采用分组交换时）<br>计算机网络并不是一个完备的世界  机器坏/光纤断/电接口受干扰/交换缓存溢出<br>网络设计者要考虑三种类型的故障 1）链路上的单比特错，突发连续比特错。  铜缆：106—-107  光缆：1012—1014 2）包错：一个包在网络上丢失  包中包含有不可纠正的比特错  中继接点因故（缓冲满，TTL）丢掉  输出链路故障等</p><p>3）结点和链路级故障  物理链路断  相连计算机崩溃  电源断电  操作失误<br>关键思想：既满足应用的需求又控制在当前技术的极限  挑战：弥补应用希望和当前技术之间的间隙</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode精解[2]两数相加</title>
    <url>/leetcode%E7%B2%BE%E8%A7%A3%5B2%5D%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Category Difficulty Likes Dislikes<br>algorithms Medium (35.93%) 3299 -<br>Tags<br>Companies<br>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><a id="more"></a><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法来自：力扣（LeetCode）：<a href="https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode/</a></p><p>方法：初等数学<br>思路</p><p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。</p><p>图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807，每个结点都包含一个数字，并且数字按位逆序存储。</p><p>算法</p><p>就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1 和 l2l2 的表头开始相加。由于每位数字都应当处于 0 \ldots 90…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1carry=1 带入下一次迭代。进位 carrycarry 必定是 00 或 11，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 199+9+1=19。</p><p>伪代码如下：</p><p>将当前结点初始化为返回列表的哑结点。<br>将进位 carrycarry 初始化为 00。<br>将 pp 和 qq 分别初始化为列表 l1l1 和 l2l2 的头部。<br>遍历列表 l1l1 和 l2l2 直至到达它们的尾端。<br>将 xx 设为结点 pp 的值。如果 pp 已经到达 l1l1 的末尾，则将其值设置为 00。<br>将 yy 设为结点 qq 的值。如果 qq 已经到达 l2l2 的末尾，则将其值设置为 00。<br>设定 sum = x + y + carrysum=x+y+carry。<br>更新进位的值，carry = sum / 10carry=sum/10。<br>创建一个数值为 (sum \bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。<br>同时，将 pp 和 qq 前进到下一个结点。<br>检查 carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 11 的新结点。<br>返回哑结点的下一个结点。<br>请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。</p><p>请特别注意以下情况：</p><p>测试用例 说明<br>l1=[0,1]l1=[0,1]，l2=[0,1,2]l2=[0,1,2] 当一个列表比另一个列表长时<br>l1=[]l1=[]，l2=[0,1]l2=[0,1] 当一个列表为空时，即出现空列表<br>l1=[9,9]l1=[9,9]，l2=[1]l2=[1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘<br>Java<br>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {<br>ListNode dummyHead = new ListNode(0);<br>ListNode p = l1, q = l2, curr = dummyHead;<br>int carry = 0;<br>while (p != null || q != null) {<br>int x = (p != null) ? p.val : 0;<br>int y = (q != null) ? q.val : 0;<br>int sum = carry + x + y;<br>carry = sum / 10;<br>curr.next = new ListNode(sum % 10);<br>curr = curr.next;<br>if (p != null) p = p.next;<br>if (q != null) q = q.next;<br>}<br>if (carry &gt; 0) {<br>curr.next = new ListNode(carry);<br>}<br>return dummyHead.next;<br>}<br>复杂度分析</p><p>时间复杂度：O(\max(m, n))O(max(m,n))，假设 mm 和 nn 分别表示 l1l1 和 l2l2 的长度，上面的算法最多重复 \max(m, n)max(m,n) 次。</p><p>空间复杂度：O(\max(m, n))O(max(m,n))， 新列表的长度最多为 \max(m,n) + 1max(m,n)+1。</p><p>拓展</p><p>如果链表中的数字不是按逆序存储的呢？例如：</p><p>(3 \to 4 \to 2) + (4 \to 6 \to 5) = 8 \to 0 \to 7<br>(3→4→2)+(4→6→5)=8→0→7</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下CUDA环境管理</title>
    <url>/Linux%E4%B8%8BCUDA%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p></p><p style="text-indent:2em">作为一位深度神经网络设计者（调参侠），除了需要掌握各种神经网络结构相关知识外，还需要熟悉服务器端显卡管理。我们在此采用的Linux发行版Ubuntu18.04，来对显卡管理涉及到的Cuda版本选择、Linux命令等进行介绍。</p><p></p><a id="more"></a><h1 id="二、-Cuda、Cudnn、显卡驱动以及Tensorflow框架版本对照表"><a href="#二、-Cuda、Cudnn、显卡驱动以及Tensorflow框架版本对照表" class="headerlink" title="二、 Cuda、Cudnn、显卡驱动以及Tensorflow框架版本对照表"></a>二、 Cuda、Cudnn、显卡驱动以及Tensorflow框架版本对照表</h1><center>Cuda与显卡驱动版本对照表</center><table><thead><tr><th>CUDA Toolkit</th><th>Linux x86_64 Driver Version</th><th>Windows x86_64 Driver Version</th></tr></thead><tbody><tr><td>CUDA 10.1 (10.1.105 general release, and updates)</td><td>&gt;= 418.39</td><td>&gt;= 418.96</td></tr><tr><td>CUDA 10.0.130</td><td>&gt;= 410.48</td><td>&gt;= 411.31</td></tr><tr><td>CUDA 9.2 (9.2.148 Update 1)</td><td>&gt;= 396.37</td><td>&gt;= 398.26</td></tr><tr><td>CUDA 9.2 (9.2.88)</td><td>&gt;= 396.26</td><td>&gt;= 397.44</td></tr><tr><td>CUDA 9.1 (9.1.85)</td><td>&gt;= 390.46</td><td>&gt;= 391.29</td></tr><tr><td>CUDA 9.0 (9.0.76)</td><td>&gt;= 384.81</td><td>&gt;= 385.54</td></tr><tr><td>CUDA 8.0 (8.0.61 GA2)</td><td>&gt;= 375.26</td><td>&gt;= 376.51</td></tr><tr><td>CUDA 8.0 (8.0.44)</td><td>&gt;= 367.48</td><td>&gt;= 369.30</td></tr><tr><td>CUDA 7.5 (7.5.16)</td><td>&gt;= 352.31</td><td>&gt;= 353.66</td></tr><tr><td>CUDA 7.0 (7.0.28)</td><td>&gt;= 346.46</td><td>&gt;= 347.62</td></tr></tbody></table><center>Cuda、cudNN与Tensorflow版本对照表</center><table><thead><tr><th>版本</th><th>Python 版本</th><th>编译器</th><th>编译工具</th><th>cuDNN</th><th>CUDA</th></tr></thead><tbody><tr><td>tensorflow_gpu-1.13.1</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.19.2</td><td>7.4</td><td>10.0</td></tr><tr><td>tensorflow_gpu-1.12.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.15.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.11.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.15.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.10.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.15.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.9.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.11.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.8.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.10.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.7.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.9.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.6.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.9.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.5.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.8.0</td><td>7</td><td>9</td></tr><tr><td>tensorflow_gpu-1.4.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.5.4</td><td>6</td><td>8</td></tr><tr><td>tensorflow_gpu-1.3.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.4.5</td><td>6</td><td>8</td></tr><tr><td>tensorflow_gpu-1.2.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.4.5</td><td>5.1</td><td>8</td></tr><tr><td>tensorflow_gpu-1.1.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.4.2</td><td>5.1</td><td>8</td></tr><tr><td>tensorflow_gpu-1.0.0</td><td>2.7、3.3-3.6</td><td>GCC 4.8</td><td>Bazel 0.4.2</td><td>5.1</td><td>8</td></tr></tbody></table><h1 id="三、Linux下Cuda管理相关命令"><a href="#三、Linux下Cuda管理相关命令" class="headerlink" title="三、Linux下Cuda管理相关命令"></a>三、Linux下Cuda管理相关命令</h1><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>查看cuda版本</td><td>nvcc -V</td></tr><tr><td>查看cuda安装位置</td><td>which nvcc</td></tr><tr><td>查看NVIDIA动态使用情况</td><td>watch -n 1 nvidia-smi</td></tr><tr><td>cuda 版本</td><td>cat /usr/local/cuda/version.txt</td></tr><tr><td>cudnn 版本</td><td>cat /usr/local/cuda/include/cudnn.h \</td><td>grep CUDNN_MAJOR -A 2</td></tr><tr><td>NVIDIA 驱动版本</td><td>cat /proc/driver/nvidia/version</td></tr><tr><td>查看环境变量</td><td>env</td></tr><tr><td>卸载cuda</td><td>sudo /usr/local/cuda-8.0/bin/uninstall_cuda_8.0.pl</td></tr><tr><td>卸载NVIDIA Driver</td><td>sudo /usr/bin/nvidia-uninstall</td></tr></tbody></table><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>CUDA、Nvidia驱动版本对照：<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html" target="_blank" rel="noopener">https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html</a><br>CUDA、cuDNN与Tensorflow版本对照：<a href="https://tensorflow.google.cn/install/source" target="_blank" rel="noopener">https://tensorflow.google.cn/install/source</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Linux系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>诸神之眼-Nmap命令总结：第一章 走进Nmap</title>
    <url>/%E8%AF%B8%E7%A5%9E%E4%B9%8B%E7%9C%BC-Nmap%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%EF%BC%9A%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%B5%B0%E8%BF%9BNmap/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><ol><li><p>基本操作<br>对目的IP进行搜扫描<br>Nmap + 目的IP</p></li><li><p>扫描范围确定<br>a. 对连续范围内的主机进行扫描</p><pre><code>语法： Nmap [IP地址的范围] 

Nmap -sn 192.168.0.1-255
</code></pre><p>b. 对整个子网进行扫描</p><pre><code>语法： Nmap [IP地址/掩码位数]

Nmap -sn 192.168.0.1/24
</code></pre><p>c. 对不连续的主机进行扫描</p><pre><code>语法： Nmap [扫描目标1 扫描目标2, … 扫描目标n]
</code></pre><p>d. 在扫描的时候排除指定的目标</p><pre><code>语法： Nmap [目标[ --exclude [目标]

Nmap -sn 192.168.0.0/24 --exclude 192.168.0.2
</code></pre><p>e. 对一个文本地址中的地址列表进行扫描</p><pre><code>语法： Nmap -iL [文本文件]

Nmap -sn -sL List.txt
</code></pre><p>f. 随机确定扫描目标</p><pre><code>语法： Nmap -iR [目标的数量]

   Nmap -sn -iR 3
</code></pre></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>网络空间安全</category>
      </categories>
      <tags>
        <tag>Nmap</tag>
        <tag>网络审计</tag>
      </tags>
  </entry>
  <entry>
    <title>leecode精解[1]两数之和</title>
    <url>/leetcode%E7%B2%BE%E8%A7%A3%5B1%5D%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><table><thead><tr><th>Category</th><th>Difficulty</th><th>Likes</th><th>Dislikes</th></tr></thead><tbody><tr><td>algorithms</td><td>Easy (46.94%)</td><td>6747</td><td>-</td></tr></tbody></table><p>给定一个整数数组 <font color="orange">nums</font> 和一个目标值<font color="orange">target</font>，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><a id="more"></a><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><!--more--><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法来自：力扣（LeetCode）：<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/</a></p><p>方法一：暴力法<br>暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n^2)O(n<br>2<br>)，<br>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n<br>2<br>)。</p><p>空间复杂度：O(1)O(1)。</p><p>方法二：两遍哈希表<br>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p><p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#Java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><p>时间复杂度：O(n)O(n)，<br>我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。</p><p>空间复杂度：O(n)O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。</p><p>方法三：一遍哈希表<br>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><p><code>`</code>java</p><p>#Java<br>class Solution {<br>public int[] twoSum(int[] nums, int target) {<br>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>for (int i = 0; i &lt; nums.length; i++) {<br>int complement = target - nums[i];<br>if (map.containsKey(complement)) {<br>return new int[] { map.get(complement), i };<br>}<br>map.put(nums[i], i);<br>}<br>throw new IllegalArgumentException(“No two sum solution”);<br>}<br>}<br><code>`</code>java</p><p>复杂度分析：</p><p>时间复杂度：O(n)O(n)，<br>我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。</p><p>空间复杂度：O(n)O(n)，<br>所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。</p><p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>知识表示研究进展梳理</title>
    <url>/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><p><img src="/images/Mindmap_KnowledgeExpression.png" alt="Mind Map of Knowledge Expression"></p><a id="more"></a><!-- rebuild by neat -->]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>思维导图</tag>
        <tag>知识表示</tag>
      </tags>
  </entry>
  <entry>
    <title>知识抽取研究进展梳理</title>
    <url>/%E7%9F%A5%E8%AF%86%E6%8A%BD%E5%8F%96%E7%A0%94%E7%A9%B6%E8%BF%9B%E5%B1%95%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 17:10:04 GMT+0800 (China Standard Time) --><p><img src="/images/Mindmap_KnowledgeExtraction.png" alt="Mind Map of Knowledge Extraction"></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>知识抽取式是实现自动化构建度规模知识图谱的重要技术。本节围绕知识抽取相关技术进行介绍，并构建思维导图。</p><a id="more"></a><h1 id="非结构化知识抽取"><a href="#非结构化知识抽取" class="headerlink" title="非结构化知识抽取"></a>非结构化知识抽取</h1><h2 id="实体抽取"><a href="#实体抽取" class="headerlink" title="实体抽取"></a>实体抽取</h2><p>2.1.1 基于<strong>规则</strong>的方法：人编写的规则<br>2.1.2 基于<strong>统计模型</strong>的方法：隐马尔可夫模型、条件马尔可夫模型、最大熵模型、条件随机场模型。<br>2.1.3 基于<strong>深度学习</strong>的方法：LSTM-CRF、LSTM-CNNs-CRF、基于注意力机制的神经网络<br>s</p><h2 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a>关系抽取</h2><p>2.2.1 基于<strong>模板</strong>的方法：如“小明”的同桌“小红”，小明与小红是同桌关系<br>2.2.2 基于<strong>监督</strong>的方法：转化为分类问题，基于深度学习CR-CNN,ATTENTIONI CNNs、Attention BLSTM基于深度学习的联合关系抽取方法：将实体抽取和关系抽取相结合<br>2.2.3 基于<strong>弱监督</strong>的方法：1. 远程监督方法 2. bootstrapping方法</p><h2 id="事件抽取"><a href="#事件抽取" class="headerlink" title="事件抽取"></a>事件抽取</h2><p>2.3.1 <strong>流水线</strong>方法：将抽取任务分解为一系列基于分类任务的子任务。流水线上有众多分类器。会导致误差不断积累。<br>2.3.2 <strong>联合抽取</strong>方法：实践的所有相关信息可以通过一个模型同时抽取出来。一般地，联合时间抽取方法可以采用联合推断或联合建模的非让发。</p><h1 id="半结构化知识抽取"><a href="#半结构化知识抽取" class="headerlink" title="半结构化知识抽取"></a>半结构化知识抽取</h1><h2 id="面向Web-网页数据"><a href="#面向Web-网页数据" class="headerlink" title="面向Web 网页数据"></a>面向Web 网页数据</h2><p>3.1.1 <strong>手工</strong>方法：XPath表达式，CSS选择器<br>3.1.2 <strong>包装器归纳</strong>方法：基于有监督学习方法从已标注的训练样例集合中学习信息抽取的规则，然后通用该模板，对其他网页进行抽取。<br>3.1.3 <strong>自动抽取</strong>方法：相似的网页首先通过聚类分成若干组，通过挖掘 同一组中相似网页的重复模式，可以生成适用于该组网页的包装器。</p><h1 id="结构化数据的知识抽取"><a href="#结构化数据的知识抽取" class="headerlink" title="结构化数据的知识抽取"></a>结构化数据的知识抽取</h1><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p>从关系户据库到RDF图数据的简单转换，为定义和比较更复杂的转换提供了基础。</p><h2 id="R2RML"><a href="#R2RML" class="headerlink" title="R2RML"></a>R2RML</h2><p>R2RML映射语言是一种用于表示从关系数据库到RDF数据集的自定义映射的语言。这种映射提供了在RDF数据模型下查看现有关系型数据对策能力，并且可以基于用户自定义的结构和目标词汇表示原有的关系型数据。每个R2RML映射都针对特定的数据库模式和目标词汇量身定制。<br>输入为符合该模式的关系数据库，输出是采用目标词汇表中谓词和类型描述的RDFG数据集。</p><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><p>4.3.1 D2RQ<br>4.3.2 Mastro<br>4.3.3 Ultrawrap<br>4.3.4 Morph-RDB<br>4.3.5 Ontop</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]王昊奋，漆桂林. 知识图谱:方法、实践与应用[M]. 北京：电子工业出版社, 2019<br>[2]赵军，刘康, 何世柱， 陈玉博. 知识图谱[M]. 北京：高等教育出版社,2018</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>知识抽取</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
</search>
